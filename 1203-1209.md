<h1>
    1203
</h1>

- Word Counter를 만들면서 느낀점

```
for(let i = 0; i < arr.length; i++) {
    ...
}
을
for(let i = arr.length - 1; i >= 0; i--) {
    ...
}
으로 바꾸기만해도 해결되는 문제가 많다는것.
```

```
javascript로 css를 다루는게 마냥 어렵고 두려울일이 아니라는것.
정말 재미있다는것.
```

```
함수에 인자를 전달해서 프로그래밍하는것에 조금은 더 친숙해진것.
```



CSS box-sizing : border-box;

```
예측하기어려운 border의 크기를 알기쉽게 바꿔준다.
기본값은 box-sizing : content-box;이다.
```



```
스크롤바 커스터마이징

.frequency::-webkit-scrollbar-thumb {
    ...
}

.frequency::-webkit-scrollbar {
    ...
}

이런식으로 작업했음. thumb은 막대.
```



<h1>
    1204
</h1>

git branch [브랜치명]

git checkout [브랜치명]

<hr>

drag and drop을 더 공부해서 완벽히 이해할 필요가 있다고봅니다.

<a href = "https://www.kirupa.com/html5/drag.htm">드래그 공부</a>

```
중요한건 움직일대상의 position : absolute인 줄 알았는데 또 링크를 보면 그런것만도 아니다.

"mousedown"
"mouseup"
"mousemove"
가 중요한것같음.

많이 연습해보고 체득할것.
```



<h3>ajax</h3>

```
<input type = "button" value = "fetch" onclick = "fetch('html').then(function(response) {
    response.text().then(function(text) {
        document.querySelector('article').innerHTML = text;
    })
})"

fetch라는 버튼을 누르니깐 html파일의 내용이 innerHTML로 들어옵니다.
여기서 제가 알 수 있는것은...

fetch('html')이라는 부분에서 html파일을 선택하는 것이고,
document.querySelecor('article').innerHTML = text; 라는 부분이 내가 하려고하는 행동인것을 알 수 있었습니다.
```

```
<input type = "button" value = "fetch" onclick = "
	function callbackme() {
        console.log('end~?');
	}
	fetch('html').then(callbackme);
">

"fetch야. 응답이 끝나면~ 너 할일 다 끝나면~ 그다음에 then을 실행시켜줘!"

<input type = "button" value = "fetch" onclick = "
	function callbackme() {
        console.log('end~?');
	}
	fetch('html').then(callbackme);
	console.log(1);
	console.log(2);
">

이렇게 작성한다면, 콘솔창에 1, 2가 출력된 다음에 end~?가 출력됩니다.
웹브라우저가 응답받는것이 끝나면, 그때서야 then을 실행시키기 때문이죠.
```



<hr>

Prototype : 원래의 형태 또는 전형적인 예. 기준 또는 표준.

Constructor : 생성자 함수
-> new 키워드와 함께 쓰이는 함수. 를 생성자 함수라고 말한다.

new Array();
new Object();
new Function();

생성자 함수는 일반적으로 첫글자를 대문자로 표기합니다.

"(거의)모든 자바스크립트 객체는 생성자 함수를 이용해 만들어집니다."

생성자 함수는 말 그대로 함수입니다.
모든 함수는 객체입니다.
고로, 생성자 함수 또한 객체입니다.

객체란?
key/value를 가질 수 있습니다.(속성/값)
고로, 생성자 함수는 key/value를 가질 수 있습니다.
예를 들면? Object.prototype

우리가 생성자 함수를 만들 수 있습니다.
생성자 함수이냐 아니냐는 단지 그 쓰임새에 달린 문제입니다.(앞에 new를 붙여서 생성자 함수로 쓰느냐..아니냐..)

Constructor(생성자함수) 에게는 항상 .prototype이 있고 그 결과는 Prototype이라는 객체이다.(prototype이라는 속성이 있다.)
이 Prototype이라는 객체에게는 .constructor(constructor라는 객체)가 또 있다.



<h1>
    1206
</h1>

```
template literal을 배워서 조금씩 써먹어보고 있습니다.
정보가 담겨있는 객체의 내용을 web에서 보여주고 싶었습니다.

result.innerHTML = `번호 : ${list[i].number}
            상호명 : ${list[i].name}
            일자 : ${list[i].date}
            상세설명 : ${list[i].explanation}`
            
이런식으루요.
안됐습니다.
template literal을 사용한다면 <br>없이도 가능할줄 알았는데 아니었습니다..

```

```
login을 만들면서 가운데 정렬을 하고 싶었습니다.
position : absolute,
left : 50%,
top : 50%
를 적용했습니다.

border의 왼쪽 변과, 윗변이 만나는 꼭지점을 기준으로 정렬이 되었습니다.
오른쪽 하단으로 치우쳐진 박스가 생긴거죠.
검색을해보니,

transform : translate(-50%, -50%)로 해결한다는것을 찾았습니다.
```

