<h1>
  0415
</h1>

<h3>
    이벤트루프
</h3>

자바스크립트의 특징 중 하나는 "단일 스레드"기반의 언어라는 점입니다.

스레드가 하나라는 말은, 곧 동시에 하나의 작업만을 처리할 수 있다라는 말과 같습니다.

하지만 자바스크립트는 여러가지의 일을 동시에 처리하는 것처럼 보입니다.

이때 등장하는 개념이 "이벤트 루프"입니다.

즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하는 것입니다.



실제로, V8같은 자바스크립트 엔진은 콜스택을 사용하며, 요청이 들어올때마다 해당 요청을 순차적으로 콜스택에 담아서 처리할 뿐입니다.

이때, 비동기 요청은 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 node.js가 담당합니다.



V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2가지의 영역으로 나뉩니다.

```
콜스택
: 작업이 요청되면(함수가 호출되면) 요청된 작업은 순차적으로 콜스택에 쌓이고, 순차적으로 실행됩니다.
자바스크립트는 단 하나의 콜스택을 사용하기에 해당 task가 종료되기 전까지는 다른 어떤 task도 실행될 수 없습니다.
```

```
힙
: 동적으로 생성된 객체 인스턴스가 할당되는 영역입니다.
```

비동기 요청 처리는 자바스크립트 엔진을 구동하는 환경(브라우저나 node.js)는 다음과 같이 구성되어 있습니다.

```
이벤트큐
:비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, timer 함수의 콜백 함수가 보관되는 영역으로, 이벤트 루프에 의해 특정시점(콜스택이 비워졌을 때)에 순차적으로 콜스택으로 이동되어 실행되어집니다.
```

```
이벤트루프
: 콜스택 내에서 현재 실행중이 task가 있는지, 그리고 이벤트큐에 task가 있는지를 반복하여 확인합니다.
만약 콜스택이 비어져있다면, 이벤트큐 내의 task가 콜스택으로 이동되어 실행되어집니다.
```



<h3>
    이벤트의 흐름
</h3>

: 계층적 구조에 포함되어 있는 HTML요소에 이벤트가 발생할 경우 연쇄적 반응이 일어납니다.

이를 이벤트 전파, Event Propagation이라고 합니다.

그리고 이 전파 방향에 따라 버블링과 캡쳐링으로 구분할 수 있습니다.

자식요소에서부터 발생한 이벤트가 부모 요소로 전파되는 것을 버블링이라고 합니다.

거품이 올라가는 모습을 상상하면 되겠네요.

자식요소에서부터 발생한 이벤트가 부모요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것을 캡쳐링이라고 합니다.

부모가 자식을 잡으러 가는...캡쳐링....

중요한 점은, 버블링과 캡쳐링이 둘 중 하나만 발생하는 것이 아니라, 캡처링부터 시작하여 버블링으로 종료한다는 점입니다.

<h4>
event.stopPropagation()
</h4>

```
function logEvent(event) {
    event.stopPropagation();
}
```

위 API는 해당 이벤트가 전파되는 것을 막습니다.

따라서, 이벤트 버블링의 경우에는 클릭한 요소의 이벤트만 발생시키고 사우이 요소로 이벤트를 전달하는 것을 방해합니다.

그렇다면 이벤트 캡쳐링의 경우에는 클릭한 요소의 최상위 요소의 이벤트만 동작시키고 하위 요소들로 이벤트를 전달할지 않을 것입니다.



<h4>
    event delegation
</h4>

'하위 요소에 각각 이벤트를 붙이지않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식'으로 말할 수 있습니다.

```
<ul class="itemList">
	<li>
		<input type="checkbox" id="item1">
		<label for="item1">111</label>
	</li>
	<li>
		<input type="checkbox" id="item2">
		<label for="item2">2</label>
	</li>
</ul>
```

```
var inputs = document.querySelectorAll('input');
inputs.forEach(function(input) {
	input.addEventListener('click', function(event) {
		alert('clicked');
	});
});
```

할 일 목록을 만들었고, 클릭하면 alert이 실행되는 이벤트를 만들었습니다.

여기서 만약에 할 일이 더 생겨서 리스트에 아이템을 추가한다면..

```
var itemList = document.querySelector('.itemList');

var li = document.createElement('li');
var input = document.createElement('input');
var label = document.createElement('label');
var labelText = document.createTextNode('333');

input.setAttribute('type', 'checkbox');
input.setAttribute('id', 'item3');
label.setAttribute('for', 'item3');
label.appendChild(labelText);
li.appendChild(input);
li.appendChild(label);
itemList.appendChild(li);
```

새로 생긴 아이템은 클릭해도 이벤트가 동작하지않습니다.

input 박스에 이벤트 리스너를 추가하는 시점에서 리스트아이템은 2개였기때문에, 새로 생긴 아이템 리스트에는 클릭 이벤트 리스너가 등록되지 않았기 때문입니다.

이런식이라면 새롭게 추가된 리스트 아이템에는 매번 클릭 이벤트 리스너를 일일이 달아줘야하는 문제가 생깁니다.

이런 상황에서는 li태그에 이벤트를 등록하는 것보다, 상위 태그인 ul태그에 이벤트를 등록하는게 해결방안이 될 수 있습니다.

이것이 바로 event delegation입니다.

```
var itemList = document.querySelector('.itemList');
itemList.addEventListener('click', function(event) {
	alert('clicked');
});
```





<h1>
  0416
</h1>

ES6의 클래스 문법

: es6 이전의 자바스크립트에는 클래스가 없었습니다.

개념 자체는 있었지만, 이를 구현하려면 class대신에 prototype을 사용해야했습니다.

~~~
function Dog(name) {
  this.name = name;
}

Dog.prototype.say = function() {
  console.log(this.name + " 멍멍");
}

var dog = new Dog("흰둥이");
dog.say();
~~~

es6문법부터는 이 코드와 동일한 기능을 class를 사용하여 잓성할 수 있습니다.

~~~
class Dog {
  constructor(name) {
    this.name = name;
  }
  
  say() {
    console.log(this.name + " 멍멍");
  }
}

const dog = new Dog("흰둥이");
dog.say();
~~~



- 

~~~
class MyComponent extends Component {
  constructor(props) {
    super(props);
  }
  
  render() {
    (...)
  }
}
~~~

MyComponent는 리액ㄱ트의 Component클래스를 상속합니다.

따로 constructor 메소드를 만들어주지않으면 Component 클래스의 생성자 메소드를 그대로 사용합니다.

직접 constructorr메소드를 작성하여 생성자 메소드에서 추가 작업을 하려면, 메쏘드 내부에서 부모 클래스인 Component의 constructo메소드를 먼저 호출해야합니다.

이때 super 키워드를 사용합니다.

컴포넌트를 만들때 props값들을 사용하므로 props 메소드의 파라미터로 전달합니다.



- 

~~~
constructor(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this);
}
~~~

컴포넌트에 임의 메소드를 만들면 기본적으로는 this에 접근할 수 없습니다.

따라서 컴포넌트의 생성자 메소드인 constructor에서 각 메소드를 this와 바인딩해주어야 합니다.

(메소드에서 this를 사용할 수 있도록 메소드에 this를 묶어주는 것입니다.)

이 작업을 하지 않으면 메소드에서 this를 부를때 undefined가 리턴됩니다.



<h1>
  0417
</h1>

디스트럭쳐링

: 배열 또는 객체를 비구조화하여 개별적인 변수에 할당하는 것

~~~
const arr = [1,2,3];

const [one, two, three] = arr;
~~~

~~~
const {prop1, prop2} = {prop1: "a", prop2: "b"};

console.log(prop1, prop2);	//a b
console.log({prop1, prop2});	// {prop1: "a", prop2: "b"}
~~~



<h1>
  0418
</h1>

execution context

~~~
실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념입니다.
좀 더 쉽게 말하면 실행 컨텍스트는 실행 각능한 코드가 실행도ㅣ기위해 필요한 환경으로 이해할 수 있습니다.
실행 가능한 코드란, 전역코드(전역 영역에 존재하는 코드), 함수코드(함숫 내에 존재하는 코드)등이 있습니다.
~~~

~~~
var x = 'xxx';

function foo() {
  var y = 'yyy';
  
  function bar() {
    var z = 'zzz';
    console.log(x+y+z);
  }
  bar();
}
foo();

위 코드를 실행하면 다음처럼 스택이 생성되고 소멸합니다.
1. (global)
전역 실행 컨텍스트가 생성되고 스택에 쌓입니다.
2. (global foo())
함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓이게됩니다.
3. (global foo() bar())
4. (global foo())
함수 실행이 끝나면 해당 함숫의 실행컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환합니다.
5. (global)
~~~

~~~
실행 컨텍스트는 추상적인 개념이지만, 물리적으로는 객체의 형태를 가지며 아래의 3가지 프로퍼티를 가지고 있습니다.
1. Variable object
2. Scope chain
3. thisValue
~~~

~~~
1.Variable object
Variable object는 다음과같은 정보를 담는 객체입니다.
1) 변수
2) 매개변수(parameter)와 인수정보(arguments)
3) 함수선언

Variable object는 실행 컨텍스트이기때문에 값을 갖는데 이 값은 다른 객체를 가리킵니다.
이때, 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할때 생성되는 함수 컨텍스트의 경우 가리키는 객체가 다릅니다.

variable object가 가리키는 객체는 다음과 같습니다.

1) 전역 컨텍스트일 경우(global)
: variable object는 유일하며 최상위에 위치하고 모든 전역변수, 전역함수 등을 포함하는 전역객체(global objectt)를 가리킵니다. 전역 객체는 전역에 선언된 전역변수와 전역함수를 프로퍼티로 소유합니다.
ex) {foo: Function Objecttt, x: 'xxx'} (전역함수 foo와 전역변수 x)

2) 함수 컨텍스트의 경우(foo())
variable objecdt는 activation object(활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고있는 객체인 arguments object가 추가됩니다.
ex) {arguments: {}, bar: Function Object, y: 'yyy'}(arguments 객체, 내부함수 bar, 지역변수 y)
~~~

~~~
2) Scope chain
스코프체인은 일종의 리스트입니다.
전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있습니다.
즉, 스코프체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 하뭇 선언등의 정보를 담고있ㅆ는 전역객체 또는 활성객체의 리스트를 가리킵니다.

현재 실행 컨텍스트의 활성 객체를 선두로하여 순차적으로 상위 컨텍스트의 활성 객체를 각리키며 마지막 리스트는 전역 객체를 가리킵니다.


"스코프 체인은 식별자 중에서 객체의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다."
"식별자 중에서 변수가 아닌 객체의 프로퍼티를 검색하는 메커니즘은 프로토타입 체인"이다.

엔진은 스코프체인을 통해 렋시컬 스코프를 파악핣니다.
함수가 중첩상태일경우, 하위함숫 내에서 상위함수의 쓰코프와 전역 스코프까지 참조할 수 있는데 이것ㅅ은 스코프 체인을 통해 가능한 것입니다.
함수가 중첩되어 있다면 중첩될때마다 부모함수의 쓰코프가 자식 함쑤의 스코프체인에 포함됩니다.
함숫ㅅ 실행중에 변수를 만난다면, 우선 현재 스코프(활성 객체)에섯 검색해보고, 만약 검색이 실패하면 스코프 체인에 담겨진 순섯대로 그 검색을 이어가게됩니다.
그래서 이름이 스코프 체인입니다.
~~~





<h1>
  0419
</h1>



- Vue.js책 구매 :  Do it! Vue.js 입문

~~~
vue.js란?
프론트엔드 프레임워크.
뷰 코어 라이브러리는 화면단 데이터 표현에 고간한 긴긍들을 중점적으로 지원할지만 프레임워크의 기능인 라우터, 상태 관리, 테스팅 등을 쉽게 결합할 수 있는 형태로도 제공합니다.
즉, 라이브러리 역할과 프레임워크의 역할을 겸비할 수 있습니다.
그래서 공식 사이트에서도 뷰를 점진적인 프레임워크(progressive framework)라고 합니다.
~~~

~~~
vue의 장점

첫째, 배우기가 쉽다!
둘째, 빠르다!
셋째, 리액트+앵귤러(리액트의 virtual dom + 앵귤러의 데이터 바인딩 특성)
~~~

vue.js의 특징

~~~
UI 화면단 라이브러리
- 뷰는 UI화면 개발 방법 중 하나인 MVVM패턴의 뷰 모델에 해당하는 화면단 라이브러리입니다.

MVVM패턴이란, 
화면을 모델(model)-뷰(view)-뷰 모델(viewmodel)로 구조화하여 개발하는 방식을 의미합니다.
뷰 : 사용자에게 보이는 화면
모델 : 데이터를 담는 용기(보통은 서버에서 가져온 데이터를 자바스크립트 객체형태로 저장)
뷰모델 : 뷰와 모델의 중간영역(돔 리스너와 데이터 바인딩을 제공하는 영역)
~~~

~~~
컴포넌트 기반 프레임워크
- 재사용하기 쉬운 컴포넌트..
~~~



~~~
node.js설치

1. nodejs.org 주소창 ㄱㄱ
2. LTS버전 다운로드
3. 설치를 진행.(노드제이에슷ㅅ와 NPM이 설치된다..!)
4. 터미널에서 node -v실행!(정상적으로 설치되었으면 노드제이에스 버전이 표시!)
~~~

~~~
뷰 개발자 도구 설치

1. vue.js devtools 검색
2. 설치
~~~



<h1>
  0420
</h1>

p40~

뷰 인스턴스

~~~
뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야하는 기본단위입니다.
~~~

뷰 인스턴스를 사용하기위해서는 다음곽같은 형식으로 뷰 인스턴스를 생성합니다.

~~~
new Vue({
  ...
});
~~~

다음은 샘플코드입니다.

~~~
<html>
	<head>
		<title>Vue Sample</title>
	</head>
	<body>
		<div id = "app">
			{{ message }}
		</div>
		<script src = "https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"></script>
		<script>
			new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue.js!'
        }
			});
		</script>
	</body>
</html>
~~~

~~~
new Vue({				// 여기섯부터 끝ㄲ가지 인스턴스입니다,
  el: '#app',		// el속성
  data: {				// data속성
  	message: 'Hello Vue.js!'
  }
});
~~~



1. 먼저 'Hello Vue.js!'를 화면에 표시하기위해 new Vue()로 뷰 인스턴스를 생성했습니다.
2. 인스턴스 안에 el속성으로 뷰 인스턴스가 그려질 지점을 지정하곡, data속ㄱ성에 message값ㅅ을 정의하여 화면의 {{ message }}에 연결하였습니다.



~~~
뷰 인스턴스 생성자
: new Vue()로 인스턴슷를 생성할때 Vue를 생성자라고 합니다.
Vue 생성자는 뷰 라이브러리를 로딩하고 나면 접근할 수 있습니다.
생성자를 사용하는 이유는 뷰로 개발할때 필요한 긱능들을 생성자에 미리 정의해놓곡 사용자가 그 긱능을 재정의하여 펴ㅕㄴ리하게 사용하도록 하기 위해서입니다.
~~~

~~~
뷰 인스턴스 옵션 속성
: 뷰 인스턴스 옵션 속성은 인씃턴스를 생성할 때 재정의할 data, el, template등의 속성을 의미합니다.
예를들어, Hello, Vue.js!예제에서는 data라는 미리 정의되어 있ㅆ는 속성을 사용하여ㅕㅆ습니다.
그 안에 message라는 새로운 속성을 추가하고 Hello Vue.js!라는 값ㅅ을 주었을 뿐입니다.
el속성역시 미리 정의되어 있으며, 뷰로 만든 화면이 끄려지는 시작점을 의미합니다.
뷰 인스턴스로 화면을 렌더링할때 화면이 그려질 위치의 돔 요소를 지정해주어야 합니다.

#app값은 화면의 돔 요소중에 app이라는 아이디를 가진 요소를 의미합니다.

이 외에도 template, methods, created등 미리 정의되어 있는 속ㄱ성을 삿용할 수 ㅅ있씁니다.
template : 화면에 표시할 html, css등의 마크업 요소를 정의하는 속성. 뷰의 데이터 및 기타 속성들도 함께 화면에 그릴 쑤 있습니다.
methods: 화면 로직 제어와 관계된 메서드를 정의하는 속성. 마우슷 클릭 이벤트 처리와 같이 화면의 전반저인 이벤트와 화면동작과 관련된 로직을 추가할 수 있습니다.
created : 뷰 인슷턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성. 뷰 인스턴스 라이프 사이클 부분에섯 추가로 공부하겍됩니다.
~~~

~~~
뷰 인스턴스의 유효범위
: 인스턴스의 유효범위란?
- 뷰 인스턴스를 생성하면 html의 특정 범위 안에서만 옵션 속ㄱ성들이 적용되어 나타납니다.
이를 인슷턴스의 유효범위라고 합니다.
앞으로 공부하게될 지역컴포넌트와 전역컴포넌트의 차이점을 이해하긱위해서 꼭알아야할 개념입니다.
인스턴스의 유효범위는 el속성과 밀접한 꽌계가 있습니다.

인스턴스으 ㅣ유효범위를 이해하려면 인스턴스가 생성된 후 화면에 어떻게 적용되는지 알아야합니다.
new Vue()로 인스턴스를 생성하고 나섯 화면에 인스턴스 옵션 쏙성을 적용하는 과정은 다음과 같습니다.

1) 뷰 라이브러리 파일 로딩
2) 인스턴스 객체 생성(옵션 속성 포함)
3) 특정 화면 요소에 인스턴스를 붙임
4) 인스턴슷 내용이 화면 요소로 변환
5) 변환된 화면 요소를 사용자가 최종확인

아까의 코드로 다시 이해해 본다면....
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!'
  }
});

먼저 자바스크립트 코드 상에서 인슷턴쓰 옵션속성 el과 data를 인스턴스에 정의하고 new Vue()로 인스턴스를 생성합니다.
그리고 브라우저에서 위 샘플 코드를 실행하면 다음과 같이 el속성에 지정한 화면요소(돔)에 인스턴스가 부착됩니다.

<div id = "app">
	{{message}}
</div>

el 속성에 인스턴스가 부착되고나면 인스턴스에 정의한 옵션 객체의 내용(data 속성)이 el속성에 지정한 화면 요소와 그 이하 레벨의 화면 요소에 적용되어 값이 치환됩니다.

{{ message }}에 'Hello Vue.js!'가 적용되어 치환되어 다음과 같이 변함.

<div id = "app">
	Hello Vue.js!
</div>
~~~

~~~
인스턴스의 유효범위확인
: 그런데 만약 인스턴스의 유효범위를 벗어나면 어떠헤 ㄱ될까요?
앞의 코드를 살짝 바꿔보겠습니다.

<div id = "app">

</div>
{{ message }}

이 코드는 단순히 {{ message }}를 출력하게됩니다.
message 속성의 값이 Hello Vue.js!로 밖뀌지않고 그대로 출려ㅕㄱ되는 이유는 인스턴슷의 유효범위를 벗어났기 때문입니다.

--인스턴스의 유효범위--
<div id = "app">

</div>
--인스턴스의 유효범위--
{{ message }}


현재 코드에서 인스턴슷의 유효범위는 el속성으로 지정한 <div id = "app">태그 아래에 오는 욧소들로 제한됩니다.
따라섯 <div>태그 바깥에 있ㅆ는 {{ message }}는 뷰에서 인식하지 못하기 때문에 Hello Vue.js!로 바뀌지않고 {{ message }}그대로 출력됩니다.
~~~

~~~
뷰 인쓰턴스 라이프 사이클
:앞에서 인스턴스의 속성 중 created를 잠시 언급했었ㅆ습니다.
인스턴스가 생성되었을 때 호출할 동작을 정의하는 속성입니다.
이처럼 인스턴스의 상태에 따라호출할 수 있는 속성들을 라이프사이클 속성이라고 합니다.
그리고 각 라이프 사이클 속성에섯 실행되는 커스텀 로직을 라이플 사이클 훅이라고 합니다.

라이플 사이클 속성에는 created, beforeCreate, beforeMount, mounted등 인스턴스의 생성, 변경, 소멸과 관련되어 총 8개가 있습니다.

[책 45p 그림 볼 것.]
~~~



<h1>
  0421
</h1>

p45

뷰 라이프 사이클

: 라이프 사이클 단계를 크게 나누면 인스턴스의 [생성], 생성된 인슷턴스를 화면에 [부착], 화면에 부착된 인스턴슷의 내용이 [갱신], 인슷턴스각 제거되는 [소멸]의 4단계로 이루어집니다.

~~~
beforeCreate
: 인스턴스가 생성되고 나서 가장 처음으로 실행되는 라이프사이클 단계입니다.
이 단계에서는 data속성과 methods속성이 아직 인스턴스에 정의되어 있지않고, 돔과 같은 화면 요소에도 접근할 수 없습니다.
~~~

~~~
created
: beforeCreate 라이프 사이클 단계 다음에 씰행되는 단계입니다.
data속성과 method속성이 정의되었ㅆ기 때문에 this.data또는 this.fettchData()와 같은 로직들을 이용하여 data속성과 methods속성에 정의된 값에 접근하여 로직을 실행할 수 있습니다.
다만, 아직ㄱ 인스턴스가 화면 요소에 부착되기 전이기 때문에 template속성에 정의된 돔 요소로 접근한 수 없습니다.

그리고 data속성과 methods속성에 접근할 수 있는 가장 첫ㅅ번째 라이픗사이클단계이자 컴포넌트가 쌩성되고 나서 실행되는 단계이기때문에, 서버에 데이터를 요청하여 받아오는 로직을 숫행하기 좋습니다.
~~~

~~~
beforeMount
: created단계 이후 template쏙성에 지정한 마크업 속성을 render()함수로 변환한 후 el 속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계입니다.
render()함수가 호출되기 직전의 로직을 추가하기 좋습니다.

* render()는 자바스크립트로 화면의 돔을 그리는 함수입니다.
~~~

~~~
mounted
el 속성에ㅓㅅ 지정한 화면 욧소에 접근할 숫 있어 화면 요솟를 제어하는 로직을 수행하기 좋은 단계입니다.
다만, 돔에 인스턴스가 부착되자마자 바로 호출되기때문에 하위 컴포넌트나 외부 라이브러리에 이해 추가된 화면 요소들이 최종 html코드로 변환되는 시점과 다를 수 있습니다.
~~~

~~~
beforeUpdate
el 속성에서 지정한 화면 욧소에 인슷턴쓰가 부착되고 나면 인스턴스에 정의한 속성들이 화면에 치환됩니다.
치환된 각ㅂㅅ은 뷰의 반응성(reactivity)을 제공하기위해 $wattch속성으로 감시합니다.
이를 데이터 관찰이라고 합니다.

또한 beforeUpdate는 고나찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단게이며, 변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있습니다.
만약 여기에 값을 변경하는 로직을 넣더라도 화면이 다시 그려지지는 않습니다.
~~~

~~~
updated
: 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고나면 실행되는 단계입니다.
데이터 변경으로 인한 화면 요소변경가지 완료된 시점이므로, 데이터 변경 후 화면 요소 제어와 고나련된 로직을 추가하기 좋은 단계입니다.
이 단게에섯 데이터 값을 변경하면 무한루프에 빠질 수 있으므로 값을 변경하려면 computed, watch와 같은 속성을 이용해야합니다.
따라서 데이터 값을 갱싯ㄴ하는 로직은 가급적이면 beforeUpdate에 추가하고, updated에섯는 변경 데이터의 화면요소(돔)과 관련된 로직을 추가하는 것이 좋습니다.
~~~

~~~
beforeDestroy
: 뷰 인스턴스가 파괴되기 직전에 호출되는 단계입니다.
이 단계에서는 아직 인스턴스에 접근할 숫 있습니다.
따라섯 뷰 인스턴스의 데이터를 삭제하기 좋은 단계입니다.
~~~

~~~
destroyed
: 뷰 인슷턴스가 파괴되고 낫서 호출되는 단계입니다.
뷰 인스턴스에 정의한 모든 솏성이 제거되고 하위에 선언한 인스턴스들 또한 모두 파괴됩니다.
~~~

