<h1>
  0415
</h1>

<h3>
    이벤트루프
</h3>

자바스크립트의 특징 중 하나는 "단일 스레드"기반의 언어라는 점입니다.

스레드가 하나라는 말은, 곧 동시에 하나의 작업만을 처리할 수 있다라는 말과 같습니다.

하지만 자바스크립트는 여러가지의 일을 동시에 처리하는 것처럼 보입니다.

이때 등장하는 개념이 "이벤트 루프"입니다.

즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원하는 것입니다.



실제로, V8같은 자바스크립트 엔진은 콜스택을 사용하며, 요청이 들어올때마다 해당 요청을 순차적으로 콜스택에 담아서 처리할 뿐입니다.

이때, 비동기 요청은 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 node.js가 담당합니다.



V8을 비롯한 대부분의 자바스크립트 엔진은 크게 2가지의 영역으로 나뉩니다.

```
콜스택
: 작업이 요청되면(함수가 호출되면) 요청된 작업은 순차적으로 콜스택에 쌓이고, 순차적으로 실행됩니다.
자바스크립트는 단 하나의 콜스택을 사용하기에 해당 task가 종료되기 전까지는 다른 어떤 task도 실행될 수 없습니다.
```

```
힙
: 동적으로 생성된 객체 인스턴스가 할당되는 영역입니다.
```

비동기 요청 처리는 자바스크립트 엔진을 구동하는 환경(브라우저나 node.js)는 다음과 같이 구성되어 있습니다.

```
이벤트큐
:비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, timer 함수의 콜백 함수가 보관되는 영역으로, 이벤트 루프에 의해 특정시점(콜스택이 비워졌을 때)에 순차적으로 콜스택으로 이동되어 실행되어집니다.
```

```
이벤트루프
: 콜스택 내에서 현재 실행중이 task가 있는지, 그리고 이벤트큐에 task가 있는지를 반복하여 확인합니다.
만약 콜스택이 비어져있다면, 이벤트큐 내의 task가 콜스택으로 이동되어 실행되어집니다.
```



<h3>
    이벤트의 흐름
</h3>

: 계층적 구조에 포함되어 있는 HTML요소에 이벤트가 발생할 경우 연쇄적 반응이 일어납니다.

이를 이벤트 전파, Event Propagation이라고 합니다.

그리고 이 전파 방향에 따라 버블링과 캡쳐링으로 구분할 수 있습니다.

자식요소에서부터 발생한 이벤트가 부모 요소로 전파되는 것을 버블링이라고 합니다.

거품이 올라가는 모습을 상상하면 되겠네요.

자식요소에서부터 발생한 이벤트가 부모요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것을 캡쳐링이라고 합니다.

부모가 자식을 잡으러 가는...캡쳐링....

중요한 점은, 버블링과 캡쳐링이 둘 중 하나만 발생하는 것이 아니라, 캡처링부터 시작하여 버블링으로 종료한다는 점입니다.

<h4>
event.stopPropagation()
</h4>

```
function logEvent(event) {
    event.stopPropagation();
}
```

위 API는 해당 이벤트가 전파되는 것을 막습니다.

따라서, 이벤트 버블링의 경우에는 클릭한 요소의 이벤트만 발생시키고 사우이 요소로 이벤트를 전달하는 것을 방해합니다.

그렇다면 이벤트 캡쳐링의 경우에는 클릭한 요소의 최상위 요소의 이벤트만 동작시키고 하위 요소들로 이벤트를 전달할지 않을 것입니다.



<h4>
    event delegation
</h4>

'하위 요소에 각각 이벤트를 붙이지않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식'으로 말할 수 있습니다.

```
<ul class="itemList">
	<li>
		<input type="checkbox" id="item1">
		<label for="item1">111</label>
	</li>
	<li>
		<input type="checkbox" id="item2">
		<label for="item2">2</label>
	</li>
</ul>
```

```
var inputs = document.querySelectorAll('input');
inputs.forEach(function(input) {
	input.addEventListener('click', function(event) {
		alert('clicked');
	});
});
```

할 일 목록을 만들었고, 클릭하면 alert이 실행되는 이벤트를 만들었습니다.

여기서 만약에 할 일이 더 생겨서 리스트에 아이템을 추가한다면..

```
var itemList = document.querySelector('.itemList');

var li = document.createElement('li');
var input = document.createElement('input');
var label = document.createElement('label');
var labelText = document.createTextNode('333');

input.setAttribute('type', 'checkbox');
input.setAttribute('id', 'item3');
label.setAttribute('for', 'item3');
label.appendChild(labelText);
li.appendChild(input);
li.appendChild(label);
itemList.appendChild(li);
```

새로 생긴 아이템은 클릭해도 이벤트가 동작하지않습니다.

input 박스에 이벤트 리스너를 추가하는 시점에서 리스트아이템은 2개였기때문에, 새로 생긴 아이템 리스트에는 클릭 이벤트 리스너가 등록되지 않았기 때문입니다.

이런식이라면 새롭게 추가된 리스트 아이템에는 매번 클릭 이벤트 리스너를 일일이 달아줘야하는 문제가 생깁니다.

이런 상황에서는 li태그에 이벤트를 등록하는 것보다, 상위 태그인 ul태그에 이벤트를 등록하는게 해결방안이 될 수 있습니다.

이것이 바로 event delegation입니다.

```
var itemList = document.querySelector('.itemList');
itemList.addEventListener('click', function(event) {
	alert('clicked');
});
```





<h1>
  0416
</h1>

ES6의 클래스 문법

: es6 이전의 자바스크립트에는 클래스가 없었습니다.

개념 자체는 있었지만, 이를 구현하려면 class대신에 prototype을 사용해야했습니다.

~~~
function Dog(name) {
  this.name = name;
}

Dog.prototype.say = function() {
  console.log(this.name + " 멍멍");
}

var dog = new Dog("흰둥이");
dog.say();
~~~

es6문법부터는 이 코드와 동일한 기능을 class를 사용하여 잓성할 수 있습니다.

~~~
class Dog {
  constructor(name) {
    this.name = name;
  }
  
  say() {
    console.log(this.name + " 멍멍");
  }
}

const dog = new Dog("흰둥이");
dog.say();
~~~



- 

~~~
class MyComponent extends Component {
  constructor(props) {
    super(props);
  }
  
  render() {
    (...)
  }
}
~~~

MyComponent는 리액ㄱ트의 Component클래스를 상속합니다.

따로 constructor 메소드를 만들어주지않으면 Component 클래스의 생성자 메소드를 그대로 사용합니다.

직접 constructorr메소드를 작성하여 생성자 메소드에서 추가 작업을 하려면, 메쏘드 내부에서 부모 클래스인 Component의 constructo메소드를 먼저 호출해야합니다.

이때 super 키워드를 사용합니다.

컴포넌트를 만들때 props값들을 사용하므로 props 메소드의 파라미터로 전달합니다.



- 

~~~
constructor(props) {
  super(props);
  this.handleClick = this.handleClick.bind(this);
}
~~~

컴포넌트에 임의 메소드를 만들면 기본적으로는 this에 접근할 수 없습니다.

따라서 컴포넌트의 생성자 메소드인 constructor에서 각 메소드를 this와 바인딩해주어야 합니다.

(메소드에서 this를 사용할 수 있도록 메소드에 this를 묶어주는 것입니다.)

이 작업을 하지 않으면 메소드에서 this를 부를때 undefined가 리턴됩니다.



<h1>
  0417
</h1>

디스트럭쳐링

: 배열 또는 객체를 비구조화하여 개별적인 변수에 할당하는 것

~~~
const arr = [1,2,3];

const [one, two, three] = arr;
~~~

~~~
const {prop1, prop2} = {prop1: "a", prop2: "b"};

console.log(prop1, prop2);	//a b
console.log({prop1, prop2});	// {prop1: "a", prop2: "b"}
~~~

