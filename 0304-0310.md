<h1>
    0304
</h1>





<h3>
    요소 렌더링
</h3>

- 요소는 React앱의 가장 작은 구성 블록입니다.

  요소는 화면에 표시할 내용을 설명합니다.

  ```
  const element = <h1>hello junwoo</h1>;
  ```

  브라우저 DOM요소와 달리, React요소는 순수한 객체이며 생성비용이 저렴합니다.

  React DOM은 React요소와 일치하도록 DOM을 업데이트합니다.

  - 요소를 "컴포넌트"라는 더 널리 알려진 개념과 혼동할 수 있습니다.

- DOM에서 요소 렌더링하기

  HTML파일 어딘가에 div가 있다고 가정하겠습니다.

  ```
  <div id = "root"></div>
  ```

  React DOM에의해 관리되는 모든 것이 이 요소안에 들어가므로 이걸 "루트"DOM노드라고 부릅니다.

  React로 구축한 어플리케이션은 보통 단일 루트 DOM노드를 가집니다.

  리액트를 기존 앱에 통합하는 경우 원하는 만큼 많은 분리된 루트 DOM 노드가 있을 수도 있습니다.

  리액트 요소를 루트 DOM노드에 렌더링하고 싶다면, ReactDOM.render()에 둘 다 전달하면 됩니다.

  ```
  const element = <h1>hello junwoo</h1>;
  ReactDOM.render(
  	element, 
  	document.getElementById("root")
  );
  ```

- 렌더링된 요소 업데이트

  리액트 요소는 변경불가능합니다.

  한번 요소를 만들었딱면, 그 자식이나 속성을 변경할 수 없습니다.

  요소는 영화의 단일 프레임과 같습니다.

  특정한 시간대의 UI를 보여줄 뿐입니다.

  이 지식을 바탕으로 하면, UI를 업데이트할 수 있는 유일한 방법은 새로운 요소를 만드는 것입니다.

  그리고 이 요소를 ReactDOM.render()로 전달하는 것이죠.

  시간이 깜빡이는 예제를 만들어 보겠습니다.

  ```
  function tick() {
      const element = (
      	<div>
      		<h1>hello junwoo</h1>
      		<h2>it is {new Date().toLocaleTimeStrinmg()} 
      		</h2>
      	</div>
      );
      
      ReactDOM.render(
      	element,
      	document.querySelector("#root")
      );
  }
  
  setInterval(tick, 1000);
  ```

- 리액트는 필요한 것만 업데이트합니다.

  리액트 DOM은 요소와 그 자식을 이전 요소와 비교하고, DOM을 원하는 상태로 만드는데 필요한 DOM 업데이트만 적용합니다.

  매 틱마다 전체 UI 트리를 설명하는 요소를 만들었지만, 내용이 변경된 텍스트 노드만 리액트 DOM에 의해서 업데이트 됩니다.

  이 경험으로 견주어 보면, 시간이 지남에 따라 UI를 변경하는 것이 아니라, 주어진 순간을 UI가 어떻게 보여줘야하는지에 대한 생각을 하게되면 버그를 해결하는데 도움이 될 것입니다.



<h3>
    컴포넌트와 props
</h3>

- 컴포넌트를 사용하여 UI를 독립적이고 재사용가능한 부분으로 분리하고 각 부분을 독립적으로 생각할 수 있습니다.

  개념상, 컴포넌트는 자바스크립트의 함수와 비슷합니다.

  임의의 입력(props라고 부르는..)을 받아들이고 어떤게 화면에 나타나야 하는지를 설명하는 리액트 요소를 반환합니다.



- 함수형 및 클래스 컴포넌트

  컴포넌트를 정의하는 가장 간단한 방법은 자바스크립트 함수로 작성하는 것입니다.

  ```
  function Welcom(props) {
      return <h1>hello, {props.name}</h1>;
  }
  ```

  이 함수는 단일 props객체 인수를 받고 리액트 요소를 반환하기 때문에 유효한 리액트 컴포넌트입니다.

  이러한 컴포넌트는 말 그대로 자바스크립트 함수이기때문에 "함수형"이라고 부릅니다.

  컴포넌트를 정의하기 위해 ES6 class를 사용할 수도 있습니다.

  ```
  class Welcom extends React.Component {
      render() {
          return <h1>hello, {this.props.name}</h1>;
      }
  }
  ```

  위의 두 컴포넌트는 리액트관점에서보면 동일핣니다.

  클래스는 몇가지 기능을 더 가지고 있습니다.

- 컴포넌트 렌더링

  이전에는 DOM태그를 나타내는 리액트 요소만 있었습니다.

  ```
  const element = <div />;
  ```

  그러나, 요소에 유저가 정의한 컴포넌트를 나타낼 수도 있습니다.

  ```
  const element = <Welcome name = "Sara" />;
  ```

  리액트가 유저가 정의한 컴포넌트를 나타내는 요소를 볼 때 JSX속성을 이 컴포넌트에 단일 객체로 전달합니다.

  이 객체를 props라고 부릅니다.

  예를 들어, 다음 코드는 "hello sara"를 페이지에 렌더링합니다.

  ```
  function Welcome(props) {
      return <h1>hello {props.name}</h1>;
  }
  
  const element = <Welcome name = "sara" />;
  ReactDOM.render(
  	element,
  	document.queyrSelector("#root")
  );
  ```

  위의 예제에서는 다음과 같은 일이 일어나고있습니다.

  ```
  1) <Welcome name = "sara" /> 요소로 ReactDOM.render()를 호출합니다.
  2) 리액트가 {name : "sara"}를 props로 하여 Welcome컴포넌트를 호출합니다.
  3) Welcome컴포넌트가 그 결과로 <h1>hello sara</h1>요소를 반환합니다.
  4) React DOM이 <h1>hello sara</h1>와 일치하도록 DOM을 효율적으로 업데이트합니다.
  ```

  

- 컴포넌트 결합

  컴포넌트는 출력될때 다른 컴포넌트를 참조할 수 있습니다.

  이를 통해 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용할 수 있습니다.

  리액트 앱에서 버튼, 폼, 다이얼로그, 스크린같은 것들은 모두 일반적으로 컴포넌트로 표현됩니다.

  예를 들어, Welcome을 여러번 렌더링하는 App 컴포넌트를 만들 수 있습니다.

  ```
  function Welcome(props) {
      return <h1>hello, {props.name}</h1>;
  }
  
  function App() {
      return (
      	<div>
      		<Welcome name = "sara" />
      		<Welcome name = "junwoo" />
      		<Welcome name = "gaon" />
      	</div>
      );
  }
  
  ReactDOM.render(
  	<App />,
  	document.getElementById("#root")
  );
  ```

  일반적으로, 새 리액트 앱은 단일 App 컴포넌트를 최상위에 둡니다.

  그러나 기존 앱에 리액트를 도입하는경우, Button같은 작은 컴포넌트부터 덩치를 키워나가기 시작하여 점차적으로 뷰 계층의 최상단으로 나아갈 수 있습니다.

