<h1>
    1224
</h1>

```
pub & sub의 장점
디커플링.
두개가 붙어버리면 생기는 단점이 분명히 생길수 있습니다.
둘을 조금더 멀게 해보자!
 => 펍썹을 이용할 수 있습니다.

```



MVC

```
요즘은 별로 중요하지않은 패턴이지만, 지금 쓰고있거나 보고있는 코드이 로직이 어떤 업무를 담당하는지 파악하는 것이 중요하기에 배웁니다.

```

컴포넌트 기반 개발

```
리액트, Vue.js 는 View에 치중하는 라이브러리입니다.
```



<h1>
    1225 Merry Christmas..! ..in VC
</h1>



Promise가 뭔가요?

```
프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다.
```

Promise가 왜 필요한가요?

```
프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.
서버에서 데이터를 받아오기도 전에 마치 데이터를 다 받아온것처럼 화면에 표시하려고한다면 오류가 발생하거나 빈화면이 뜰것입니다.
이와 같은 문제점을 해결하기 위한 방법중 하나가 프로미스입니다.
```

프로미스 코드 - 기초

```
다음은 간단한 ajax통신 코드입니다.

function getData(callbackFunc) {
    $.get('url 주소', function(response) {
        callbackFunc(response);
    })
    
    getData(function(tableData) {
        console.log(tableData);
    })
}

위 코드에 프로미스를 적용한다면 다음과 같습니다.

function getData(callback) {
    return new Promise(function(resolve, reject) {
        $.get('url 주소', function(response) {
            resolve(response);
        });
    });
}

getData().then(function(tableData) {
    console.log(tableData);
});

콜백함수로 처리하던 구조에서 new Promise(), resolve(), then()처럼 프로미스 API를 사용하는 구조로 바뀌었습니다.
```

프로미스의 3가지 상태(state)

```
프로미스의 가장 기본적인 개념이 프로미스 상태(state)입니다.
상태란, 프로미스의 처리과정을 의미합니다.
new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 가집니다.

- pending(대기) : 비동기 처리 로직이 아직 완료되지않은 상태.
- fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과값을 반환해준 상태.
- rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태.
```

Pending(대기)

```
다음과 같이 new Promise()메서드를 호출하면 pending상태가 됩니다.

new Promise();

이렇게 new Promise()메서드를 호출할 때 콜백함수의 인자로 resolve, reject에 접근할 수 있습니다.

new Promise(function(resolve, reject) {
    //..
});
```

Fulfilled(이행)

```
콜백함수의 인자 resolve를 아래와같이 실행하면 fulfilled상태가 됩니다.

new Promise(function(resolve, reject) {
    resolve();
});

fulfilled(이행)상태가 되면, 다음과같이 then()을 이용하여 처리 결과값을 받을 수 있습니다.

function getData() {
    return new Promise(function(resolve, reject) {
        var data = 100;
        resolve(data);
    });
}

getData().then(function (resolvedData) {
    console.log(resolvedData);	//100
});
```

Rejectd(실패)

```
new Promise()로 프로미스 객체를 생성하면 콜백함수 인자로 resolve와 reject를 사용할 수 있죠.
여기서reject인자로 reject()메서드를 실행하면 Rejected(실패)상태가 됩니다.

new Promise(function(resolve, reject) {
    reject();
});

그리고 실패상태가되면, 실패처리의 결과값을 catch()로 받을 수 있습니다.

function getData() {
    return new Promise(function(resolve, reject) {
        reject(new Error("Request is failed"));
    });
}

getData().then().catch(function(err) {
    console.log(err);
});
```



정리한 내용들을 바탕으로 코드를 종합해보겠습니다.

```
function getData() {
    return new Promise(function(resolve, reject) {
        $.get('url주소', function(response) {
            if(response) {
                resolve(response);
            }
            reject(new Error("Request is failed"));
        });
    });
}

getData().then(function(data) {
    console.log(data);
}).catch(function(err) {
    console.log(err);
});
```

여러개의 프로미스 연결하기(Promise Chaining)

```
프로미스는 여러개의 프로미스를 연결하여 사용할 수 있다는 특징을 가지고 있습니다.
바로 위의 예제에서, then()메서드를 호출하고 나면 새로운 프로미스 객체가 반환됩니다.
따라서 다음과 같은 코딩이 가능합니다.

function getData() {
    return new Promise(
    	//..
    );
}

getData().then(function(data) {
    //..
}).then(function() {
    //..
}).then(function() {
    //..
});
```

위 형식을 참고한 간단한 예제입니다.

```
new Promise(function(resolve, reject) {
    setTimeout(function() {
        resolve(1);
    }, 2000);
}).then(function(result) {
    console.log(result);	//1
    return result + 10;
}).then(function(result) {
    console.log(result);	//11
    return result + 20;
}).then(function(result) {
    console.log(result);	//31
});
```



<h1>
    1226
</h1>



```
코드스타일
커밋메세지
기능구현
방심, 자만 금지. 최선을다해서. 절박.
```



<h2>Asynchronous Programming - part2(Promise)</h2>

```
마냥 기다리던걸,
promise를 써서 객체를 만들어서.
추가적인 동작을 할수 있게 된것

promise는 비동기적인 코드를 객체로 다루어서 .. 즉 동기적으로 다룰 수 있게 되었다는게 가장 큰 점.

```



<h1>
    1227
</h1>




ES2015



1.파라미터 기본값(Default Parameter Value)

```
function plus(x = 0, y = 0) {
    return x + y;
}

console.log(plus());	//0
console.log(plus(1, 2));	//3
```



2.Rest 파라미터

```
Rest파라미터는 Spread연산자(...)를 사용하여 파라미터를 정의한 것을 의미합니다.
Rest파라미터를 사용하면 인수의 리스트를 함수 내부에서 배열로 전달받을 수 있습니다.


function foo(...rest) {
    console.log(Array.isArray(rest));	//true
    console.log(rest);	//[1,2,3,4,5]
}

foo(1,2,3,4,5);


function foo(param, ...rest) {
    console.log(param);	//1
    console.log(rest);	//[2,3,4,5]
}

foo(1,2,3,4,5);


function bar(param1, param2, ...rest) {
    console.log(param1);	//1
    console.log(param2);	//2
    console.log(rest);	//[3,4,5]
}

bar(1,2,3,4,5);

Rest파라미터는 반드시 마지막 파라미터여야합니다.
function foo(...rest, param1, param2) {
    //..
}
foo(1,2,3,4,5);
//SyntaxError : Rest parameter must be last formal parameter.
```

- arguments와 rest파라미터.

```
function foo() {
    console.log(arguments);
}

foo(1,2);	//{'0' : 1, '1' : 2}

arguments객체는 유사배열객체이므로 배열 메소드를 사용하려면 Function.prototype.call을 사용해야하는 번거로움이 있습니다.

function sum() {
    var array = Array.prototype.slice.call(arguments);
    return array.reduce(function(pre, cur) {
        return pre + cur;
    });
}

console.log(sum(1,2,3,4,5));	//15


ES2015의 Rest파라미터를 사용하면 이렇게 유사배열인 arguments객체를 배열로 변환하는 번거로움을 피할 수 있습니다.

function sum(...args) {
    return args.reduce((pre, cur) => pre + cur);
}

console.log(sum(1,2,3,4,5));	//15

* ES2015의 화살표함수에는 arguments프로퍼티가 없습니다.
화살표함수를 사용할때는 반드시 rest파라미터를 사용해야합니다.

var normalFunc = function() {};
console.log(normalFunc.hasOwnProperty('arguments'));	//true

const arrowFunc = () => {};
console.log(arrowFunc.hasOwnProperty('arguments'));	//false
```



3.Spread연산자

```
console.log(...[1,2,3]);	//1 2 3
console.log(...'Hello');	//H e l l o
```

배열을 함수의 인자로 사용하고, 배열의 각 요소를 개별적인 파라미터로 전달하고 싶은 경우엔, Function.prototype.apply를 사용하는 것이 일반적입니다.

```
function foo(x,y,z) {
    console.log(x);
    console.log(y);
    console.log(z);
}

const arr = [1,2,3];

foo.apply(null, arr);
```

Spread연산자를 사용한 배열을 함수의 인수로 사용하면 배열의 요소를 개별적으로 분리하여 순차적으로 파라미터에 할당합니다.

```
function foo(x,y,z) {
    console.log(x);
    console.log(y);
    console.log(z);
}

const arr = [1,2,3];

foo(...arr);
```

Rest파라미터는 Spread연산자를 사용하여 파라미터를 정의한 것입니다.

비슷한 생김새에 헷갈릴 수 있으니 주의해야합니다.

```
function foo(param, ...rest) {
    console.log(param);	//1
    console.log(rest);	//[2,3]
}
foo(1,2,3);


function bar(x,y,z){
    console.log(x);	//4
    console.log(y);	//5
    console.log(z);	//6
}

bar(...[4,5,6]);
```

Rest파라미터는 반드시 마지막 파라미터여야합니다.

하지만 Spread연산자를 사용한 인수는 자유롭게 사용할 수 있습니다.

```
function foo(v,w,x,y,z) {
	console.log(v);	//1
	console.log(w);	//2
    console.log(x);	//3
    console.log(y);	//4
    console.log(z);	//5
}

foo(1,...[2,3], 4, ...[5]);
```



<h1>
    1228
</h1>

배열에서 spread연산자를 사용하는 경우.



1.concat

```
var arr = [1,2,3];
arr.concat([4,5,6]);

const arr = [1,2,3];
[...arr,4,5,6];
```

2.push

```
const arr1 = [1,2,3];
const arr2 = [4,5,6];

arr1.push(...arr2);
```

3.splice

```
const arr1 = [1,2,3,6];
const arr2 = [4,5];
arr1.splice(3, 0, ...arr2);	//[1,2,3,4,5,6]
```

4.copy

```
var arr = [1,2,3];
var copy = arr.slice();


const arr = [1,2,3];
const copy = [...arr];
```



객체에서 사용하는 경우

```
객체의 병합
const merged = {...{x:1, y:2}, ...{y:10, z:3}};
console.log(merged);	//{x:1, y:10, z:3}

특정 프로퍼티 변경
const changed = {...{x:1, y:2}, y:100}
console.log(changed);	//{x:1, y:100}

프로퍼티추가
const added = {...{x:1, y:2}, z:0};
console.log(added);	//{x:1, y:2, z:0}
```





<h1>1229
</h1>

배열 디스트럭처링

Array destructuring

```
var arr = [1,2,3];
var one = arr[0];
var two = arr[1];
var three = arr[2];
console.log(one, two, three);
이것이 기존 es5라면,

const arr = [1,2,3];
const [one, two, three] = arr;
console.log(one, two, three);
```

배열 디스트럭쳐링을 위해서는 할당 연산자 왼쪽에 배열형태의 변수 리스트가 필요합니다.

```
let x, y, z;
[x, y, z] = [1, 2, 3];
이 두 줄은,
let [x, y, z] = [1, 2, 3];
이 구문과 동치입니다.
```

왼쪽의 변수리스트와 오른쪽의 배열은 배열의 인덱스를 기준으로 할당됩니다.

```
let x, y, z;
[x,y] = [1,2];
console.log(x,y);	//1 2

[x,y] = [1];
console.log(x,y);	//1 undefined

[x,y] = [1,2,3];
console.log(x,y);	//1 2

[x, , z] = [1,2,3];
console.log(x, z);	//1 3

[x,y,z=3] = [1,2];
console.log(x,y,z);	//1 2 3

[x, ...y] = [1,2,3];
console.log(x,y);	//1 [2,3]
```

```
const today = new Date();
const formattedDate = today.toISOString().substring(0, 10);
const [year, month, day] = formattedDate.split('-');
console.log([year, month, day]);	
```



객체 디스트럭처링

```
var obj = {first : 'junwoo', last: 'park'};

var first = obj.first;
var last = obj.last;

console.log(first, last);
```

