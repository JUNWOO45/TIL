<h1>
  0506
</h1>

컴포넌트란?

: 블록! 레고블록!

컴포넌트를 활용하여 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발할 수 있습니다.



전역 컴포넌트 등록

```
Vue.component("component name", {
	// component content
});
```

: 컴포넌트 등록 형식에는 컴포넌트 이름과 컴포넌트 내용이 있습니다.

컴포넌트 이름은 template속성에서 사용할 HTML사용자 정의 태그이름을 의미합니다.

컴포넌트 내용에는 컴포넌트 태그가 실제 화면의 HTML요소로 변환될 때 표시될 속성들을 작성합니다.

컴포넌트 내용에는 template, data, methods등 인스턴스 옵션 속성을 정의할 수 있습니다.

```
<div id="app">
	<button>컴포넌트 등록</button>
	<my-component></my-component>
</div>

<script>
	Vue.component('my-component', {
		template: '<div>hey~</div>'
	});
	
	new Vue({
		el: '#app'
	});
</script>
```





지역 컴포넌트 등록

: 지역 컴포넌트 등록은 전역 컴포넌트 등록과는 다르게 인스턴스에 components속성을 추가하고 등록할 컴포넌트의 이름과 내용을 정의하면 됩니다.

```
<div id='app'>
	<button>component</button>
	<my-local-component></my-local-component>
</div>

<script>
	var cmp = {
		template: '<div>local component!!</div>'
	};
	
	new Vue({
		el: '#app',
		components: {
			'my-local-component': cmp
		}
	});
</script>
```



지역 컴포넌트와 전역 컴포넌트의 차이

: 지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서는 인스턴스의 유효 범위를 이해해야합니다.

HTML의 특정 범위 안에서만 인스턴스의 내용이 유효한 것.

```
<div id="app">
	<h1>첫번째 인스턴스 영역</h1>
	<my-global-component></my-global-component>
	<my-local-component></my-local-component>
</div>

<script>
	Vue.component('my-global-component', {
		template: '<div>global component</div>'
	});
	
	var cmp = {
		template: '<div>this is local component</div>'
	};
	
	new Vue({
		el: '#app',
		components: {
			'my-local-component': cmp
		}
	})
</script>
```

인스턴스를 하나 생성하여 my-global-component전역 컴포넌트와 My-local-component지역 컴포넌트를 등록하고 화면에 나타내는 예제입니다.



인스턴스를 하나 더 생성해보겠습니다.

```
<div id="app">
	<h1>첫번째 인스턴스 영역</h1>
	<my-global-component></my-global-component>
	<my-local-component></my-local-component>
</div>
<div id="app2">
	<h1>두번째 인스턴스 영역</h1>
	<my-global-component></my-global-component>
	<my-local-component></my-local-component>
</div>

<script>
	Vue.component('my-global-component', {
		template: '<div>gggggggggggglobal</div>'
	});
	
	var cmp = {
		template: '<div>lllllllllocal</div>'
	};
	
	new Vue({
		el: '#app',
		components: {
			'my-local-component': cmp
		}
	});
	
	new Vue({
		el: '#app2'
	});
</script>
```

첫번째 인스턴스 영역에는 전역과 지역 컴포넌트가 모두 정상적으로 나타납니다.

하지만 두번째 인스턴스 영역에는 전역 컴포넌트만 나타나고 지역 컴포넌트는 나타나지 않습니다.

왜?

: 전역 컴포넌트와 지역 컴포넌트의 유효범위가 모두 다르기 때문입니다.

```
전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components속ㄱ성으로 등록할 필요 없이 한 번 등록하면 어느 인스턴스에서든지 사용할 수 있습니다.
반대로, 지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록해주어야합니다.

첫번째 인스턴스의 유효범위는 첫번째 인스턴스영역으로 제한되기때문에 <div id="app">에 지역 컴포넌트를 등록해도 두번째 인스턴스 영역인 <div id="app2">의 범위 안에서는 지역 컴포넌트로 인식되지 않아서 위와같은 결과가 나온것입니다!
```





<h2>
  컴포넌트 간 통신과 유효범위
</h2>

뷰의 경우, 컴포넌트로 화면을 구성하기에 같은 웹 페이지이더라도 데이터를 공유할 수 없습니다.

그 이유는 컴포넌트마다 자체적으로 고유한 유효범위(스코프)를 가지고 있기 때문입니다.

따라서, 각 컴포넌트의 유효범위가 독립적이기에 다른 컴포넌트의 값을 직접적으로 참조할 수 없습니다.



<h3>
  상, 하위 컴포넌트 관계
</h3>

컴포넌트는 각각 고유한 유효 범위를 갖고 있기 때문에 직접 다른 컴포넌트의 값을 참조할 수 없습니다.

따라서 뷰 자체에서 정의한 컴포넌트 데이터 전달 방법을 따라야합니다.

기본적인 데이터 전달 방법은 상위 - 하위 컴포넌트간의 데이터 전달 방법입니다.



상위에서 하위로는 props라는 특별한 속성으로 전달합니다.

하위에서 상위로는 이벤트만 전달할 수 있습니다.



<h3>
  상위에서 하위컴포넌트로 데이터 전달하기
</h3>

props

```
Vue.component('child-component', {
	props: ['props 속성 이름']
});
```

그리고 상위 컴포넌트의 html 코드에 등록된 child-component컴포넌트 태그에 v-bind속성을 추가합니다.

```
<child-component v-bind:props 속성 이름="상위컴포넌트의 data 속성"></child-component>
```

v-bind속성의 왼쪽 값은 하위 컴포넌트에서 정의한 props속성을 넣습니다.

오른쪽 값은 하위 컴포넌트에 전달할 상위 컴포넌트의 data속성을 지정합니다.

```
<div id="app">
	<chlid-component v-bind:propsdata="message"></child-component>
</div>

<script>
	Vue.component('child-component', {
		props: ['propsdata'],
		template: '<p>{{propsdata}}</p>'
	});
	
	new Vue({
		el: '#app',
		data: {
			message: 'passed from parent component'
		}
	});
</script>
```



1. new Vue()로 인스턴스를 하나 생성합니다.
2. Vue.component()로 하위 컴포넌트인 child-component를 등록핣니다.
3. child-component내용에 props 속성으로 propsdata를 정의합니다.
4. HTML에 컴포넌트를 추가합니다. child-component태그의 v-bind속성을 보면, v-bind:propsdata="message"는 상위 컴포넌트의 message속성 값을 하위컴포넌트의 propsdata로 전달합니다.
5. child-component의 template속성에 정의된 'p {{propsdata}} p'에 적용됩니다.



즉, 뷰 인스턴스의 data속성에 정의된 message속성을 하위 컴포넌트에 props로 전달하여 화면에 나타냅니다!

짚고 넘어가야할점은, "컴포넌트 간의 관계"입니다.

위 코드에서는, child-component를 전역으로 등록한 것 이외에 딱히 상위 컴포넌트를 지정하지 않았습니다.

그럼에도 불구하고 뷰 인스턴스는 마치 상위 컴포넌트가 존재하는 것처럼 하위 컴포넌트로 props를 내려보냈습니다.

그 이유는, 컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문입니다.



<h3>
  하위에서 상위 컴포넌트로 이벤트 전달하기
</h3>

이벤트 발생과 수신

: 상위 컴포넌트에서 하위 컴포넌트의 특정 이벤트가 발생하기를 기다리고 있다가, 하위 컴포넌트에서 특정 이벤트가 발생하면 상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메쏘드를 호출하는 방법입니다.



이벤트 발생과 수신 형식

: 이벤트 발생과 수신은 $emit()과 v-on: 속성을 사용합니다.

```
//event emit
this.$emit('event name');

//receive event
<child-component v-on:event name="상위 컴포넌트의 메서드명"></child-component>
```

$emit( )을 호출하면 괄호 안에 정의된 이벤트가 발생합니다.

일반적으로 $emit( )을 호출하는 위치는 하위 컴포넌트의 특정 메서드 내부입니다.

따라서, $emit( )을 호출할 때 사용되는 this는 하위 컴포넌트를 가리킵니다.



호출한 이벤트는 하위 컴포넌트를 등록하는 태그에서 v-on:으로 받습니다.

하위 컴포넌트에서 발생한 이벤트명을 v-on:속성에 지정하고, 속성의 값에 이벤트가 발생했을 때 호출될 상위 컴포넌트으 ㅣ메서드를 지정합니다.

```
<div id="app">
	<child-component v-on:show-log="printText"></child-component>
</div>

<Script>
	Vue.component('child-component', {
		template: '<button v-on:click="showLog">show</button>',
		methods: {
			showLog: function() {
				this.$emit('show-log');
			}
		}
	});
	
	new Vue({
		el: '#app',
		data: {
			message: 'hi gaon'
		},
		methods: {
			printText: function() {
				console.log("received an event");
			}
		}
	})
</script>
```





<h1>
  0507
</h1>

```
1. 미리 무엇을 보여줄지 결정한 후 작업을 시작해야, 작업을 수정, 수정, 수정하지않고... 효율적으로 작업가능하다..
```

```
modal, popup, scroll처리.
```

