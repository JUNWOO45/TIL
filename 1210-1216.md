<h1>
    1210
</h1>

OAuth2 생활코딩

```
사용자(USER)들이 내(I)가 만든 서비스를 안에서 그들(페이스북, 구글 등)이 만든 서비스를 이용하게 해주는 강력한 도구!?
상호작용하게 해주는..!
```

```
OAuth의 용어.
사용자(user)는 Resource Owner라고 합니다.
나(I)는 Client라고 합니다.
그들(페이스북, 구글 등..)은 Resource Server라고 합니다.
```

```
API란?
Application Progaramming Interface의 약자.
```

```
access token은 수명이있습니다.
1시간..2시간...60일..등등..
수명이 끝나면 API에 접근해도 더이상 데이터를 주지 않습니다.
그러면 다시 발급해야겠죠?
하지만 계속 이런식으로 다시 발급받으려면 복잡하니깐..!
이런 경우 쉽게 access token을 발급받는게 refresh token입니다.
```



<h2>
    수업
</h2>
 ```
Functional Programming

"Independent from outside context"
"Input & Output relationship"

function은 mapping이라고도 합니다.



이게 pure function일까?
const y = 1;

let foo = function(x) {
    return x + y;
}
foo(1);

y는 고정된값.재할당이 불가능.
해석의차이.바깥의 것을 사용하기는 하지만...
 ```



<h1>
    1212
</h1>

<h2> - async 라이브러리 filter를 구현하는 중에 배운점</h2>

```
1.

for(let i = 0; i < duplicateCollection.length; i++) {
        iteratee(duplicateCollection[i], FUNCTION);
}
    
function자리에 밖에서 정의한 함수를 넣고싶었습니다.
그 함수는 내부에서 i를 쓰고 싶은 상황이었습니다.


for(let i = 0; i < duplicateCollection.length; i++) {
        iteratee(duplicateCollection[i], function(error, result) {
            callbackFunc(error, result, i);
        });
}

짜잔! 
그동안 많이 봐왔던 패턴인데.. ken님의 말을 듣고나서야 눈에 보이고 기억이 났습니다.
반복숙달할 필요가 있을것같습니다.

2.

결과배열의 순서가 중요했습니다.

resultArr.push(arr[index]);
이런식이라면, [1,2,3]이라는 배열중 % 2 === 1만 filter로 걸러낼때,
배열을 순서대로 filter하지않는 async라이브러리의 특성상 3이 먼저 filter하게 된다면,
결과배열은 [3,1]의 순서일것입니다.
그래서 push 메소드를 사용하지않았습니다.

resultArr[index] = arr[index];
이러면, 위의 경우처럼 3이먼저 걸리더라도 resultArr[2] = 3
이기에, resultArr = [undefined, undefined, 3];입니다.
1이 들어온다면 resultArr = [1, undefined, 3]입니다.

그리고 마지막에 resultArr.filter(function(el) {return el !== undefined});
으로 배열을 압축해서 resultArr = [1,3]을 만들었습니다.
```

