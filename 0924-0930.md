<h1>0924</h1>
<h3>함수</h3>

- 함수는 객체다.

```
var fun = function(){};

fun['x'] = 9;
fun[0] = 'cat';
fun[1] = 'dog';

console.log(fun['x']); // 9
console.log(fun[0]); // 'cat'
console.log(fun[1]); // 'dog'

for(var i in fun){
	console.log(i);	// '0', '1', 'x' 
}
```



- 

```
var fun = function(){
	console.log(2);
}

var res = fun();	// console.log(2);
console.log(res);	// undefined

모든 함수는 return값을 가지기 전까지는 undefined를 return한다.
fun함수는 return값이 없기때문에 undefined를 리턴한다.
```

```
var fun = function(){
	console.log(2);
	return 1;
}

var res = fun();	//console.log(2);
console.log(res)	// 1

console.log(2)는 side effect이다.
이 side effect와 return을 헷갈려선 안된다.
```



- 

```
var fun = function(){
	return 1;
}

var str = "this is not a function";
var res = str();	// TypeError: str is not a function

자바스크립트 인터프리터는 단순히 변수뒤에 ()가 있어도 함수인줄알고 해석을 시도한다.
그리고 오류를 토해낸다..
```

심지어....

```
var fun = function(){
	return 1;
}

var res = "this is not a function"(); //TypeError : not a function

문자열뒤에 ()있어도 해석을 시도한다.
```

```
var fun = function(){
	return 1;
}

var res =                   fun                ();
console.log(res);	// 1

하지만 value가 함수이기만 한다면, 사이에 공백이 있다한들 옳은값을 출력한다.
```



- 

```
var fun = function(){return 1;}();

var res = fun();	//Error! not a function

이 경우에, 변수 fun은 함수를 저장하는 것이 아니다.
함수를 실행하고, 그 return값을 저장하는 것이다.
즉, var fun = 1; 인 셈.
```





<h1>
    0925
</h1>

<h3>
    Primitive vs Reference
</h3>

1.primitive  -> 값을 그대로 할당 

- Number
- String
- Boolean
- null
- undefined

```
var b = 'abc';
b = false;
var c = b;
	b === c
c = 20;
	b !== c
```



2.Reference

- Object -> 값이 저장된 주소값을 할당(참조)
  - Array
  - Function
  - RegExp(정규표현식)

```
var obj = {
	a: 1,
	b: 'b'
}
var obj2 = obj;
	obj2 === obj;
obj2.a = 10;
console.log(obj2.a);	//10
console.log(ojb.a);		//10

```

```
var obj3 = {
	a : [4,5,6]
}
```



<h3>
    HOISTING
</h3>

```
끌어올린다.
변수선언.
함수선언.
을 끌어올린다.
```

```
console.log(a());
console.log(b());
console.log(c());

function a(){
	return 'a';
}
var b = function bb(){
	return 'bb';
}
var c = function (){
	return 'c';
}

이건...
```

```
function a(){
	return 'a';
}
var b;
var c;
console.log(a());
console.log(b());
console.log(c());

b = function bb(){
	return 'bb';
}
c = function(){
	return 'c';
}

함수선언문은 통채로 올라간반면, 함수표현식은 선언부분만 올라간다.
함수선언문은 그 자체가 선언이다.
함수표현식은 선언과 할당이 분리되어있는것..!
```



<h3>
    함수선언문과 함수표현식
</h3>



- 함수선언문 function declaration

```
function a(){
    return 'a';
}
```

- 기명 함수표현식 named function expression

```
var b = function bb(){
	return 'bb';
}
```

- (익명) 함수표현식 (unnamed/annonymous) function expression

```
var c = function(){
	return 'c';
}

자세히 살펴보면.
1.var c로 변수 c 선언
2.function(){return 'c';}라는 익명함수 선언.
3.익명함수를 변수 c에 할당

'선언한 함수를 변수에 할당한다.' 이것이 함수 표현식의 개념이다!
```

```
함수선언문과 함수표현식의 차이점은 '할당'이다.
할당을 하지않으면 전체가 호이스팅의 대상이다.
할당을 하게된다면 함수는 그자리에 남게되고, 변수만 호이스팅된다.
```



함수선언문대신에, 함수표현식을 쓰자.



<h3>
    함수스코프, 실행컨텍스트
</h3>

```
스코프 : 유효범위
실행컨텍스트 : 실행되는 코드덩어리(추상적개념)
```

```
스코프는 "정의"될때 결정된다.
실행컨텍스트는 "실행"될때 생성된다.
```



```
1/var a = 1;
2/function outer(){
3/	console.log(a);
4/	
5/	function inner(){
6/		console.log(a);
7/		var a = 3;
8/	}
9/	
10/	inner();
11/	
12/	console.log(a);
13/}
14/outer();
15/console.log(a);
```

```
0.전역 실행컨텍스트 생성[GLOBAL]
1.변수 a선언	//호이스팅 시작.
2.함수선언문인 outer선언[GLOBAL > outer]	//호이스팅 끝.
3.변수 a에 1할당
4.outer()로 인해 outer함수 호출 -> outer실행컨텍스트 생성
	4-1.함수선언문인 inner선언[GLOBAL > outer > inner]	//호이스팅 시작,끝
	4-2. 3번째줄 콘솔로그실행. outer scope에서 a탐색 -> 없어 -> global scope에서 a탐색 -> 1출력!
	4-3. 10번째줄 inner() 실행. -> inner실행컨텍스트 생성
        4-3-1. 변수a선언	//호이스팅 시작, 끝
        4-3-2. 6번째줄 콘솔로그실행. inner scopre에서 a탐색 -> undefined출력!
        4-3-3. 변수 a에 3할당
    4-4. inner 실행 컨텍스트 종료
    4-5. 12번째줄 콘솔로그실행. outer scope에서 a탐색 -> 업성 -> global scope에서 a탐색 -> 1출력!
5.outer실행컨텍스트 종료.
6.global scope에서 a탐색 -> 1출력!
7.전역컨텍스트 종료
```



<h2>
    DOM
</h2>

- Get parent element node

```
var el = document.querySelector('div');
var parent = el.parentNode;
```

- Get siblings of an element

```
var el = document.querySelector('div');

var previous = el.previousSibling;
var next = el.nextSibling;
```

- Select the children of an element

```
var el = document.querySelector('div');

var firstChild = el.firstChild;
var lastChild = el.lastChild;

for(var i = 0; i < el.children.length; i++){
	console.log(el.children[i].innerHTML)
}
```





<h1>
    0926
</h1>

https://joshuajangblog.wordpress.com/2016/09/19/learn-css-flexbox-in-3mins/

<h2>CSS FLEX BOX</h2>



```
.container {
	display : flex;
}
```

![display : flex](https://github.com/JUNWOO45/TIL/blob/master/pic/flex1.png)



flex-direction으로 축을 전환할 수 있다.

```
.container {
	display : flex;
	flex-direction : column;
}
```

![flex-direction:column](https://github.com/JUNWOO45/TIL/blob/master/pic/flex2.png)



```
.container {
	display : flex;
	flx-direction : column;
	justify-content: center;
}
```

![justify-content](https://github.com/JUNWOO45/TIL/blob/master/pic/flex3.png)



```
.container {
	display : flex;
	flx-direction : column;
	justify-content: center;
	align-items: center;
}
```

![align-items](https://github.com/JUNWOO45/TIL/blob/master/pic/flex4.png)



축에따른 전체적인 정렬 말고도, 각각의 아이템에 대해서도 CSS효과를 줄 수 있다.

align-self

```
.box1{
	align-self :flex-end;
}
```

![align-self](https://github.com/JUNWOO45/TIL/blob/master/pic/flex5.png)



```
.box1{
	align-self :flex-end;
}
.box2{
	align-self :center;
}
```

![align-self](https://github.com/JUNWOO45/TIL/blob/master/pic/flex6.png)