<h1>
  0408
</h1>

1. typescript
2. material ui
3. Mobx

조금이라도 공부해가기

<hr>

간만에 교보문고에서 자바스크립트 책을 봤습니다.

한달동안 너무 탱자탱자 놀지말고 그동안 경험해보지못했던 기술들을 공부하는게 좋을 것 같습니다

<hr>

또 한가지 해야 할 일,…..

키보드 수리받기…….

1주일 이상 걸린다는데… 그럼 그 동안은 컴퓨터를 어떻게 하지…….?ㅠㅠㅠ..





<h1>
  0409
</h1>



typescript

~~~
typescript는 ex5의 superset이므로 기존의 자바스크립트 문법을 그대로 사용할 수 있습니다.
또한, es6의 새로운 기능들을 삿용하기위해 babel같은 별도의 트랜스파일러를 사용하지않아도 es6의 새로운 기능을 기존의 자바스크립트 엔진에서 실행할 수 있습니다.
~~~



장점

~~~
정적타입
- 가장 큰 장점 중 하나는 정적타입의 지원입니다.

function sum(a, b) {
  return a + b;
}

개발자의 의도는 아마도 2객의 숫자타입 인수를 전달받아서 그 합꼐를 반환하려는 것일겁니다.
하지만 어떤 타입의 인수를 전달하여야하는지, 어떤 타입의 리턴값을 반환하는지 명확하지는 않습니다.

따라서 다음과 같이 호출 될 숫도 있습니다.
function sum(a, b) {
  return a + b;
}

sum('x', 'y');	// 'xy'

위 함수를 타입스크립트의 정적타입을 사용하여 다시 작성해보면 다음과 깥습니다.

function sum(a: number, b: number) {
  return a + b;
}

sum('x', 'y');
// error TS2345: Argument of type '"x"' is not assignable to parameter of type 'number'.

타입스크립트는 정적타입을 지원하므로 컴파일 단계에서 오류를 포착할 수 있는 큰 장점이 있습니다.
이는 개발자의 의도를 명확학게 코드로 기술할 수 있어섯, 코드의 가독성을 높이고 예측할 수 있겍하며 디버깅을 쉽겍 합니다.
~~~

~~~
강력한 객체지향 프로그래밍 지원
인터페이스, 제네릭ㄱ 등과 같은 강력한 객체지향 프로그래밍 지원은 크고 복잡한 프로젝트의 코드기반을 쉽게 구성할 수 있게 도와줍니다.
~~~

~~~
ES6 / ES Next지원
브라우저만 있으면 컴파일러 등의 개발환경 구축없이 바로 사용할 수 있는 ES5와 비교할 때, 개발환경 구축관점에섯 다소 복ㄱ잡해진 측면이 있지만 현재 ES6를 완전히 지원하지 않고 있는 브라우저를 고려하여 babel등의 트랜스파일러를 사용해야하는 현 상황에서 타입스크립트 개발환경 구축에 드는 수고는 그다지 아깝지 않다고 합니다.
또한 타입스크립트는 아직 ECMAScript표준에 포함되지는 않았지만 표준화가 유력한 스펙을 선제적으로 도입하므로 새로운 스펙의 유용한 기능을 안전하게 도입하기에 유리합니다.
~~~



개발환경구축

~~~
타입스크립트 파일(.ts)은 브라우저에서 동작하지 않으므로 타입스크립트 컴파일러를 이용해 자바스크립트 파일로 변환해야합니다.
이를 컴파일 또는 트랜스파일링이라고 합니다.
~~~

1. Node.js설치

2. 타입스크립트 컴파일러 설치

3. ~~~
   npm install -g typescript
   
   설치가완료되면 버전을 출력해서 설치를 확인해봅니다.
   tsc -v
   
   타입스크립트 컴파일러(tsc)는 타입스크립트 파일(.ts)을 자바스크립트 파일로 트랜스파일링합니다.
   ~~~

   트랜스파일링을 실행해보기위해 다음과 같이 작성한뒤,

   ~~~
   //person.ts
   class Person {
     private name: string;
     
     constructor(name: string) {
       this.name = name;
     }
     
     sayHello() {
       return "Hello, " + this.name;
     }
   }
   
   const person = new Person('Park');
   
   console.log(person.sayHello());
   ~~~

   트랜스 파일링을 실행해 봅니다.

   ~~~
   tsc person
   ~~~

   트랜스 파일링 실행 결과, 같은 디렉터리에 자바슷크립트 파일이 생성됩니다.

   ~~~
   // person.js
   var Person = /* @class */ (function () {
     function Person(name) {
       this.name = name;
     }
     Person.prototype.sayHello = function() {
       return "Hello, : + this.name;
     };
     return Person;
   }());
   
   var perrson = new Person('Park');
   console.log(person.sayHello());
   ~~~

   트랜스파일링이 성공하여 자바슷크립트 파일이 생성되었으면, Node.js REPL을 이용해 트랜스파일링된 person.js를 실행할 수 있습니다.

   ~~~
   node person
   
   //Hello, Park
   ~~~

   여러개의 타입스크립트 파일을 한번에 트랜스파일링할 수도 있습니다.

   상속관꼐에 있는 두개의 타입스크립트 class를 작성해보도록 하겠습니다.

   ~~~
   //person.ts
   export class Person {
     protected name: string;
     
     constructor(name: string) {
       this.name = name;
     }
     sayHello() {
       return "Hello, " + this.name;
     }
   }
   ~~~

   ~~~
   //student.ts
   import { Person } from './person';
   
   class Student extends Person {
     study(): string {
       return `${this.name} is studying.`;
     }
   }
   
   const student = new Student('Park');
   
   console.log(student.sayHello());
   console.log(student.study());
   ~~~

   다음 명령으로 두 개의 타입스크립트 파일을 한번에 트랜스파일링할 숫 있습니다.

   ~~~
   $ tsc person student
   $ node student
   
   Hello, Park
   Park is studying.
   ~~~

   또는 와일드카드를 사용하여 모든 타입스크립트 파일을 한꺼번에 트랜스파일링할 수도 있습니다.

   ~~~
   $ tsc *.ts
   $ node student
   
   Hello, Park
   Park is studying.
   ~~~

   

공부자료 : <https://poiemaweb.com/typescript-introduction>



<h1>
  0410
</h1>

~~~
리액트 책과 네트워크가 궁금해서 기초적인 네트워크책을 사서 읽고있습니다.
우선적으로 리액트를 빠르게 복습하는 식으로 공부를 진행하고, typescript와 mobx, material ui를 보는식으로 해야할 것 같습니다. 
~~~



<h1>
  0411
</h1>

```
function UserGreeting(props) {
    return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
    return <h1>please sign up</h1>;
}
```

사용자의 로그인 여부에 따라 다음 컴포넌트 중 하나를 표시하는 Greeting컴포넌트를 만들었습니다.

```
function Greeting(props) {
    const isLoggedIn = props.isLoggedIn;
    if(isLoggedIn) {
        return <UserGreeting />;
    }
    return <GuestGreeting />;
}

ReactDOM.render(
	<Greeting isLoggedIn = {false} />,
	document.getElemetById("root")
);
```

이 예제는 isLoggendIn prop의 값에 따라 다른 인삿말을 노출시킵니다.

- 요소 변수

  요소를 담기위해 변수를 사용할 수 있습니다.

  이렇게 하면 컴포넌트의 일부를 조건부로 렌더링하는데 도움이 되며 나머지 출력은 변경되지 않습니다.

  로그아웃과 로그인 버튼을 나타내는 두개의 새 컴포넌트를 살펴봅시다.

  ```
  function LoginButton(props) {
      return (
  		<button onClick = {props.onClick}>
  			Login
  		</button>
  	);
  }
  
  function LogoutButton(props) {
      return (
      	<button onClick = {props.onClick}>
      		Logout
      	</button>
      );
  }
  ```

  위 예제에서, LoginControl이라는 state를 가진 컴포넌트를 생성했습니다.

  이 컴포넌트는 현재 상태에 따라 LoginButton 혹은 LogoutButton중 하나를 렌더링 할 것입니다.

  이전 예제에서 만들었떤 Greeting도 렌더링해보겠습니다.

  ```
  class LoginControl extends React.Component {
      constructor(props) {
          super(props);
          this.handleLoginClick = this.handleLoginClick(this);
          this.handleLogoutClick = this.handleLogoutClick(this);
          this.state = {isLoggedIn: false};
      }
      
      handleLoginClick() {
          this.setState({isLoggedIn: true});
      }
      
      handleLogoutClick() {
          this.setState({isLoggedIn: false});
      }
      
      render() {
          const isLoggedIn = this.state.isLoggedIn;
          
          let button = null;
          if(isLoggedIn) {
              button = <LogoutButton onClick = {this.handleLogoutClick} />;
          } else {
              button = <LoginButton onClick = {this.handleLoginClick} />;
          }
          
          return (
          	<div>
          		<Greeting isLoggedIn = {isLoggedIn} />
          		{button}
          	</div>
          );
      }
  }
  
  ReactDOM.render(
  	<LoginControl />,
  	document.getElementById("root")
  );
  ```

  변수를 선언하고 if문을 사용하는 것은 조건부로 컴포넌트를 렌더링하는 훌륭한 방법이지만, 원한다면 더 짧은 구문을 사용할 수도 있습니다.

  - 논리 && 연산자가 있는 인라인 조건

    중괄호로 감싸면 JSX에 어떤 표현식이던 넣을수있습니다.

    ```
    function Mailbox(props) {
        const unreadMessages = props.unreadMessages;
        return (
        	<div>
        		<h1>hello!</h1>
        		{unreadMessages.length > 0 &&
        			<h2>
        				you have {unreadMessages.length} unread messages.
        			</h2>
        		}
        	</div>
        );
    }
    
    const messages = ["react", "re:react", "re:re:react"];
    ReactDOM.render(
    	<Mailbox unreadMessages = {messages} />,
    	document.getElemetById("root")
    );
    ```

    자바스크립트에서 true && expression은 항상 expression으로 평가되고, false && expression은 항상 false로 평가되기때문에 이 코드는 동작합니다.

    따라서 조건이 true라면 &&다음에 오는 요소가 노출됩니다.

    만약 조건이 false라면, 리액트는 이를 무시하고 건너뜁니다.

  - 조건부 연산자를 사용한 인라인 If-Else

    인라인으로 요소를 조건부 렌더링하는 다른 방법은 자바스크립트의 삼항연산자를 사용하는 것입니다.

    ```
    render() {
        const isLoggedIn = this.state.isLoggedIn;
        return (
        	<div>
        		the user is <b>{isLoggedIn ? "currently" : "not"}</b> logged in.
        	</div>
        );
    }
    ```

    또한 더 큰 표현을 위해 사용할 수도있지만, 덜 명백해보입니다.

    ```
    render() {
        const isLoggedIn = this.state.isLoggedIn;
        return (
        	<div>
        		{isLoggedIn ? (
        			<LogoutButton onClick = {this.handleLogoutClick} />
        		) : (
        			<LoginButton onClick = {this.handleLoginClick} />
        		)}
        	</div>
        );
    }
    ```

    자바스크립트에서와 마찬가지로 당신과 당신의 팀이 더 읽기 쉽다고 생각하는 것을 바탕으로 적절한 스타일을 선택해야됩니다.

    또한 조건이 너무 복잡해질때마다 컴포넌트를 추출하면 좋습니다.

  - 컴포넌트가 렌더링되지 못하도록 방지

    흔하지않지만 컴포넌트가 다른 컴포넌트에 의해 렌더링되었더라도 이를 숨길 수 있습니다.

    이렇게하려면 렌더출력대신 null을 반환합니다.

    아래 예제에서, WaringBanner는 warn prop의 값에의존해 렌더링됩니다.

    만약 prop값이 false라면 이 컴포넌트는 렌더링되지 않습니다.

    ```
    function WaringBanner(props) {
        if(!props.warn) {
            return null;
        }
        
        return (
        	<div className = "warning">
        		Warning!
        	</div>
        );
    }
    ```



<h1>
  0412
</h1>

~~~
```
function UserGreeting(props) {
    return <h1>Welcome back!</h1>;
}

function GuestGreeting(props) {
    return <h1>please sign up</h1>;
}
```

사용자의 로그인 여부에 따라 다음 컴포넌트 중 하나를 표시하는 Greeting컴포넌트를 만들었습니다.

```
function Greeting(props) {
    const isLoggedIn = props.isLoggedIn;
    if(isLoggedIn) {
        return <UserGreeting />;
    }
    return <GuestGreeting />;
}

ReactDOM.render(
	<Greeting isLoggedIn = {false} />,
	document.getElemetById("root")
);
```

이 예제는 isLoggendIn prop의 값에 따라 다른 인삿말을 노출시킵니다.

- 요소 변수

  요소를 담기위해 변수를 사용할 수 있습니다.

  이렇게 하면 컴포넌트의 일부를 조건부로 렌더링하는데 도움이 되며 나머지 출력은 변경되지 않습니다.

  로그아웃과 로그인 버튼을 나타내는 두개의 새 컴포넌트를 살펴봅시다.

  ```
  function LoginButton(props) {
      return (
  		<button onClick = {props.onClick}>
  			Login
  		</button>
  	);
  }
  
  function LogoutButton(props) {
      return (
      	<button onClick = {props.onClick}>
      		Logout
      	</button>
      );
  }
  ```

  위 예제에서, LoginControl이라는 state를 가진 컴포넌트를 생성했습니다.

  이 컴포넌트는 현재 상태에 따라 LoginButton 혹은 LogoutButton중 하나를 렌더링 할 것입니다.

  이전 예제에서 만들었떤 Greeting도 렌더링해보겠습니다.

  ```
  class LoginControl extends React.Component {
      constructor(props) {
          super(props);
          this.handleLoginClick = this.handleLoginClick(this);
          this.handleLogoutClick = this.handleLogoutClick(this);
          this.state = {isLoggedIn: false};
      }
      
      handleLoginClick() {
          this.setState({isLoggedIn: true});
      }
      
      handleLogoutClick() {
          this.setState({isLoggedIn: false});
      }
      
      render() {
          const isLoggedIn = this.state.isLoggedIn;
          
          let button = null;
          if(isLoggedIn) {
              button = <LogoutButton onClick = {this.handleLogoutClick} />;
          } else {
              button = <LoginButton onClick = {this.handleLoginClick} />;
          }
          
          return (
          	<div>
          		<Greeting isLoggedIn = {isLoggedIn} />
          		{button}
          	</div>
          );
      }
  }
  
  ReactDOM.render(
  	<LoginControl />,
  	document.getElementById("root")
  );
  ```

  변수를 선언하고 if문을 사용하는 것은 조건부로 컴포넌트를 렌더링하는 훌륭한 방법이지만, 원한다면 더 짧은 구문을 사용할 수도 있습니다.

  - 논리 && 연산자가 있는 인라인 조건

    중괄호로 감싸면 JSX에 어떤 표현식이던 넣을수있습니다.

    ```
    function Mailbox(props) {
        const unreadMessages = props.unreadMessages;
        return (
        	<div>
        		<h1>hello!</h1>
        		{unreadMessages.length > 0 &&
        			<h2>
        				you have {unreadMessages.length} unread messages.
        			</h2>
        		}
        	</div>
        );
    }
    
    const messages = ["react", "re:react", "re:re:react"];
    ReactDOM.render(
    	<Mailbox unreadMessages = {messages} />,
    	document.getElemetById("root")
    );
    ```

    자바스크립트에서 true && expression은 항상 expression으로 평가되고, false && expression은 항상 false로 평가되기때문에 이 코드는 동작합니다.

    따라서 조건이 true라면 &&다음에 오는 요소가 노출됩니다.

    만약 조건이 false라면, 리액트는 이를 무시하고 건너뜁니다.

  - 조건부 연산자를 사용한 인라인 If-Else

    인라인으로 요소를 조건부 렌더링하는 다른 방법은 자바스크립트의 삼항연산자를 사용하는 것입니다.

    ```
    render() {
        const isLoggedIn = this.state.isLoggedIn;
        return (
        	<div>
        		the user is <b>{isLoggedIn ? "currently" : "not"}</b> logged in.
        	</div>
        );
    }
    ```

    또한 더 큰 표현을 위해 사용할 수도있지만, 덜 명백해보입니다.

    ```
    render() {
        const isLoggedIn = this.state.isLoggedIn;
        return (
        	<div>
        		{isLoggedIn ? (
        			<LogoutButton onClick = {this.handleLogoutClick} />
        		) : (
        			<LoginButton onClick = {this.handleLoginClick} />
        		)}
        	</div>
        );
    }
    ```

    자바스크립트에서와 마찬가지로 당신과 당신의 팀이 더 읽기 쉽다고 생각하는 것을 바탕으로 적절한 스타일을 선택해야됩니다.

    또한 조건이 너무 복잡해질때마다 컴포넌트를 추출하면 좋습니다.

  - 컴포넌트가 렌더링되지 못하도록 방지

    흔하지않지만 컴포넌트가 다른 컴포넌트에 의해 렌더링되었더라도 이를 숨길 수 있습니다.

    이렇게하려면 렌더출력대신 null을 반환합니다.

    아래 예제에서, WaringBanner는 warn prop의 값에의존해 렌더링됩니다.

    만약 prop값이 false라면 이 컴포넌트는 렌더링되지 않습니다.

    ```
    function WaringBanner(props) {
        if(!props.warn) {
            return null;
        }
        
        return (
        	<div className = "warning">
        		Warning!
        	</div>
        );
    }
    ```
~~~

