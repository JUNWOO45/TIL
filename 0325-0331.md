<h1>
  0325
</h1>



떨려도 잘해낼것..!

자신있게!

일찍 도착하기!

들어가기 전까지 개념 복습하고 들어가기!





<h1>
  0326
</h1>

클로져

: 함수가 만들어진 환경을 기억하는 것

~~~
function test() {
  const text = "hello";
  return function() {
    return text;
  }
}

const result = test();
result();	// "hello"
~~~



호이스팅

: 변수나 함수 선언이 최상단으로 끌어올려지는것.

~~~
console.log(a);
var a = 10;

이건,

var a;
console.log(a);
a = 10;
과 같다.

~~~



자료구조

스택

: 한쪽 끝에서만 자료를 넣고 뺄 수 있는 구조.

~~~
pop();

스택에서 가장 위에있는 항목을 제거한다.

push();

아이템 하나를 스택의 가장 윗 부분에 추가한다.
~~~

큐

: 먼저 집어넣은 데이터가 먼저 나오는 구조.

트리

: 노드로 이루어진 자료 구조. 계층 구조.

~~~
그래프와 트리의 차이점

트리도 그래프의 한 종류이다.
그래프에는 부모-자식 관계가 없다.
~~~



var, let, const

~~~
var는 function-scoped이고, let, const는 block-scoped입니다.

var a = 123;
{
  var a = 456;
}
console.log(a);	// 456

let b = 456;
{
  let b = 789; let c = 0123;
}

console.log(b);	// 456
console.log(c); // c is not defined
~~~

화살표함수

~~~
var sum = function(a, b) {
  return a + b;
};

var sum = (a, b) => {
  return a + b;
}
~~~



this

1. 함수가 실행될 때, dot 앞이 this

   ~~~
   const person = {
     name : 'junwoo',
     age : 100,
     greet() {
       console.log(`hello! my name is %{this.name}`);
     }
   }
   
   person.greet();	// "hello! my name is junwoo";
   ~~~

2. call, apply bind일때 괄호안이 this

   ~~~
   function greet() {
     console.log(`hello, my name is ${this.name}`);
   }
   
   const user = {
     name : 'junwoo',
     age : 100
   };
   
   greet.call(user);	// "hello, my name is junwoo"
   ~~~

3. new binding일 경우에는 this가 빈 객체를 가리킨다.

   ~~~
   function Person(name, age) {
     this.name = name;
     this.age = age;
   }
   
   const me = new Person("junwoo", 100);
   ~~~

4. 함수로 실행되었을때에는 this는 window

5. strcit모드일때는 undefined



CORS

~~~
Ajax뿐만아니라, XMLHttpRequest객체는 기본적으로 동일 출처 정책의 제약을 받습니다.
즉, 현재 브라우저에 보여지고 있는 HTML을 내려준 웹서버에게만 Ajax요청을 할 수 있습니다.

CORS란 기술이 아니라, 크로스 도메인 요청에대한 표준입니다.
스펙이죠.
CORS를 사용하기 위해서는 클라이언트와 서버가 몇가지 추가정보를 주고받아야합니다.
클라이언트는 CORS요청을 위해 새로운 HTTP헤더를 추가합니다.
서버는 클라이언트가 전송한 헤더를 확인해서 요청을 허용할지 말지를 결정합니다.
데이터에 사이드 이펙트를 발생시킬 수 있ㅅ는 HTTP메솟드를 사용할 때는 preflight요청을 서버로 전송해서 섯버가 허용하는 메소드목록을 HTTP options헤더로 획득한 다음 실제 요청을 전송합니다.
~~~

~~~
var xhr = new XMLHttptRequestt();
var url = "httpt://~~~~";

functiotn simpleRequest() {
  xhr.open("GET", url);
  xhr.onreadystatechange = function() {
    //..
  };
  xhr.send();
}
~~~



ES2015

1. let, const

- temporal deadzone(tdz)

- ~~~
  console.log(x);	//undefined
  console.log(y);	//Reference Error
  
  var x = "hello";
  let y = "hello";
  ~~~

let은 호이스팅이 안될까?

~~~
console.log(typeof abcd);	//undefined
console.log(typeof i);	//레퍼런스에러

let i = 10;
~~~

2. defualt parameter value

3. ~~~
   function plus(x = 0, y = 0) {
     return x + y;
   }
   
   console.log(plus());	//0;
   ~~~

3. rest parameter

   : 인수의 리스트를 함수 내부에서 배열로 전달받습니다.

   ~~~
   function foo(...rest) {
     console.log(rest);	//[1,2,3,4,5]
   }
   
   foo(1,2,3,4,5);
   ~~~

4. spread연산자

   ~~~
   function foo(x,y,z) {
     console.log(x);
     console.log(y);
     console.log(z);
   }
   
   const arr = [1,2,3];
   
   foo(...arr);
   ~~~



Recursion

:함수가 자기 자신을 호출하는 것을 의미.

~~~
const factorial = function(number) {
  let result = 1;
  for(let i = 1; i <= number; i++) {
    result *= i;
  }
  
 	return result;
}
~~~

memoizatiot적용

~~~
let container = {};
function fac(n) {
  if(container[n] !== undefined) {
    return container[n];
  }
  if(n === 0) {
    return container[n] = 1;
  } else {
    return container[n] = n * fac(n - 1);
  }
}
~~~

~~~
function fib(num, memo) {
  memo = memo || {};
  
  if(memo[num]) {
    return memo[n];
  }
  if(num <= 1) {
    return 1;
  }
  
  return memo[num] = fib(num - 1, memo) + fib(num - 2, memo);
}
~~~



promise의 3가지 상태

1) pending: 비동기처리 로직이 아직 완료되지않은 상태

2)fulfilled : 비동기처리가 완료되어 프로밋스가 결과값을 반환해준 상태

3)rejected: 비동기처리가 실패, 또는 오류

~~~
function getData() {
  return new Promise(function(resolve, reject) {
    setTimeoutt(function() {
      resolve(10);
    }, 1000);
  });
}
~~~



restful api.

virtual dom.

함수형프로그래밍

클래스, 상속구현

async await