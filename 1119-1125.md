<h1>
    1119
</h1>

Prototype 복습.

```
prototype
원래의 형태.

constructor
생성자 함수.
new키워드와 함께 쓰이는 함수.

생성자 함수는 함수입니다.
모든 함수는 객체입니다.
고로 생성자함수는 객체입니다!
(그리고, 객체에는 key/value를 가질 수 있습니다. -> 생성자 함수는 키/밸류를 가질수있다는 소리입니다!)
ex)Object.prototype

Instance
var obj = new Object();
//new Object()의 Object라는 녀석이 생성자함수인거고.
obj라는 녀석이 인스턴스이다.

이 obj는 엄마(Object.prototype)가 가지고 잇는 constructor라는 속성값을 훔쳐쓸 수 있다.
즉, obj.prototype을 쓸 수 가있다.
이를 prototype chain이라고 한다.


던더 프로토.

var Person = function () {
	this.name = name;
};
var junwoo = new Person('park junwoo');

junwoo.constructor === Person;	//true
junwoo.__proto__ === Person.prototype;	//true


프로토타입 체인을 behavior delegation이라고 많이 쓴다.
행동 위임 정도의 해석.
```



```
getElementsByClassName함수 구현

function getElementsByClassName(target, className){
    var arr = [];
    
    if(target.classList.contains(className)) {
        arr.push(target);
    }
    if(target.children.length){
        for(let i = 0; i < target.children.length; i++){
            arr = arr.concat(getElementsByClassName(target.children[i], className));
        }
    }
    return arr;
}
```



고차함수 복습

```
A higher order function is a functio that takes a function as an argument, or returns a function.
둘 중 하나의 조건을 만족해야 고차함수입니다.


function logNumber(n, callback){
    for(var i = 1; i <= n; i++){
        callback(i);
    }
}
logNumber(5, console.log);
logNumber(10, window.alert);
logNumber(20, console.warn);
```



```
callback이란?
- A function that is passed to another as a parameter.
다른함수에 인자로 넘어가는 함수.

자바스크립트에서 함수는 "일급"이기때문에 함수를 인자로 넘겨줄 수 있다!
```



```
first-class citizen의 조건
- 변수나 데이터 구조안에 담을 수 있다.
- 파라미터로 전달할 수 있다.
- 리턴값으로 사용할 수 있다.
```

```
자바스크립트에서는 숫자와 문자, 그리고 함수까지도 일급 객체에 속합니다.
```





<h3>
    1119수업
</h3>

Git

```
버전관리시스템.
버전관리시스템이무엇이냐!?

- 파일 변경 사항을 추적해주는 프로그램.
- 협력 개발을 도와주는 프로그램.
- 누가 언제 무엇을 수정했는지 알 수 있게 해주는 프로그램.
- 다시 과거 시점의 상태로 돌아갈 수 있게 해주는 프로그램.
```

```
Version Control.

사용자가 코드와 그 코드의 히스토리를 사용자 컴퓨터에 보관함.
인터넷 접근이 필요없음.(클라우드에 있는 정보를 업데이트하거나 받아올때를 제외.)

```

```
Snapshots

- git이 코드 히스토리를 기억하는 방식이다.
- 주어진 시점에 파일들이 어떻게 생겼는지를 기록한다.
- 시점은 우리가 선택하여 기록해달라고 명령하는것.
- 기록된 과거 시점으로 돌아갈 수 있다.
- 기록된 가장 최신 시점으로 돌아올 수 있다.
```

```
Commit

- Snapshot을 만드는 행위.
- 동사 또는 명사로 쓰인다.
- 각 Commit은 크게 세가지 정보를 보관합니다.

1. 파일 변경 사항
2. 바로 이전 Commit, 즉 "parent commit"
3. Commit hash

```

```
Repository

- 줄임말로 Repo라고 부른다.
- 모든 파일들과 그 파일들의 히스토리가 모여있는 곳.
- 모든 Commit을 포함하고 있는곳.
- 개인 컴퓨터나 클러우드서버(깃헙)에 있다.
- 클라우드에서 복사해서 다운받는 행위를 Clone이라고 한다.
- Clone을 함으로써 협업이 가능해진다.
- 내 컴퓨터에 없는 내용을 클라우드로부터 추가적으로 다운로드받는 행위를 Pull이라고 한다.(유사 : fetch)
- 내 컴퓨터의 변경 사항을 클라우드에 추가하는 행위를 Push한다고 한다.
```

```
Branch

- 모든 Commit들은 Branch내에 존재한다.
- Branch는 아주 많이 많이 있을 수 있다.
- Git에서 항상 메인 Branch는 master Branch이다.
```

```
HEAD

- 현재 Branch의 가장 마지막 Commit.
```

```
Master

- 모든 프로젝트의 가장 중심이 되는 Branch이름
```

```
Commit 만들기

파일 변경사항을 히스토리 기록에 남겨야겠다고 생각할때, 해당 변경 사항을 스테이지에 올려야 합니다.
스테이지에 올린다는 것은, 우리가 수정한 파일 내역 중에 다음 Commit에 포함하고 싶은 사항들을 예약하는 것입니다.
스테이지에 올라가 있는 사항들만이 Commit에 추가됩니다.

git add
- 변경 사항을 스테이지에 추가하는 명령어.
```

```
git log

- 위 명령어를 실행할 경우,
- Commit history를 최신순부터 보여준다.
- Commit history를 그만보고싶다면, q를 누르면 됩니다.

```

```
github

git repository 호스팅 서비스 업체.
다른 사람들과의 공유나 협업, 또는 백업을 가능케 해준다.
```



Big-O & Time Complexity

```
O(1)이 무조건 좋은것일까?
아니다.
늘 1초씩 걸린다면야 좋을수도 있을것이다. 
하지만 늘~ 항상 10년씩 걸린다면 과연 이게 좋은것일까?
상황에 따라서 O(1)이 가장 좋은게 아니란걸 기억하자.
```



<h1>
    1120
</h1>

vanilla-sorting을 어떻게 구현할 것인가.

```
조건

1.사용자가 "숫자"들을 최소 5개에서 최대 10개까지 선택할 수 있는 UI가 있어야 합니다.
2.숫자들을 입력한 후, 사용자가 원하는 정렬 방식을 선택할 수 있어야 합니다.
3.정렬 방식을 선택한 후, 실행할 수 있는 "실행" 버튼이 있어야 합니다.
4.실행시킬 경우, 시각적으로 해당 정렬 로직이 어떤 식으로 작동되는지 보여주어야 합니다. (/videos 디렉토리 내부 영상 참고)
5.숫자의 갯수가 충족되지 않았거나, 정렬 방식이 선택되지 않은 상황에서는 "실행"을 시킬 수 없어야 합니다.
6.숫자가 아닌 값은 받을 수 없어야 합니다.
```

```
1.5~10의 숫자를 입력하는 방식이 아닌, 버튼으로 클릭하는 방식으로 제작.
->1, 5, 6번 해결.

2. 정렬방식또한 버튼으로 클릭하는 방식 + 실행또한 버튼클릭해서.
->2, 3번 해결


문제는 4번. 4번을 어떻게 시각화하여 보여줄지.
```



<h1>
    1121
</h1>

Bubble Sort(거품 정렬)

```
O(n^2)의 시간복잡도를 가집니다.

var bubbleSort = function(arr){
    for(let i = 0; i < arr.length-1; i++){
        for(let j = 0; j < arr.length-1-i; j++){
            if(arr[j] > arr[j+1]){
                var temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```



Insertion Sort(삽입 정렬)

```
O(n^2)의 시간복잡도를 가집니다.

var insertionSort = function(arr){
    for(let i = 1; i < arr.length; i++){
        var temp = arr[i];
        for(var j = i-1; j > -1 && temp < arr[j]; j--){
            arr[j+1] = arr[j];
        }
        arr[j+1] = temp;
    }
}
```



Merge Sort(병합 정렬)

```
O(n log(n))의 시간복잡도를 가집니다.

var mergeSort = function(arr){
    if(arr.length === 1){
        return arr;
    }
    var toDivide = Math.floor(arr.length / 2);
    var left = arr.slice(0, toDivide);
    var right = arr.slice(toDivide);

    var innerFunc = function(left, right){
        var result = [];
        while(left.length && right.length){
            if(left[0] < right[0]){
                result.push(left[0]);
                left.shift();
            } else {
                result.push(right[0]);
                right.shift();
            }
        }
        if(left.length > 0){
            result.push(left[0]);
        } else if (right.length > 0){
            result.push(right[0]);
        }
        return result;
    }
    return innerFunc(mergeSort(left), mergeSort(right));
}
```



Selection Sort(선택 정렬)

```
O(n^2)의 시간복잡도를 가집니다.

var selectionSort = function(arr){
    for(let i = 0; i < arr.length; i++){
        var min = arr[i];
        var minIndex = i;
        var temp = arr[i];
        for(let j = i+1; j < arr.length; j++){
            if(arr[j] < min){
                min = arr[j];
                minIndex = j;
            }
        }
        arr[i] = min;
        arr[minIndex] = temp;
    }
}
```





NPM이란?

```
npm(node package manager)
npm은 node의 모듈을 관리해주는 패키지 매니저입니다.
간단히 말해서, Node.js로 만든 모듈들을 모아놓은 앱스토어같은 시스템입니다.

모듈은 무엇일까요?
모듈은 부품이라고 생각하면 됩니다.
이 부품들은 어떠한 기능들을 만드는데 도움이 되죠.
특정 모듈을 해당 모듈에 해당하는 특정 방법을따라 사용한다면 어떠한 기능을 쉽게 만들 수가 있습니다.

npm은 nodejs의 내장모듈이 아닌, 유저들이 만들어놓은 모듈들의 시장이라고 생각하면 좋을것같습니다.

```

