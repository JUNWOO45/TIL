<h1>
    1008
</h1>

<h3>
    Primitive vs Reference
</h3>

1.primitive  -> 값을 그대로 할당 

- Number
- String
- Boolean
- null
- undefined

```
var b = 'abc';
b = false;
var c = b;
	b === c
c = 20;
	b !== c
```



2.Reference

- Object -> 값이 저장된 주소값을 할당(참조)
  - Array
  - Function
  - RegExp(정규표현식)

```
var obj = {
	a: 1,
	b: 'b'
}
var obj2 = obj;
	obj2 === obj;
obj2.a = 10;
console.log(obj2.a);	//10
console.log(ojb.a);		//10

```

```
var obj3 = {
	a : [4,5,6]
}
```



<h1>
    1009
</h1>



- 클로저

  ```
  var arr = [];
  for(var i = 0; i < 3; i++){
  	arr.push(function(){console.log(i);});
  }
  
  for(var j = 0; j < 3; j++){
  	arr[j]();
  }
  
  //0,1,2가 아닌 3이 세번 출력된다.
  for문의 i가 전역변수이기 때문이다.
  
  ```

  ```
  var arr = [];
  for(var i = 0; i < 3; i++){
  	(function(index){
  		arr.push(function(){console.log(index);});
  	}(i));
  }
  
  for(var j = 0; j < 3; j++){
  	arr[j]();
  }
  // index는 자유변수다.
  // 클로저를 사용하여 0,1,2가 출력하게된다.
  ES6의 let키워드를 사용하면, 밑의 예제와 같이 클로저를 사용하지않고도 동일한 결과물을 얻을수있다.
  
  ```

  ```
  var arr = [];
  //for문의 i는 코드블록에서만 유효한 지역변수이자 자유변수이다.
  for(let i = 0; i < 3; i++){
  	arr.push(function(){console.log(i);});
  }
  
  for(var j = 0; j < 3; j++){
  	arr.[j]();
  }
  
  //let i는 for문 안에서만 유효한 지역변수이다. 또한 i는 자유변수로서 for문의 생명주기가 종료되어도 변수 i를 참조하는 함수가 존재하는 한 계속 유지된다.
  
  ```

