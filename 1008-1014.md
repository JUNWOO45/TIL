<h1>
    1008
</h1>

<h3>
    Primitive vs Reference
</h3>

1.primitive  -> 값을 그대로 할당 

- Number
- String
- Boolean
- null
- undefined

```
var b = 'abc';
b = false;
var c = b;
	b === c
c = 20;
	b !== c
```



2.Reference

- Object -> 값이 저장된 주소값을 할당(참조)
  - Array
  - Function
  - RegExp(정규표현식)

```
var obj = {
	a: 1,
	b: 'b'
}
var obj2 = obj;
	obj2 === obj;
obj2.a = 10;
console.log(obj2.a);	//10
console.log(ojb.a);		//10

```

```
var obj3 = {
	a : [4,5,6]
}
```



<h1>
    1009
</h1>



- 클로저

  ```
  var arr = [];
  for(var i = 0; i < 3; i++){
  	arr.push(function(){console.log(i);});
  }
  
  for(var j = 0; j < 3; j++){
  	arr[j]();
  }
  
  //0,1,2가 아닌 3이 세번 출력된다.
  for문의 i가 전역변수이기 때문이다.
  
  ```

  ```
  var arr = [];
  for(var i = 0; i < 3; i++){
  	(function(index){
  		arr.push(function(){console.log(index);});
  	}(i));
  }
  
  for(var j = 0; j < 3; j++){
  	arr[j]();
  }
  // index는 자유변수다.
  // 클로저를 사용하여 0,1,2가 출력하게된다.
  ES6의 let키워드를 사용하면, 밑의 예제와 같이 클로저를 사용하지않고도 동일한 결과물을 얻을수있다.
  
  ```

  ```
  var arr = [];
  //for문의 i는 코드블록에서만 유효한 지역변수이자 자유변수이다.
  for(let i = 0; i < 3; i++){
  	arr.push(function(){console.log(i);});
  }
  
  for(var j = 0; j < 3; j++){
  	arr.[j]();
  }
  
  //let i는 for문 안에서만 유효한 지역변수이다. 또한 i는 자유변수로서 for문의 생명주기가 종료되어도 변수 i를 참조하는 함수가 존재하는 한 계속 유지된다.
  
  ```



<h1>
    1010
</h1>

달력과 todo를 만들면서 합칠때 있었던 문제점.



각 날짜마다 todo를 만들고, 기존에 todo를 적어놨던 날짜를 클릭하면 기존의 todo가 보이고,  기존에 todo를 적어놓지 않았다면 빈 todo를 보여주는걸 구현하려했다.

todo목록을 만들고, 아무것도 없는 날짜를 눌렀다가 다시 todo목록이 있는 날짜를 클릭했을때 목록이 제대로 보이지않았다.

마지막 todo만 보였었음.

```
var listItem = document.createElement('LI');
var span = document.createElement("SPAN");
var txt = document.createTextNode("\u00D7");
span.className = "close";
span.appendChild(txt);

for(let i = 0; i < keysLength; i++){
            listItem.innerText = Object.keys(todoCon[abcd])[i];
            listItem.appendChild(span);
            todolist.appendChild(listItem);
        }
```

for문에서 i값이 마지막일때의 listItem.innerText만 출력됐다.

그래서 그냥 이걸 콘솔에서 만지작거려봤음.

```
var listItem = document.createElement('LI');
todolist.innerText = "밥";
todolist.appendChild(listItem);

밥이 잘 생성되었음.
그래서 하나 더 생성해보려고 했는데....!

todolist.innerText = "잠";

이라고 쓰자마자 기존의 "밥"으로 잘 출력되었던 녀석의 text가 "잠"으로 바뀌고 새롭게 "잠"이 출력 안됨.

이게 문제였다...!
```

```
고민하다가 
var listItem = document.createElement('LI');
의 위치를 바꿔보았다.
```



```
var span = document.createElement("SPAN");
        var txt = document.createTextNode("\u00D7");
        span.className = "close";
        span.appendChild(txt);
        var keysLength = Object.keys(todoCon[abcd]).length;
        
        for(let i = 0; i < keysLength; i++){
            var listItem = document.createElement('LI');
            listItem.innerText = Object.keys(todoCon[abcd])[i];
            listItem.appendChild(span);
            todolist.appendChild(listItem);
            console.log(keysLength,listItem.innerText);
        }
```

for문 안으로 listItem의 선언을 넣어주었더니...문제해결........