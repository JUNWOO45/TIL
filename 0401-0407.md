<h1>
  0401
</h1>



v8 engine

```
브라우저, node.js에섯 동작하는 자바스크립트는 모두 자바스크립트 엔진 위에서 동작핣니다.
구글에서는 V8이라는 자바스크립트 엔진을 개발했습니다.
v8은 자바스크립트를 해석하고, 기계가 인식해서 수행할 수 있는 코드로 변환하는 역할을 핣니다.
node.js는 자바스크립트를 해석하는 핵심모듈로 v8을 이용합니다.
```

Non-Blocking I/O

```
input과 output을 의미합니다.
파일이나 HTTP API요청을 읽고(input), 쓰는(output)것이 대표적인 i/o입니다.
이렇란 작업은 요청과 응답을 받기위한 대기시간이 오래걸려 실행시간에 병목이 되는 작업입니다.
Non-Blocking I/O는 하나의 작업이 완료되기 전에 다른 작업을 계속해서 수행할 수 있는 처리 방식입니다.
node.js는 대부분의 i/o작업을 논블로킹형태로 수행할 수 있도록 구현해 제공합니다.
```

Event-Driven

```
이벤트드라이븐이란, 이벤트에따라 프로그램의 실행을 제어하는 구현방식을 의미합니다.
일반적으로는, 어떤 이벤트가 발생하는지 살펴보고 있다가 해당 이벤트가 발생했을 때, 원하는 작업을 실행하는 것을 의미합니다.
node.js는 이러한 비동기작업을 구현하기 위해 내부적으로 event loop을 이용하고 있습니다.

이벤트루프는, 프로그램의 콜스택이 비어있는지를 지켜보고있다가 작업이 모두 실행되어 비어있는 상태가 되면, 콜백큐에 담긴 콜백을 하나씩 꺼내 콜스택으로 가져와 처리합니다.

```

Package Ecosystem

```
다른 개발환경에서도 마찬가지이지만, 특히나 node.js가 강력한 이유는 바로 패키지매니저때문입니다.
npm(node package manager)는 node.js가 기본적으로 포함하고 있는 자밧스크립트 언어를 위한 패키지매니저입니다.
개발자는 npm을 이용해서 자신이 필요한 라이브러리와 패키지를 바로 검색해서 설치하고 사용할 수 있습니다.
```



이 밖에도, 자바스크립트 하나로 프론트와 백엔드 모두 개발할 수 있다는 점 또한 아주 큰 장점입니다.



<h1>
  0402
</h1>

props

```
변경불가능한 데이터. 불변.
부모에게서 자식에게 데이터를 전달하는 방법.

class Welcome extends React.Component {
	render() {
    return <h1>Hello {this.props.name}</h1>
	}
}

const element = <Welcome name = "junwoo" />;
```

state

```
유동적인 데이터.
초기값 설정 필수
생성자(constructor) 안에서 this.state = {};
값을 수정할때는 this.setState({...}).
```

```
class Button extends React.Component {
  constructor() {
    super();
    this.state = {
      count: 0,
    };
  }

  updateCount() {
    this.setState((prevState, props) => {
      return {
        count: prevState.count + 1
      }
    });
  }

	render() {
    return (
    	<button onClick = {() => this.updateCount()}>Clicked {this.state.count} times! </button>
    );
	}
}

```

리액트의 component

```
클래스기반의 component와 Functional Component와의 차이점
함수형 컴포넌트는 간단한 하나의 함수로서 props를 인자로 받습니다.
따라서 내부에는 state나 lifecycle api를 가지고 있지 않습니다.
```



쿠키와 세션

```
쿠키와 세션을 사용하는 이유
- HTTP 프로토콜의 특징이자 약점을 보완하기 위해서.

1)비연결지향(Connectionless)
 - HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트의 요청에 맞는 repose를 보내고 접속을 끊는 특성을 가지고 있습니다.
2)상태정보유지안함(Stateless)
- 연결을 끊는 순간, 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성을 가지고 있습니다.

비연결지향이라는 특성덕분에 계속해서 통신연결을 유지하지않기때문에 리소스 낭비가 줄어드는 크나큰 장점입니다.
하지만 클라이언트는 내가 누구인지 인증을 계속해야만 하겠죠.

이러한 특성을 보완하기 위하여 쿠키와 세션을 사용하게되었다고 합니다.

만약, 쿠키와 세션이 없다면 페이지를 옮겨다닐때마다 로그인을 다시해야합니다.
```

쿠키

```
쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터파일입니다.
쿠키에는 이름, 값, 만료날짜(쿠키 저장기간), 경로 정보가 들어있다고 합니다.
쿠키는 일정시간동안 데이터를 저장할 수 있습니다.
쿠키는 클라이언트의 상태정보를 로컬에 저장했다가 참조합니다.

프로세스
1. 브라우저에서 웹페이지로 접속
2. 클라이언트가 요청한 웹페이지를 받으면서 쿠키를 클라이언트 로컬에 저장
3. 클라이언트가 재요청 시 웹페이지 요청과 함께 쿠키값도 전송
4. 지속적으로 로그인정보를 가지고 있는것처럼 사용!

쿠키 사례
1. 자동로그인
2. 팝업에서 "오늘 더이상 이 창을 보지 않음" 체크
3. 쇼핑몰의 장바구니

쿠키의 한계
- 클라이언트에 300개까지의 쿠키를 저장할 수 있습니다.
하나의 도메인당 20개의 값만 가질 수 있습니다.
하나의 쿠키값은 4kb까지 저장가능합니다.
```

세션

```
일정시간동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로보고 그 상태를 유지하는 기술
즉, 웹 브라우저를 통해 웹 서버에 접속한 이후로 브라우저를 종료할 때까지 유지되는 상태

클라이언트가 request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 id값을 부여하는데 이것이 세션id입니다.

프로세스
1. 클라이언트가 서버에 접속시 세션id를 발급
2. 서버에서는 클라이언트로 발급해준 세션id를 쿠키를 사용해 저장
3. 클라이언트는 다시 접속할 때, 이 쿠키를 이용해서 세션id값을 서버에 전달.
```



쿠키와 세션의 차이

```
저장위치
- 쿠키는 클라이언트에 파일로, 세션은 서버에 저장됩니다.

보안
- 쿠키는 클라이언트 로컬에 저장되기때문에 변질되거나 request에서 스나이핑당할 우려가 있어서 보안에 취약합니다.
세션은 쿠키를 이용해서 sessionid만 저장하고 그것으로 구분해서 서버에서 처리하기때문에 비교적 보안성이 좋습니다.

라이프 사이클
- 쿠키도 만료시간이 있지만 파일로 저장되기때문에 브라우저를 종료해도 계속해서 정보가 남아있을 수 있습니다.
또한 만료기간을 넉넉하게 잡아놓는다면 쿠키삭제를 할 때까지 유지가 가능합니다.
반면 세션도 만료시간을 정할 수 있지만, 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다.

속도
- 쿠키는 로컬에 정보가 있기때문에 서버에 요청시 속도가 빠릅니다.
세션은 정보가 서버에 있긱때문에 처리가 요국되어 속도가 느립니다.
```

```
세션을 주로 사용하면 좋은데 왜 쿠키를 사용할까?
- 세션은 서버의 자원을 이용하기때문에 무분별하게 세션만을 사용한다면 서버의 메모리가 감당할 수 없어져 속도가 느려질 수 있습니다.

"캐시"는 이미지나 css, js파일등이 사용자의 브라우저에 저장 되는 것입니다.
```

