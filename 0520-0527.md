<h1>
  0520
</h1>

<h3>
  구글 시트에 데이터 복사할때, 휴대폰번호 앞 0지워지지않게 하는 방법
</h3>

```
1. 구글시트 > 셀 전체선택 또는 휴대폰번호 열 선택 > 메뉴의 '서식' > 숫자 > '일반텍스트' 선택
2. 데이터복사
```




  리팩토링의 재미..!

```
1. 함수로 모듈화...!?
2. end date 자동적용 -> 시간지나도 손볼필요없게..
3. 중복의 제거!!!
4. 요구사항에 맞게 바꾸기
```



<h3>
  Toast에서 서버 구입...!
</h3>

```
크레딧으로만 무료사용하도록...안까먹게 잘 취소해야지...ㅎㅎ
```

1.인스턴스 생성

```
아직은 서버를 킨게 아닌것같다.
```

```
인스턴스는 CentOS 7.5를 선택합니다..
2019년 4.25라고 써있네요.
한달된 따끈따끈한 녀석입니다..
```

2.인스턴스 타입설정

```
굉장히 뭐가 많네요.
u2,m2,c2....u2는 또 다섯가지로 나뉩니다.
c1m1, c1m2, c2m2, c2m4, c4m4...
```

3.키페어 생성

```
키를 다운 받아놓고 그 키로 접속하는 것이라고 합니다.
당연히 키는 유출을 조심해야하니, 항상 주의해야합니다.
```

4.공인(플로팅) 아이피 생성

```
외부 연결을 위해 공인 아이피를 생성해야합니다.
공인아이피는 최소한 하나는 있어야한다고합니다.
```

5.리눅스서버 생성완료~

```
하지만 네트워크 설정이 완료되지않아 아직은 접속불가능합니다.
```

6.네트워크설정

```
ssh가 열려있지않아서 보안그룹설정(security groups)에서 서비스할 포트를 열어야합니다.
```

7.security Group 생성

```
보안그룹을 생성합니다.
SSH CIDR
```

<<<<<<< HEAD
8.인스턴스에 보안그룹연결

```
default로 되어있던 보안그룹을 nemv로 바꿔줍니다~
이제 ping으로 아이피를 확인해보니 연결이 되었네요..

핑이 날아간다는것은, ICMP가 수신이 된다는의미.
```

9.접속하기

```
키 권한 설정
: 받아놓은 키로는 맥에서 접속이 불가능해서 키 권한을 고쳐줍니다.

$ chmod 600 nemvKey.pem
```

10.연결

```
$ ssh -i nemvKey.pem centos@x.x.x.x
```




<h1>
  0521
</h1>

<h3>
  마이그레이션
</h3>

```
스트랭글러 패턴..?
```

```
t.스케줄업데이트가 0000-00-00 00:00:00인경우에 어떻게 처리?

1)최근스케줄이 없으니, 가입일을 보고 판단한다.
2)최근스케줄도 없고, 가입일도 먼 과거라면, 뭘로 판단할까?
```



<h2>
  NEMV
</h2>

1.git설치

```
$ ssh -i nemvKey.pem centos@x.x.x.x
$ sudo -i
```

로 서버에 접속합니다.

```
$ git
```

을 입력해보니...

```
-bash: git: command not found
```

git을 설치합니다.

```
$ yum -y install
$ yum -y install git
$ git --version
git version 1.8.3.1
```

음…git 최신버전이 아니네요…..



2.서비스 할 디렉토리

일반적으로 /var/www에 서비스된다고 합니다.

```
$ cd /
$ cd var
$ mkdir www
$ cd www
```



3.ssh키 등록하기

```
$ ssh-keygen -t rsa -b 4096 -C "나의 이메일"

$ cat ~/ssh/id_rsa.pub
```

키를 만들고 값을 복사한 뒤, SSH key값에 넣어줍니다.



4.깃헙에 연결

```
$ git clone 레포지토리
```

하니깐..

```
The authenticity of host 'github.com (192.30.255.113)' can't be established.
RSA key fingerprint is 불라불라
RSA key fingerprint is 불라불라불라불ㅇ
Are you sure you want to continue connecting (yes/no)? yes
```



<h1>
  0522
</h1>

<h2>
  python
</h2>



<h3>
  문자열
</h3>

```
' 이나 "을 똑같이 쓰네. 
```

```
#docstring

print('''
H
e
l
l
o
''')
이렇게 작은따옴표 3개를 쓰면 줄바꿈을 자유롭게 사용가능하게됨.
```

<h3>
  Comparison operator
</h3>

```
print(1==1) #true
print(1<2) #true
print(2<1) #false
```



<h3>
  Membership operator
</h3>

```
print("King" in "King's landing")	#true

print("Jon Snow" in "King's landing") #false
```



<h3>
  Conditional statement
</h3>

```
if user_pwd == '111111':
	print('Hello master')
else:
	print('Who are you?')
```

```
if user_id = 'junwoo':
  if user_pwd == '111111':
    print('Hello master')
  else:
    print('Who are you?')
else:
	print('Who are you?')
```



<h3>
  list
</h3>

```
JS의 array.
method는 이름이 다르니...문서를 잘 보면서 사용해야할듯.
```



<h3>
  dictionary
</h3>

```
JS의 object
```



<h3>
  loop
</h3>

###list

```
for value in ['a','b','c']:
	print(value)
  
a
b
c
가 출력된다.
JS의 for in문이랑 같네.
```

### range

```
for value in range(10):
	print(value)
	
0
1
2
3
4
5
6
7
8
9
가 출력된다.
	
```

while문도 있구나.

<h3>
  function
</h3>

```
def function():
	a=1
	b=2
	c=3
	s=a+b+c
	r=s/3
	print(r)
```

```
def function(a,b):
	a=5
	b=6
	print(a+b)
	
11
```



<h3>
  module
</h3>

```
math.py가 존재하고,
module.py에서 작업중이라면.
#math.py
def average(a,b,c):
	s=a+b+c
	print(s/3)

#module.py
import math

print(math.average(1,2,3))
```

함수만 불러올 수 도 있다고 하네요.

```
from math import average

print(average(1,2,3))
```



<hr>

지난번에 데이터베이스를 새로 import한뒤 로컬에서 돌릴때 

```
InternalError: (1449, u"The user specified as a definer ('root'@'%') does not exist")
```

에러가 생겼었는데,

그때는

```
sed -i '' 's/DEFINER=`root`@`%`//g' [DB_FILE_NAME].sql
```

로 해결한줄알았는데.. 이번엔 안되네요

해결법이 굉장히 많이있었는데..

이런 에러는 root가 가지고 있는 권한에대한 문제라고 합니다.

```
grant all on *.* to 'root'@'%' identified by 'password' with grant option;
```

로 해결했습니다.

<hr>

<h2>
  HTTP
</h2>

1990년 최초의 웹은 크게 4가지 요소로 이루어져있었다고 합니다.

```
HTML: 웹페이지를 만드는 컴퓨터 언어

URL: 이러한 웹페이지를 방문할수있도록 도와주는 주소체계

Web browser, Web server: 웹페이지를 주고받는 소프트웨어

HTTP: 웹브라우저와 웹서버가 통신할때 사용되는 통신규칙
```

웹이 폭발적으로 성장하며  HTTP는 보다 풍부한 기능을 가진 프로토콜로 발전하게 되었다고 합니다.

HTTP는 request와 response로 이루어져있습니다.

<hr>

<h1>
  Returning HTML with fetch()
</h1>

```
fetch('../../불라불라불라/toast.html')
	.then(function(html) {
		new Vue({
			el: '#app',
			template: html,
			...
		})
	})
```

이런식으로 작업했었는데, 

```
vue.js:634 [Vue warn]: invalid template option:[object Response]

(found in <Root>)
```

이런 경고가 떴습니다.

구글링해보니..

```
You need to use the .text() method, instead of .json(). This converts the byte stream into plain text, which can be parsed by the browser as HTML.

출처 : https://stackoverflow.com/questions/36631762/returning-html-with-fetch
```



그래서 바꿔줬습니다.

<hr>

<h1>
  NEMV
</h1>

yarn 설치

```
$ cd /
$ cd var/www/NEMV/be

yarn 홈페이지에서 install -> centOS클릭.
$ curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo

복사붙여넣기.

$ sudo yum -y install yarn
```

```
be에서.
$ yarn
```

```
이제
$ ls
하면,
node_modules 들어있다..!
```

```
fe에서도
$ yarn
$ yarn build
까지해줘야 dist에 빌드! 
```

이하 생략...
=======
```
fetch('../../불라불라불라/toast.html')
	.then(response => response.text())
	.then(function(html) {
		new Vue({
			el: '#app',
			template: html,
			...
		})
	});
```

성공

<h1>
  git 고장..
</h1>

```
git branch --set-upstream-to=origin/master
```

이거입력했는데 뭐가 잘못된듯.

```
<script src="https://unpkg.com/vue"></script>
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
  
  <script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>
```



<h1>
  0523
</h1>

```
API경로를 모드별로 변경
```

```
// src/main.js

Vue.prototype.$apiRootPath = process.env.NODE_ENV !== 'production' ? 'http://localhost/api/' : '/api/'
```

```
src/views/user.vue

axios.get(`${this.$apiRootPath}user`)
```

```
src/App.vue

			...
			rightDrawer: false,
      title: this.$apiRootPath
}
```

<h1>
  0524
</h1>

```
pm2란?
- 프로세스(노드) 매니져입니다.
Process Manager!
노드가 돌다가 코드가 꼬여서 꺼지면 다시 실행시켜줍니다.
다시 실행시켜주는것 뿐만아니라, 이것저것 여러것들을 관리해주는 이름 그대로 프로세스 매니져라고합니다.
```

```
$ yarn global add pm2
```

```
pm2 start ./be/bin/www
```

로 실행시켜주고,

```
pm2 log
```

로 로그도보고..

```
pm2 stop www
```

로 멈추고,

```
pm2 delete www
```

로 삭제도했습니다.



프로젝트 최상단에서

```
$ pm2 init
```

명령어를 입력하면

ecosystem.config.js 파일이 생성됩니다.

```
module.exports = {
  apps : [{
    name      : 'API',
    script    : 'app.js',
    env: {
      NODE_ENV: 'development'
    },
    env_production : {
      NODE_ENV: 'production'
    }
  }],

  deploy : {
    production : {
      user : 'node',
      host : '212.83.163.1',
      ref  : 'origin/master',
      repo : 'git@github.com:repo.git',
      path : '/var/www/production',
      'post-deploy' : 'npm install && pm2 reload ecosystem.config.js --env production'
    }
  }
};
```

요런 파일이네요.

```
module.exports = {
apps : [{
    name      : 'nemv',
    script    : './be/bin/www',
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production : {
      NODE_ENV: 'production',
      PORT: 80
    }
    ...
}
```

이렇게 port번호를 입력해주고, 이름이랑 script도 바꿔줍니다.

```
$ pm2 start --env production
```

을 입력하면 production(배포용)이 실행됩니다.

이름을 변경할 수 있는데요,

```
module.exports = {
apps : [{
    name      : 'nemv',
    script    : './be/bin/www',
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_pr : {
      NODE_ENV: 'production',
      PORT: 80
    }
    ...
}
```

이런식으로 에코시스템js를 바꿔주면,

```
$ pm2 start --env pr
```

로 입력ㅎㅏ면 실행됩니다.

<hr>

```
$ pm2 install pm2-logrotate 
```

pm2 log로 보이는 수많은 로그들..

그게 계속 쌓인다고합니다.

심지어 나중에는 몇기가가 될 수도...

그러면 서버가 뻗는다고합니다.

그래서, 서버 제한도 두고, 날짜별로 로그를 커팅해주는 녀석이 로그로테이트라고합니다.

7일만 저장하게 해보려고합니다.

```
$ pm2 set pm2-logrotate:retain 7
```

이제 로그는 7일동안만 유지가됩니다..!