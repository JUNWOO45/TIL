<h1>
    1112
</h1>

1.즐겨찾기해놓은 현섭님의 블로그의 closure부분 정리하기.(블로깅을 위한.)

2.지난 수업시간에 배운 this 정리하기.



- Closure 다시 정리해보기

```
만들어졌을때의 환경을 기억.
```



- 클로저를 통한 은닉화.

```
function Hello(name){
    this._name = name;
}

Hello.prototype.say = function(){
    console.log('hello! ' + this._name);
}

var hello1 = new Hello('준우');

hello1.say();	// 'hello! 준우'
```

Hello()로 생성된 객체들은 모두 _name이라는 변수를 가집니다.

(변수명 앞에 underscore(_)를 포함하면, 일반적으로 이 변수는 Private variable로 사용할것이라는 의도를 뜻합니다.)

이 _name이라는 변수는 외부에서도 쉽게 접근 가능합니다.



이럴때 클로저를 사용하여 외부에서 내부의 변수로의 접근을 제한할 수 있습니다.

```
function Hello(name){
    var _name = name;
    return function(){
        console.log('hello! '+ _name);
    }
}

var hello1 = Hello('준우');

hello1();	//'hello! 준우'
```





- 반복문 클로저

```
for(var i = 0; i < 10; i ++){
    setTimeout(function(){
        console.log(i);
    }, 100);
}
```

0~9까지의 정수를 출력하려는 의도로 만든 코드이지만, 사실 10만 10번 출력됩니다.

왜 그럴까요?

```
setTimeout()에 인자로 넘긴 익명함수(function(){console.log(i)})는 모두 0.1초 뒤에 호출됩니다.
그 0.1초 사이에 반복문은 이미 이미 순회하여 i값은 10이 된 상태입니다.
i가 10이 된 상태에서 익명함수가 호출되므로, 10이 10번 출력되어버립니다.
```

이 경우에도 클로저를 사용하여 해결할 수 있습니다.

```
for(var i = 0; i < 10; i++){
    (function(j){
        setTimeout(function(){
            console.log(j);
        }, 100);
    })(i);
}
```

IIFE를 사용하여 setTimeout()에 걸린 익명함수를 클로저로 만들었습니다.

for문의 i는 즉시실행함수에 j라는 형태로 들어갑니다.

