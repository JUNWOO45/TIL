<h1>
    1126
</h1>

Hash Table

```
insertion: O(1)
deletion: O(1)
search: O(1)
```

Is hash table perfect?

```
not suitable for ordered data.
might need large space allocation.
must have a good hash function.
```

hash function

```
hash function needs to be idempotent.
 같은input이라면 output은 일정해야함.

hash function needs to have a good distribution of values.

hash function needs to be performant.
 성능이 좋아야함.

```

```
전화번호부, 블록체인
```

Hash tables in javascript

```
A lot of times, we use javascript plain objects in the place of hash table.

객체가 해시테이블과 비슷한 구조이기에, 객체를 자주 사용하게 될 것.
사실 프론트엔드 개발을 하면서 해시함수를 구현하는일 등을 자주 하게 되지는 않을것.

javascript is high level language.
programmers don't manage memory themselves.

javascript objects use hash tables.

javascript Map is not stable yet.
```



Tree

```
what is "node"?
- A node is a basic unit used in computer science.
```

```
조직도, DOM, File System,..
계층이 있는 자료를 다룰때.
```

```
Binary Search Tree
자식노드를 0개, 1개, 2개까지 가질 수 있음.

Big-O average

insertion: O(log n)
deletion: O(log n)
search: O(log n)

Big-O worst (한쪽으로 다 몰렸을때.4,7,16,20,37,38,43 처럼 다 오른쪽으로)

insertion: O(n)
deletion: O(n)
search: O(n)
```

```
real life use cases
- searching in an ordered data
- AVL Tree
```

```
binary tree VS binary search tree
```



<h3>
    수업
</h3>

Sortin Algoriths - Part 1

Bubble Sort & Insertion Sort

```
안정정렬이란?

```

```
Bubble Sort

- At the end of the kth pass, the k rightmost elements are in their final positions.
->한바퀴 돌면 뒤에서 한개는 제자리를 찾은것. 두바퀴 돌면 뒤에서 두개는 제자리를 찾은것.

worst : O(n^2)
best: O(n) 이미정렬이 되어있어서 쭉~한번 훑으면 될때.

1.Memory : bubble sort is "in place" algoritm.
추가적인 메모리소모없이 사용가능한 알고리즘.
2.Easy to write : ideal for beginners

3.최고의상황에서 O(n)의 시간복잡도를 가지기에, Good for testing wheter a list is sorted or not.

```

```
Insertion Sort

worst : O(n^2) 버블과 마찬가지로, 거꾸로 정렬이 되어있을때.
best : O(n) 버블과 마찬가지로, 다 정렬이 되어있을때.

```



<h1>
    1127
</h1>

Prototype : 원래의 형태 또는 전형적인 예. 기준 또는 표준.

Constructor : 생성자 함수
-> new 키워드와 함께 쓰이는 함수. 를 생성자 함수라고 말한다.

new Array();
new Object();
new Function();

생성자 함수는 일반적으로 첫글자를 대문자로 표기합니다.

"(거의)모든 자바스크립트 객체는 생성자 함수를 이용해 만들어집니다."

생성자 함수는 말 그대로 함수입니다.
모든 함수는 객체입니다.
고로, 생성자 함수 또한 객체입니다.

객체란?
key/value를 가질 수 있습니다.(속성/값)
고로, 생성자 함수는 key/value를 가질 수 있습니다.
예를 들면? Object.prototype

우리가 생성자 함수를 만들 수 있습니다.
생성자 함수이냐 아니냐는 단지 그 쓰임새에 달린 문제입니다.(앞에 new를 붙여서 생성자 함수로 쓰느냐..아니냐..)

Constructor(생성자함수) 에게는 항상 .prototype이 있고 그 결과는 Prototype이라는 객체이다.(prototype이라는 속성이 있다.)
이 Prototype이라는 객체에게는 .constructor(constructor라는 객체)가 또 있다.



<h1>
    1128
</h1>

```
콜백함수.
함수가 인자로들어간다.

A higher order function
함수를 인자로받거나, 함수를 리턴하거나.
ex) map, reduce
```

```
event.target
이벤트가 발생된 최초 element
```

```
event.currentTarget
이벤트가 실제로 등록되어있는 element
```

```
event.preventDefault
해당 이벤트의 브라우저 기본 동작을 방지하는 함수
```

```
event.stopPropagtion
해당 이벤트의 흐름을 중지시키는 함수
```

```
Event의 흐름
- Event Capturing
- Event Bubbling
```

```
Event Handler 등록

- Capturing
var someElement = document.querySelector(".container);
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
}, true);


- Bubbling
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
});
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
}, false);


항상 이벤트 버블링을 쓰게될것.
"캡쳐링을 쓸 상황이 거의 없을것입니다."
```



```
This

1.일반함수실행방식.
- window

1-2. in strict mode
- undefined

2.Dot notation
- dot 앞.

3.call apply bind
```



<h3>
    수업
</h3>

What does "stable" mean?

```
기존 기록에서의 순서를 유지.
```

What does "in place" mean?

```
새로운 저장공간 필요없이. without requiring additional space.
```



Selection Sort

```
worst : O(n^2)
best : O(n^2)

advantages
1. in place
2. easy to write

unstable하다.
```



Merge Sort

```
worst : O(n log n)
best : O(n log n)

disadvantages
- requires additional O(n) space.

advantages
1. Best case, Worst case : All O(n log n)

Divide and Conquer 분할정복

```

```
TODO

Quick Sort
Divide and Conquer
Dynamic Programming
```



ES2015

```
let

호이스팅
let은 초기화가 되지않는다. 초기화와 할당이 동시에 일어나기에, 호이스팅이 곤란하다.
Must Read "Temporal Dead Zone"
```

```
const
```



```
rest parameter(...)
```



```
spread operator
발라먹는버터
```



```
destructuring
```



```
default parameter
```



<h1>
    1129
</h1>

Quick sort

```
퀵 정렬은 분할정복(divide and conquer)방법을 통해 리스트를 정렬합니다.
1. 리스트 중 하나의 원소를 고릅니다.(이 원소를 피벗이라고 부릅니다.)
2. 피벗앞에는 피벗보다 값이 작은 모든 원소들이 오도록하고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록합니다.
3. 분할된 두개의 작은 리스트에대해 재귀적으로 이 과정을 반복합니다.
```

```
function QuickSort(arr) { 
	if(arr.length === 0 ) { 
		return []; 
    } 
var middle = arr[0]; 
var len = arr.length; 
var left = [], right = []; 
for(var i = 1; i < len; ++i) { 
	if( arr[i] < middle ) { 
		left.push(arr[i]); 
	} else { 
		right.push(arr[i]); 
	} 
} 
	return QuickSort(left).concat(middle, QuickSort(right)); 
}

출처: https://boycoding.tistory.com/74 [소년코딩]
```



분할정복

```
분할정복이란, 한 문제를 유형이 비슷한 여러개의 하위문제로 나누어 재귀적ㅇ로 해결하고 이를 합쳐 원래 문제를 해결하는 방식입니다.
분할정복방식이 하위문제를 재귀적으로 해결하기때문에, 하위문제 각각은 원래 문제보다 범위가 작아야하며 하위문제는 각 문제마다 탈출조건이 존재해야 합니다.
```

```
1. 분할 : 원래 문제를 분할하여 비슷한 유형의 더 작은 하위 문제들로 나눕니다.
2. 정복 : 하위 문제 각각을 재귀적으로 해결합니다.
3. 합치기 : 하위 문제들의 답을 합쳐서 원래 문제를 해결합니다.
```



Dynamic Programming

```
다이나믹 프로그래밍.
작은 문제의 답을 조합해서 큰 문제의 답을 푸는것.

동적 계획법이 올바른 번역이라고 합니다.

다이나믹 프로그래밍은 문제의 답이 이용되는 구조를 이용한 알고리즘입니다.
큰 문제를 작은 문제로 나눈다는 측면에서 분할정복알고리즘과 비슷하지만 차이점또한 존재합니다
```

| DaC                    | DP                      |
| ---------------------- | ----------------------- |
| 문제가 절반으로 줄어듬 | 문제가 -1로 줄어듬      |
| Function problem       | 최적화문제              |
| 결과가 한번 사용       | 결과가 여러번 사용됨    |
| 분할이 성능향상.       | 결과 재사용이 성능향상. |



다이나믹 프로그래밍 알고리즘을 적용하기위해서는 다음과 같은 조건을 만족해야합니다.

- Overlapping Subproblem

```
중복되는 부분 문제를 뜻합니다.
예를 들자면, N번째 피보나치수를 구하는 문제는 N-1번째나 N-2번째 피보나치수를 구하는 문제와 같습니다.
```

- Optimal Substructure

```
문제의 정답으로 작은 문제의 정답을 구할 수 있음을 뜻합니다.
다이나믹 프로그래밍에서는 작은 문제들을 한 번만 풀어야합니다.(시간을 줄이기위해서.)
그리고 정답을 구했으면 이 답을 어딘가에 저장시켜두고(메모아이제이션) 이 답을 이용해서 큰 문제를 풉니다.
이때 저장되는 공간을 cache라고 합니다.
```

다이나믹 프로그래밍 문제를 푸는 방법에는 크게 두가지가 있습니다.

- Top-down

```
탑-다운 방식은 다음과 같습니다.
1. 문제를 작은 문제로 나눈다.
2. 작은 문제들을 푼다.
3. 작은 문제들의 답으로 전체 문제를 푼다.
```

- Bottom-up

```
바텀-업 방식은 다음과 같습니다.
1. 가장 작은 문제부터 푼다.
2. 문제의 크기를 점점 크게 만들어서 전체문제를 푼다.
```

