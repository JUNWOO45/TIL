<h1>
    1126
</h1>

Hash Table

```
insertion: O(1)
deletion: O(1)
search: O(1)
```

Is hash table perfect?

```
not suitable for ordered data.
might need large space allocation.
must have a good hash function.
```

hash function

```
hash function needs to be idempotent.
 같은input이라면 output은 일정해야함.

hash function needs to have a good distribution of values.

hash function needs to be performant.
 성능이 좋아야함.

```

```
전화번호부, 블록체인
```

Hash tables in javascript

```
A lot of times, we use javascript plain objects in the place of hash table.

객체가 해시테이블과 비슷한 구조이기에, 객체를 자주 사용하게 될 것.
사실 프론트엔드 개발을 하면서 해시함수를 구현하는일 등을 자주 하게 되지는 않을것.

javascript is high level language.
programmers don't manage memory themselves.

javascript objects use hash tables.

javascript Map is not stable yet.
```



Tree

```
what is "node"?
- A node is a basic unit used in computer science.
```

```
조직도, DOM, File System,..
계층이 있는 자료를 다룰때.
```

```
Binary Search Tree
자식노드를 0개, 1개, 2개까지 가질 수 있음.

Big-O average

insertion: O(log n)
deletion: O(log n)
search: O(log n)

Big-O worst (한쪽으로 다 몰렸을때.4,7,16,20,37,38,43 처럼 다 오른쪽으로)

insertion: O(n)
deletion: O(n)
search: O(n)
```

```
real life use cases
- searching in an ordered data
- AVL Tree
```

```
binary tree VS binary search tree
```



<h3>
    수업
</h3>

Sortin Algoriths - Part 1

Bubble Sort & Insertion Sort

```
안정정렬이란?

```

```
Bubble Sort

- At the end of the kth pass, the k rightmost elements are in their final positions.
->한바퀴 돌면 뒤에서 한개는 제자리를 찾은것. 두바퀴 돌면 뒤에서 두개는 제자리를 찾은것.

worst : O(n^2)
best: O(n) 이미정렬이 되어있어서 쭉~한번 훑으면 될때.

1.Memory : bubble sort is "in place" algoritm.
추가적인 메모리소모없이 사용가능한 알고리즘.
2.Easy to write : ideal for beginners

3.최고의상황에서 O(n)의 시간복잡도를 가지기에, Good for testing wheter a list is sorted or not.

```

```
Insertion Sort

worst : O(n^2) 버블과 마찬가지로, 거꾸로 정렬이 되어있을때.
best : O(n) 버블과 마찬가지로, 다 정렬이 되어있을때.

```



<h1>
    1127
</h1>

Prototype : 원래의 형태 또는 전형적인 예. 기준 또는 표준.

Constructor : 생성자 함수
-> new 키워드와 함께 쓰이는 함수. 를 생성자 함수라고 말한다.

new Array();
new Object();
new Function();

생성자 함수는 일반적으로 첫글자를 대문자로 표기합니다.

"(거의)모든 자바스크립트 객체는 생성자 함수를 이용해 만들어집니다."

생성자 함수는 말 그대로 함수입니다.
모든 함수는 객체입니다.
고로, 생성자 함수 또한 객체입니다.

객체란?
key/value를 가질 수 있습니다.(속성/값)
고로, 생성자 함수는 key/value를 가질 수 있습니다.
예를 들면? Object.prototype

우리가 생성자 함수를 만들 수 있습니다.
생성자 함수이냐 아니냐는 단지 그 쓰임새에 달린 문제입니다.(앞에 new를 붙여서 생성자 함수로 쓰느냐..아니냐..)

Constructor(생성자함수) 에게는 항상 .prototype이 있고 그 결과는 Prototype이라는 객체이다.(prototype이라는 속성이 있다.)
이 Prototype이라는 객체에게는 .constructor(constructor라는 객체)가 또 있다.



<h1>
    1128
</h1>

```
콜백함수.
함수가 인자로들어간다.

A higher order function
함수를 인자로받거나, 함수를 리턴하거나.
ex) map, reduce
```

```
event.target
이벤트가 발생된 최초 element
```

```
event.currentTarget
이벤트가 실제로 등록되어있는 element
```

```
event.preventDefault
해당 이벤트의 브라우저 기본 동작을 방지하는 함수
```

```
event.stopPropagtion
해당 이벤트의 흐름을 중지시키는 함수
```

```
Event의 흐름
- Event Capturing
- Event Bubbling
```

```
Event Handler 등록

- Capturing
var someElement = document.querySelector(".container);
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
}, true);


- Bubbling
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
});
someElement.addEventListener("click", function onClick(ev){
    console.log("clicked!");
}, false);
```

