<h1>
    0225
</h1>

~~~
리액트 책 빠르게 훑기
과제정리
회사정리
바닐라 자바스크립트 복습
~~~





<h1>
    0226
</h1>
Promise란

```
프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다.
```

Promise가 왜 필요한가요?

```
프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.
서버에서 데이터를 받아오기도 전에 마치 데이터를 다 받아온것처럼 화면에 표시하려고한다면 오류가 발생하거나 빈화면이 뜰것입니다.
이와 같은 문제점을 해결하기 위한 방법중 하나가 프로미스입니다.
```

프로미스 코드 - 기초

```
다음은 간단한 ajax통신 코드입니다.

function getData(callbackFunc) {
    $.get('url 주소', function(response) {
        callbackFunc(response);
    })
    
    getData(function(tableData) {
        console.log(tableData);
    })
}

위 코드에 프로미스를 적용한다면 다음과 같습니다.

function getData(callback) {
    return new Promise(function(resolve, reject) {
        $.get('url 주소', function(response) {
            resolve(response);
        });
    });
}

getData().then(function(tableData) {
    console.log(tableData);
});

콜백함수로 처리하던 구조에서 new Promise(), resolve(), then()처럼 프로미스 API를 사용하는 구조로 바뀌었습니다.
```

프로미스의 3가지 상태(state)

```
프로미스의 가장 기본적인 개념이 프로미스 상태(state)입니다.
상태란, 프로미스의 처리과정을 의미합니다.
new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 가집니다.

- pending(대기) : 비동기 처리 로직이 아직 완료되지않은 상태.
- fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과값을 반환해준 상태.
- rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태.
```

Pending(대기)

```
다음과 같이 new Promise()메서드를 호출하면 pending상태가 됩니다.

new Promise();

이렇게 new Promise()메서드를 호출할 때 콜백함수의 인자로 resolve, reject에 접근할 수 있습니다.

new Promise(function(resolve, reject) {
    //..
});
```

Fulfilled(이행)

```
콜백함수의 인자 resolve를 아래와같이 실행하면 fulfilled상태가 됩니다.

new Promise(function(resolve, reject) {
    resolve();
});

fulfilled(이행)상태가 되면, 다음과같이 then()을 이용하여 처리 결과값을 받을 수 있습니다.

function getData() {
    return new Promise(function(resolve, reject) {
        var data = 100;
        resolve(data);
    });
}

getData().then(function (resolvedData) {
    console.log(resolvedData);	//100
});
```

Rejectd(실패)

```
new Promise()로 프로미스 객체를 생성하면 콜백함수 인자로 resolve와 reject를 사용할 수 있죠.
여기서reject인자로 reject()메서드를 실행하면 Rejected(실패)상태가 됩니다.

new Promise(function(resolve, reject) {
    reject();
});

그리고 실패상태가되면, 실패처리의 결과값을 catch()로 받을 수 있습니다.

function getData() {
    return new Promise(function(resolve, reject) {
        reject(new Error("Request is failed"));
    });
}

getData().then().catch(function(err) {
    console.log(err);
});
```



<h1>
    0227
</h1>

Prototype : 원래의 형태 또는 전형적인 예. 기준 또는 표준.

Constructor : 생성자 함수
-> new 키워드와 함께 쓰이는 함수. 를 생성자 함수라고 말한다.

new Array();
new Object();
new Function();

생성자 함수는 일반적으로 첫글자를 대문자로 표기합니다.

"(거의)모든 자바스크립트 객체는 생성자 함수를 이용해 만들어집니다."

생성자 함수는 말 그대로 함수입니다.
모든 함수는 객체입니다.
고로, 생성자 함수 또한 객체입니다.

객체란?
key/value를 가질 수 있습니다.(속성/값)
고로, 생성자 함수는 key/value를 가질 수 있습니다.
예를 들면? Object.prototype

우리가 생성자 함수를 만들 수 있습니다.
생성자 함수이냐 아니냐는 단지 그 쓰임새에 달린 문제입니다.(앞에 new를 붙여서 생성자 함수로 쓰느냐..아니냐..)

Constructor(생성자함수) 에게는 항상 .prototype이 있고 그 결과는 Prototype이라는 객체이다.(prototype이라는 속성이 있다.)
이 Prototype이라는 객체에게는 .constructor(constructor라는 객체)가 또 있다.



<h1>
    0228
</h1>

Hash Table

```
insertion: O(1)
deletion: O(1)
search: O(1)
```

Is hash table perfect?

```
not suitable for ordered data.
might need large space allocation.
must have a good hash function.
```

hash function

```
hash function needs to be idempotent.
 같은input이라면 output은 일정해야함.

hash function needs to have a good distribution of values.

hash function needs to be performant.
 성능이 좋아야함.

```

```
전화번호부, 블록체인
```

Hash tables in javascript

```
A lot of times, we use javascript plain objects in the place of hash table.

객체가 해시테이블과 비슷한 구조이기에, 객체를 자주 사용하게 될 것.
사실 프론트엔드 개발을 하면서 해시함수를 구현하는일 등을 자주 하게 되지는 않을것.

javascript is high level language.
programmers don't manage memory themselves.

javascript objects use hash tables.

javascript Map is not stable yet.
```

