<h1>
    0311
</h1>

defaultProps

props의 기본값을 설정해줄 수 있습니다.

```
static defaultProps = {
    name: "기본값"
}
render() {
    return (
    	<div>
    		안녕하세요? 제 이름은 {this.props.name}입니다!
    	</div>
    );
}
```

state

```
class Counter extends Component {
    constructor(props) {
        super(props);
        this.state = {
            number : 0
        }
    }
}
```

this.setState

:state값을 바꾸기위해서는 this.setState를 무조건 거쳐야합니다.

리액트에서는 this.setState가 실행되면 컴포넌트가 리렌더링되도록 설계되어있습니다.

this.setState는 객체의 깊은곳까지 확인하지 못합니다.

따라서 만약 다음과 같이 state가 설정되어있다면,

```
state = {
    number: 0,
    foo: {
        bar: 0,
        foobar: 1
    }
}
```

아래와같이 setState를 한다고해서 foobar값이 업데이트되지 않습니다.

```
this.setState({
    foo: {
        foobar: 2
    }
});
```

이렇게하면 다음과같이 기존의 foo객체가 바뀌어버립니다.

```
state = {
    number: 0,
    foo: {
        foobar: 2
    }
}
```

이런 상황에서는 다음과같이 해주어야합니다.

```
this.setState({
    number: 0,
    foo: {
        ...this.state.foo,
        foobar: 2
    }
});
```



<h1>
    0313
</h1>

LifeCycle API

: 이 API는 컴포넌트가 브라우저에서 나타날때, 사라질때, 그리고 업데이트될때 호출되는 API입니다.

1. 컴포넌트 초기생성

   컴포넌트가 브라우저에 나타나기 전, 후에 호출되는 API들이 있습니다.

   1) construnctor

   ```
   constructor(props) {
       super(props);
   }
   ```

   컴포넌트 생성자 함수입니다.

   컴포넌트가 새로 만들어질때마다 이 함수가 호출됩니다.

   2)componentWillMount

   ```
   componentWillMount() {
       
   }
   ```

   컴포넌트가 화면에 나타나기 직전에 호출되는 API입니다.

   v16.3부터 deprecated되었습니다.

   3)componentDidMount

   ```
   componentDidMount() {
       //외부 라이브러리 연동
       //데이터요청 : ajax, graphql
       //dom에 관련된 작업: 스크롤설정
   }
   ```

   컴포넌트가 화면에 나타났을때 호출됩니다.

2. 컴포넌트 업데이트

   컴포넌트의 업데이트는 props의 변화, state의 변화에 의해 결정됩니다.

   1 )shouldComponentUpdate

   ```
   shouldComponentUpdate(nextProps, nextState) {
       //returrnr false하면 업데이트를 하지 않습니다.
       
       return true;
   }
   ```

   컴포넌트를 최적화하는 작업에서 매우 유용하게 사용됩니다.

   2 )componentDidUpdate

   ```
   componentDidUpdate(prevProps, prevState, snapshot) {
       
   }
   ```

   컴포넌트에서 render()를 호출하고난 다음에 발생합니다.

   이 시점에서는 이미 this.props와 this.state가 바뀌어있씁니다.

   그리고 파라미터를 통해 이전의 값인 prevProps와 prevState를 조회할 수 있습니다.

3. 컴포넌트제거

   컴포넌트가 더 이상 필요하지 않게되면 다음 API가 호출됩니다.

   1) componentWillUnmount

   ```
   componentWillUnmount() {
       //이벤트, setTimeOutt, 외부 라이브러리 인스턴스 제거거거거
   }
   ```

4. 컴포넌트에 에러 발생

   render함수에서 error가 발생했을 때 유용한 API가 있습니다.

   1) componentDidCatch

   ```
   componentDidCatch(error, info) {
       this.setState({
           error: true
       });
   }
   ```



<h1>
    0314
</h1>

~~~
- 콜백헬이 뭘까요?
비동기 자바스크립트, 또는 콜백을 사용하는 자바스크립트는 직관적이지 못합니다.
//
콜백헬의 예제..
//

저 피라미드구조와, 끝의 })를 보세요. 이게 바로 콜백헬입니다.

콜백헬의 원인은 사람들이 자바스크립트의 실행이 시각적으로 위에서 아래로 발생하려는 방식으로 자바스크립트를 작성하기때문에 발생합니다.
많은 사람들이 이러한 실수를 하죠!
C, 루비, 파이썬등은 첫번째 줄에 무엇이 써있든 간에 두번째 줄이 실행되기 전에 끝날거라고 예측가능합니다.
하지만 자바스크립트는 다르죠.

- 그래서 콜백헬이 뭔데?
콜백이란 단지 자바스크립트 함수를 사용하는 이름일 뿐입니다.
자바스크립트에서 콜백을 부른다는건 특별할게 없어요.
즉시 어떠한 결과를 리턴하는 대부분의 함수와는 달리, 콜백을 사용하는 함수는 결과를 생산해내는데 약간의 시간이 필요할 뿐이죠.
"asynchronous"라는 단어는 단지 "시간이 약간 걸려." 혹은 "미래에 일어날 일이지. 지금이 아니고!"의 의미를 가지고 있답니다.
보통 콜백은 입출력, 다운로드, 파일읽기, 데이터베이스 등에 사용됩니다.

일반적인 함수를 실행할때 우린 리턴결과값을 사용할 수 있습니다.
var result = multiplyTwoNumbers(5, 10);
console.log(result);	//50

그러나, 콜백을 사용하고 비동기함수람련 당장 리턴하지않습니다.
var photo = downloadPhoto("https://coolcats.com/cat.gif")
//photo is 'undefined'

이때, gif파일을 다운받는데에는 굉장히 오랜 시간이 걸리고, 우린 다운로드가 끝날때까지 우리의 프로그램이 멈추는걸 보고싶지않아요.

대신에, 당신은 다운로드가 완료된 후에 실행되어야할 코드를 함수에 저장합니다.
이것이 콜백입니다!

downloadPhoto("https://coolcats.com/cat.gif", handlePhoto)

function handlePhoto(error, photo) {
    if(error) {
        console.error("donwload error!", error);
    } else {
        console.log("donwload finished", photo);
    }
}

console.log("donwload started");

우리가 콜백을 이해할때 가장 큰 장애물은 프로그램이 실행되는 순서입니다.
위의 예시에서는 크게 3가지 일이 일어납니다.
1. handlePhoto함수가 선언되었고, 
2. downloadPhoto함수가 실행되었을때 handlePhoto가 콜백으로 넘어가고,
3. 최종적으로 "download started"가 출력됩니다.

handlePhoto가 아직 실행되지 않았다는 것을 기억해야합니다.
단지 콜백으로써, downloadPhoto안으로 들어갔을 뿐이죠.
downloadPhoto가 완료되기 전까지는 절대 실행되지않습니다.

이 예시는 두가지 중요한 컨셉을 시사합니다.
1. handlePhoto 콜백은 나중에 실행되어야할 무언가를 저장하는 용도이다.
2. 실행되는 순서는 위에서 아래순서가 아니라, 언제 종료되느냐에 달려있다.

- 콜백헬을 어떻게 고치죠?
콜백헬은 나쁜 코딩습관때문에 발생합니다.
우리는 세가지 규칙을 지켜야합니다.

1) 코드를 가볍게 유지하기.
다음은 복잡하게 엉킨 AJAX입니다.

var form = document.querySelector("form");
form.onsubmit = function(submitEvent) {
    var name = document.querySelector("input").value;
    request({
        uri : "http://.....",
        body : name,
        method: "POST"
    }, function(err, response, body) {
        var statusMessage = document.querySelector(".status");
        if(err) {
            return statusMessage.value = err;
        }
        statusMessage.value = body;
    });
};

위의 코드는 두개의 익명함수를 가지고 있습니다. 이름을 만들어주죠!

var form = document.querySelector("form");
form.onsubmit = function formSubmit(submitEvent) {
var name = document.querySelector("input").value;
    request({
        uri : "http://.....",
        body : name,
        method: "POST"
    }, function postResponse(err, response, body) {
        var statusMessage = document.querySelector(".status");
        if(err) {
            return statusMessage.value = err;
        }
        statusMessage.value = body;
    });
};

당신이 볼 수 있듯이, 기명함수는 좋은 장점들을 가지고 있습니다.
1. 함수 이름의 묘사를 보고 쉽게 읽을 수 있습니다.
2. 예외가 발생했을때, "anonymous"대신 함수 이름을 보고 쉽게 추적할 수 있습니다.
3. 함수로 이동하고 함수이름으로 참조할 수 있게 해줍니다.

다시 손봅시다!

document.querySelector("form").onsubmit = formSubmit;

function formSubmit(submitEvent) {
    var name = document.querySelector("input").value;
    reqeust({
        uri : "http://.....",
        body : name,
        method: "POST"
    }, postResponse);
}

function postResponse(err, response, body) {
    var statusMessage = document.querySelector(".status");
    if(err) {
    	return statusMessage.value = err;
    }
    statusMessage.value = body;
}

함수호이스팅덕분에 함수를 아래 선언할 수도 있었습니다.

2) 모듈화
가장 중요한 부분입니다 : 누구나 모듈을 만들 수 있다!
"한가지 일만 하는 작은 모듈을 만들고, 좀 더 큰 일을 하는 모듈에게로 조립시켜라. 가지 않는다면, 콜백헬에 갈 수 없는건 당연하다."

위의 예시를 다시 가져와서 모듈화해봅시다.
몇개의 파일로 쪼갤거에요.
브라우저코드와 서버코드로 나누어서 모듈패턴을 적용해보죠.

formuploader.js라는 새로운 파일입니다. 2가지 함수를 가지고있죠.

module.exports.submit = formSubmit;

function formSubmit(submitEvent) {
    var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, postResponse)
}

functin posetResponse(err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}

module.exports는 node에서 작동하는 모듈시스템입니다.

이제 우리는 formuploader.js을 가지고 있으니 이걸 사용해야합니다.

var formUploader = require("formuploader");
document.querySelector("form").onsubmit = formUploader.subit;

이제, 우리의 어플리케이션은 오직 2줄의 코드만을 가지고 있고 다음과같은 이점을 가집니다.
1. 새로운 개발자가 이해하기 쉽습니다.
2. formuploader는 이제 코드를 복사하지않고도 다른곳에서 쓰일 수 있습니다.

3)모든 단위의 에러를 다루기
수많은 타입의 에러들이 있습니다.
syntax errors는 프로그래머에의해 발생합니다.
runtime errors도 마찬가지구요.
platform errors는 잘못된 파일 사용권한, 하드 드라이브 오류, 네트워크 연결없음 등의 이유로 발생합니다.
이번 섹션은 이 마지막 오류를 다룰겁니다.

1), 2)규칙은 주로 코드를 읽기쉽게 만드는데에 반해, 3)규칙은 코드를 안정적으로 만들기위함에 가깝습니다.
When dealing with callbacks you are by definition dealing with tasks that get dispatched, go off and do something in the background, and then complete successfully or abort due to failure. 
어떠한 경험많은 개발자라도 당신에게 이렇게 말할겁니다.
언제 에러가 발생할지 모르니, 항상 대비하고 있어야한다고.

에러를 다루는 가장 인기있는 방법은 첫번째 인자로 오류를 받는 Node.js스타일입니다.

var fs = require("fs);

fs.readFile("/Does/not/exist", handleFile);

function handleFile(error, file) {
    if(error) return console.error("there was an error", error);
}

첫번째 인자로 error를 받는것은 당신이 에러를 다루어야한다고 계속 상기시켜주는 간단한 관습입니다.
만약 두번째인자로 에러를 다룬다면, 당신은 에러를 다루어야한다는 것을 자주 잊어버리고 말것입니다.

코드 linters 또한 에러를 다루어야한다고 기억해내는데에 도움이 됩니다.

요약!
1.함수를 계속 감싸지 말자!(dont nest functions). 함수에게 이름을 지어주고, 프로그램의 최상단에 위치하게 하자.
2.함수 호이스팅을 써먹자.
3.콜백에서 모든 에러를 다루자.
4. 재사용가능한 함수를 만들고 모듈화시켜서 당신의 코드를 이해하기 쉽게 만들자.

콜백헬에서 벗어나는 가장 중요한 관점은, 새로온 사람도 프로그램의 흐름을 이해하기 쉽도록 코드를 짜는 것입니다.

여러분은 함수를 파일의 bottom으로 옮기는 것으로 시작할 수 있습니다.
그리고 함수를 다른 파일로 옮겨서 모듈화시키는 것입니다.
~~~

