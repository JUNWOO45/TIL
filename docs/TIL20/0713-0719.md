# 0714

# 프론트엔드 성능최적화



> 가장 중요한건, 웹페이지 로딩 최적화, 웹페이지 렌더링 최적화 이 두가지만 얻어가자.



---

## W3C Navigation Timing API - Processing Model

Prompt for unload : "정말 창을 닫으실거에요?"

Redirect : 리다이렉트 시작!

AppCache: "브라우저 캐시 날려주세요"

DNS

TCP

Request 날리고

Response 받고

domContentLoadedEventStart: 모든 dom 요소가 준비되었다.

loadEventStart : 모든 리소스가 준비되었다.

<br>

## 브라우저 렌더링 과정

### 파싱

> 두가지일을 한다.dom 트리구축, cssom 트리 구축

#### 과정

패킷 안에 들어있는 바이트를

브라우저가 문자열로 바꾸고

토큰화 한 뒤,(토크나이징)

토큰화한 정보로 dom node로(노드화), 그리고 부모 자식 관계로..(dom tree)

> Dom, cssom 모두 같은 과정을 거친다.

### 스타일

만든 dom트리와 cssom트리를 합친다.(렌더 트리를 만든다.)

그러나 `display: none` 인 경우에는 렌더트리에 반영이 되지 않을 것이다.

<br>

### 레이아웃

> 가장 중요하다.

**브라우저의 뷰포트 안에** 노드가 가져야 할 정확한 위치와 크기를 계산한다.

"깊이우선 탐색"

> 렌더링 과정 중 레이아웃 과정이 가장 오래걸린다.

실제 픽셀 정보를 박아두게 된다.

짤린 이미지 -> `size = 600px` 처럼 px단위로 정해진다.

레이아웃 전에는 정확한 픽셀을 알 수가 없다.(뷰포트를 모르니깐? 없으니깐!?)

<br>

## 페인트

> 레이아웃에서는 위치를 잡았다면, 여기서는 색상이나 투명도 같은 CSS 속성들이 적용된다.

<br>

## 합성 & 렌더

모든 것이 그려져있고, "모니터에 보여준다." 라고 이해하면 된다.

- CSS Transform
  - 컴포지션 단계에서 일어난다.
    - 응?? 무슨 소리일까?
    - 실제 dom의 위치는 변하지않는다.

> 링크 Falling leaves예시를 보면, 나뭇잎의 dom위치는 그대로이다.
>
> transform으로 애니메이션만 추가된거임 ㅇㅇ



## 성능 측정 도구 익히기

FP: 가장 처음 무엇인가가 그려졌다.

FCP: 컨텐트가 처음 나타났다..?

FMP: 의미있는 컨텐트가 처음 나타났다..?

LCP: 가장 큰 컨텐트가 그려졌다.

DCL: 알지?

L: 알지?



> 꿀팁
>
> body태그를 날려버리고 성능측정을 시작하자.
>
> 그럼 더 이쁘게 볼 수 있다.



## 웹페이지 로딩 최적화

**로딩 속도의 의미는?**

- 서버 응답을 받은 시점?
- 전체 페이지가 로드되는 시점?
- 화면에 무언가 그려지는 시점?

무엇이 중요할까?

> 관점이 다르다.
>
> 다음과 같을수 있겠지..

- 최적화의 기준: 브라우저가 기준이 될 수 있겠고..

  - 리소스 로딩을 확인하자.

- 최적화의 기준: 사용자가 기준이 될 수도 있겠지.

  - 한 번에 빵!하고 보여주지말고, 로드되는 녀석들부터 화면에 보여주자.

    - Progressive Rendering!(요즘 대세다.)

    

- 리소스 최적화

  - 실습2: 개발자 도구 Performace 탭 둘러보기



### 라이트하우스

#### FMP

조금 논쟁이 있는 지표다. 애매해~

"우리는 이미지가 의미있는 지푠데?" "우리는 아닌데?레이아웃인데?"



> 구글의 제안
>
> 현재는 TTI만 쓴다.
>
> "근데 예전에는 CI와 FI로 나누기도 했었다~ 정도의 역사가 있었다고만 알고 있어라."

그래서, Largest Contentful Paint가 도입되었다.

얘는 W3C 스펙이다.



레이지로딩을 하면 fi, ci가 향상된다.

>  레이지로딩? 그게 정말 필요할때 로딩하는 기법.



<br>

## 크리티컬 렌더링 패스

"핵심 렌더링 과정"

크리티컬 렌더링 패스를 최대한 직선으로 뽑아내는게 최적화에서 중요하다.

하지만 그렇다고 css, js를 없앨 순 없어.

그럼 뭘 줄일 수 있을까?

<br>

## CSS 최적화





## 리소스 최적화

> 가장 효과가 좋다!

할 건 2가지 이다.

1. 요청을 줄인다.
2. 리스폰스의 용량을 줄인다.



### 왜 요청을 줄여야할까?

네트워크 요청 자체의 오버헤드가 심하다.

---

## 웹 페이지 로딩 최적화 요약

### 네트워크 리소스 최소화

- 네트워크 요청의 개수를 줄인다 (Javascript 와 CSS 파일을 가능한한 합친다)
- 아이콘이 많은 경우 이미지 스프라이트를 사용한다
- HTML, CSS, Javascript 를 Minified 해서 사용한다

### 크리티컬 렌더링 패스 최적화

- HTML 과 CSS 의 구조를 최대한 단순하게 만든다
- CSS는 HTML 문서의 최상단에 배치한다
- CSS의 `media` 타입을 정확하게 지정한다
- 크리티컬 CSS는 인라인 시킨다
- Javascript 는 HTML 문서의 최하단에 배치한다
- 초기 로딩과 렌더링에 꼭 필요없는 Javascript는 `async`나 `defer` 속성을 사용한다.

---



<br>

# 0716

## UML

### 모델링

- 현실세계의 것을 시각화하려면 다들 각자의 시각으로 구현함.
  기능, 명세, 구조를 명확하게 정의하기위해 사용
- 복잡한 것일 수록 모델링이 더 중요.
- 모델링을 하지 않는다면(요구사항으로부터 코딩을 시작하면)
  - 빠른 것 같지만, 결국엔 느려진다.
  - 아키텍쳐가 잡혀있지 않고,
  - 결국은 실패할 것이다

### MDA(Model Driven Architecture)

이란 것도 있구나.

<br>

### 모델링 원칙

- ㅇㅓ떤 모델을 사용할지, 선택할지가 중요하다.
  - 프로세스 모델, 배포 모델, 디자인 모델... 
- 모든 모델은 현실과 연관되어있다.
  - 현실의 단순화
- 모델 하나로는 모든 것을 해결할 수 없다.

<br>

### 그래서, UML이 뭐야?

#### ... 를 위한 언어

- 시각화
  - 가장 중요한건 시각화를 한다는 것.
- ~~특정화~~(specifying)
  - 명시화
  - The UML builds models that are precise, unambiguous, and complete.
- 구성화(constructuring???)
- 문서화

<br>

### Object

#### Abstraction

우리 시스템에서 관심있는 항목만 뽑아서 추상화

### Encapsulation

"구현을 감춘다."

리모콘이 어떻게 통신하는지는 관심없고, 기대한대로 동작한다에 집중.

얘 덕에 Polymorphism(다형성)이 가능!

#### Modularity

- 복잡한 시스템을 더 작은 모듈로 나눈다.
  - 작게 쪼갠 모듈화가 도움이 된다!

#### Hierarchy

상속받을수록 abstraction이 점점 구체화된다.

<br>

### Representing Objects in the UML

> 클래스가 뭘까? 
>
> "객체를 찍어내기 위한 틀"
>
> 그것도 맞는데,
>
> "오 공통점을 뽑아낼 수 있겠네. -> 이게 클래스."
>
> 클래스는 object들의 공통점을 뽑아내는 것.



고객과 얘기할때.. 아래 모델, 다이어그램등을 사용한다.

### use-case model

사용자(시스템 외부)와 시스템 사이의 상호작용을 보여준다.

### activity diagram

> 기획문서에서 자주 봤던 사용자입자의 흐름 다이어그램이네.

<br>



객체와 클래스로 표현하는 다이어그램

### Sequence Diagram

시간 순서에 초점을 가지고 객체 간 메시지를 표현한다.



### Communication Diagram

 객체 간 메시지를 표현한다는 점은 시퀀스 다이어그램과 똑같다.

관계에 더 초점.

"이런 방식으로 통신하는구나." 의 패턴을 더 잘 볼 수 있다.

---

#### Timing Diagram

> 거의 안써. 정말 복잡한 시스템에서 사용함.

#### Interaction Overview Diagram

> 거의 안써. 정말 복잡한 시스템에서 사용함.

---

<br>

### Class Diagram

