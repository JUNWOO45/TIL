# 0304

innerHTML 속성으로 바인딩 할 경우, 스타일이나 클래스가 사라지는 현상이 생겼다.

버그는 아니라고 한다.

[https://blog.eunsatio.io/develop/Angular-2%2B-innerHTML%EC%97%90%EC%84%9C-%EC%9D%B8%EB%9D%BC%EC%9D%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%9D%B4-%EC%97%86%EC%96%B4%EC%A7%88-%EB%95%8C](https://blog.eunsatio.io/develop/Angular-2%2B-innerHTML에서-인라인-스타일이-없어질-때)



파이프를 만들어서 해결하는 방법이 있다고 하지만, 우리 프로젝트에서는 외부 lib을 가져와서인지, 잘 되질 않았다.

그래서 이 방법으로 수정.

https://stackoverflow.com/questions/50183294/angular-add-style-tag-into-innerhtml



Ref

-  [https://blog.eunsatio.io/develop/Angular-2%2B-innerHTML%EC%97%90%EC%84%9C-%EC%9D%B8%EB%9D%BC%EC%9D%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%9D%B4-%EC%97%86%EC%96%B4%EC%A7%88-%EB%95%8C](https://blog.eunsatio.io/develop/Angular-2%2B-innerHTML에서-인라인-스타일이-없어질-때)
- https://stackoverflow.com/questions/50183294/angular-add-style-tag-into-innerhtml



# 0305

구조분해할당을 자주 안쓰는듯하다.

정말 간만에 사용...

```typescript
const activities = [
  {
    type: 1,
    name: 'junwoo'
	},
  {
    type: 2,
    name: 'yeoul'
	},
  {
    type: 3,
    name: 'gaon'
	},
];

const result = [];

for(let {type} of activities) {
  result.push(type);
}

console.log(result);	//[1, 2, 3]
```

좀 더 좋은 방법을 찾아보면 좋을텐데... 뭐가 있을까?

```typescript
let result = [];

for(let {type} of activities) {
  result = [...result, type];
}

console.log(result);	//[1, 2, 3]
```



# 0306

이터레이터

```typescript
const iterator = (function() {
  let num = 1;
  
  return {
    next: function() {
      return (num > 7 ? {done:true} : {done:false, value: num++});
    }
  }
})();

console.log(iterator.next());	//{done:false, value: 1}
console.log(iterator.next()); //{done:false, value: 2}
```



이터레이터는 배열의 부분집합이라고 할 수 있겠다.

더 작다.

메모리도 덜 차지한다.

```typescript
const array = [1, 2, 3, 4, 5, 6, 7];
```

배열은 1부터 7까지 들어있는 배열을 메모리 위에 올려두었지만, 이터레이터는 그렇지 않다. 숫자 하나만큼만 메모리를 사용.



제너레이터

```typescript
function* getGenerator() {
  for(let i = 1; i <= 7; i++) {
    yield num;
  }
}

const array = [...getGenerator()];	//[1, 2, 3, 4, 5, 6, 7]
```

이터레이터와 이터러블의 조합.

`이터레이터`는 `next` 메소드를 사용해서 다음 아이템을 가져온다.

결과값은 `value`와 `done` 을 가진다. 

`이터러블 프로토콜` 을 구현하면, `for...of` 를 통해 이터레이터의 값을 가져올 수 있고, 구조분해할당을 통해 아이템을 가져올 수 도 있다.

```typescript
for(const value of getIterator()) {
  ..//do something
}
```

```typescript
const array = [...getIterator()];
```



