# 0406

### DOCTYPE

- HTML Tag는 아닙니다.
- 현재 페이지의 HTML의 버젼이 몇인지 웹 브라우저에게 알려주는 역할을 합니다.



### 자바스크립트 데이터타입

- 7개의 자료형을 정의합니다.
  - 기본 자료형 Primitive
    - Number
    - String
    - Boolean
    - Null
    - Undefined
    - Symbol
  - Object
- Object를 제외한 모든 값들은 Immutable Value 변경 불가능한 값입니다.



### 원시형과 참조형

```
let myNumber = 23;
```

1. 변수의 고유 식별자(myNumber)를 생성합니다.
2. 메모리에 주소를 할당합니다.
3. 생성된 주소에 값을 저장합니다.(23)

```
let newVar = myNumber;
```

`newVar` 도 23을 값으로 가지고 있는 메모리주소입니다.

즉 "newVar도 23 입니다."

```
myNumber = myNumber + 1;
```

`myNumber` 는 24입니다.

newVar도 같은 메모리 주소를 가리키기 때문에 24를 가질까?

ㄴㄴ!

`myNumber + 1` 의 연산결과가 24로 확인되면, 자바스크립트는 메모리에 새로운 주소를 할당합니다.

> 자바스크립트의 원시타입 데이터는 변경불가능 immutable 하기때문입니다.

```
let myString = 'abc';

myString = myString + 'd';
```

이미 메모리에 존재하는 `abc` 에 문자열 `d` 를 추가한 것이라고 생각할 수 있지만, 그렇지 않습니다.

`abc` 와 `d` 가 연결될 때, 메모리에 새로운 주소가 할당되고, 그 메모리 주소에 `abcf` 가 저장되고, myString은 그 메모리 주소를 가리키게 됩니다.



참조타입은 좀 다릅니다.

```
let myArr = [];
```

1. 변수의 고유 식별자를 생성합니다.
2. 콜스택의 메모리에 주소를 할당합니다.
3. 힙에 할당된 메모리 주소를 콜스택의 value로 저장합니다.
4. 힙의 메모리 주소에 할당된 값에 빈 배열을 저장합니다.



> let 은 메모리 주소의 변경을 허락하고,
>
> const는 메모리 주소의 변경을 허락하지 않습니다.

```
const myId = 123;

myId = 456;
```

`myId` 가 선언되면, 메모리 주소가 할당되고 123이라는 값이 저장됩니다.

456이라는 값이 `myId` 에 할당되면, 456은 원시타입이기때문에 새로운 메모리 주소가 할당되고, 456이라는 값이 그 메모리 주소에 저장됩니다.



```
const myA = [];
```

`myA` 가 선언되면, 콜스택에 메모리 주소가 할당됩니다.

그리고 메모리 주소의 값으로 힙에 할당된 메모리 주소가 들어옵니다.



### 호이스팅

#### 변수선언단계

- 선언단계
  - 변수 객체(Variable Object)에 변수를 등록합니다.
- 초기화단계
  - 변수 객체에 등록된 변수를 메모리에 할당합니다.
  - 이 과정에서 변수는 undefined로 초기화됩니다.
- 할당단계
  - undefined로 초기화된 변수에 값을 할당합니다.

---

호이스팅은 실제로 코드가 끌어올려지는 것이 아니고, 자바스크립트 파서가 내부적으로 끌어올리는 것입니다.

실제 메모리에서의 변화는 없습니다.

호이스팅은 모든 선언문에서 발생합니다.

var, let, const, function, class...

#### TDZ

```
console.log(a);
var a = 'abc';	//undefined
```

```
console.log(b);
const b = 'b';
// ReferenceError: Cannot access 'b' before initialization.
```

`var` 는 선언과 초기화가 동시에 일어납니다. 그래서 undefined가 출력됩니다.

`const` 는 선언만 이루어졌기 때문에, 초기화 전에는 접근할 수 없다는 레퍼런스에러가 발생합니다.

참고.

- `var` 는 함수레벨 스코프
- `let / const` 는 블록레벨 스코프



### 클로져

함수는 함수가 만들어질때, 바깥쪽의 변수들을 캡쳐한 뒤 마치 지역변수처럼 사용할 수 있습니다.

하지만 함수 입장에선, 이 변수들은 사실 지역변수도 아니고 인자도 아닙니다.

이러한 변수들을 `자유변수` 라고 부릅니다.

그리고 이러한 `자유변수` 들이 캡쳐되어서 사용되어지는 공간을 클로져라고 합니다.

즉, 자바스크립트 함수는 클로져이다. 라고도 할 수 있습니다.



### Event delegation

- Bubbling
- Capturing
- event.stopPropagation();
- event.preventDefault();
- 단점
  - document에서 delegation을 이용해서 처리를 한다고 하면, 앱 퍼포먼스에서 굉장히 좋지않은 결과를 가져올 것 같다.



### 프로미스?

- 자바스크립트 비동기 처리에 사용되는 객체이다.
- 프로미스의 3가지 상태
  - pending: 비동기처리로직이 아직 완료되지 않은 상태
  - fulfilled: 비동기 처리가 완료되어, 프로미스가 결과값을 리턴해준 상태
  - rejected: 비동기 처리가 실패하거나 오류가 발생한 상태

- 에러 처리 방법

  - then의 두번째 인자로 에러를 처리하는 방법

    ```
    getData().then(
    	handleSuccess,
    	handleError
    )
    ```

  - catch로 처리하는 방법

    ```
    getData().then().catch()
    ```




# 0408

---

# 채팅

- 채팅 일자단위로 컴포넌트로 만들자.
- TTL? time to leave?
  - 생존기간.
  - firestore에도 기능이 잇는지 확인해보자.

---



GCP cron기능을 이용한 작업을 몇 번 해서 어떤 동작을 원할때 크론을 사용하는지 감을 잡았다.

메시지를 처리하는데 Tasks 라는 기능도 사용하고 있다.

둘의 차이점을 제공해주는 페이지이다.

https://cloud.google.com/tasks/docs/comp-tasks-sched

우선 도드라지게 이해할 수 있는 부분은, Handling failure 부분이다.

크론은 작업이 실패하면 로그를 쌓을 뿐, 재실행하지는 않는다.(interval이 설정되어있다면, 실행한다.)

태스크는 작업이 성공할때까지 재실행한다. 재실행 횟수를 지정할 수 있나보다.



