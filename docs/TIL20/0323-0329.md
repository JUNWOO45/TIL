# 0323

쿠폰 생성 프로시져 삽질의 결과

### v1

```
DELIMITER ;;
CREATE DEFINER=`----`@`----` PROCEDURE `makeCouponsV1`()
BEGIN
DECLARE i INT DEFAULT 1; 
WHILE (i <= 1000) DO
    INSERT
INTO coupon(sid, group_sid, name, description, mode, discount_type, status, discount_amount, max_issued, regularity, specialties, start_datetime, end_datetime, terms, code)
VALUES(UUID(), '--삭제--', '고객 특별 쿠폰', '모바일 티켓용 쿠폰 코드입니다.', 2, 1, 2, 10000, 1, 3, '1|2|3|4|5|6', '2019.11.29', '2020-02-29 23:59:59', '하이요.', concat(char(round(rand()*25)+65),char(round(rand()*25)+65),char(round(rand()*25)+65),char(round(rand()*25)+65),char(round(rand()*25)+65),char(round(rand()*25)+65)));
    SET i = i+1;
END WHILE;
END;;
DELIMITER ;
```

후기 : 문자열도 섞어서 뭔가 더 다양한 경우의 수를 만들어내고 싶다.



### v2

```
DELIMITER ;;
CREATE DEFINER=`----`@`----` PROCEDURE `makeCouponsV2`()
BEGIN
DECLARE i INT DEFAULT 1; 
WHILE (i <= 1000) DO
		SET @UUID = UUID();
    INSERT
INTO coupon(sid, group_sid, name, description, mode, discount_type, status, discount_amount, max_issued, regularity, specialties, start_datetime, end_datetime, terms, code)
VALUES(@UUID, @UUID, '고객 특별 쿠폰', '모바일 티켓용 쿠폰 코드입니다.', 2, 1, 2, 10000, 1, 3, '1|2|3|4|5|6', '2019.11.29', '2020-02-29 23:59:59', '하이요.',  concat(UCASE(LEFT(MD5(RAND()), 6)),UCASE(LEFT(MD5(RAND()), 6)),UCASE(LEFT(MD5(RAND()), 6)),UCASE(LEFT(MD5(RAND()), 6)),UCASE(LEFT(MD5(RAND()), 6)),UCASE(LEFT(MD5(RAND()), 6))));
    SET i = i+1;
END WHILE;
END;;
DELIMITER
;
```

- 변수를 사용해보았다. 엄청 편리하네;
- 후기 : 헷갈릴 수 있는 I, O, 1, 0 이 섞여있다.





### v3

```
DELIMITER ;;
CREATE DEFINER=`----`@`----` PROCEDURE `makeCouponsV2`()
BEGIN
DECLARE i INT DEFAULT 1; 
WHILE (i <= 1000) DO
		SET @UUID = UUID();
    SET @allowedChars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    INSERT
INTO coupon(sid, group_sid, name, description, mode, discount_type, status, discount_amount, max_issued, regularity, specialties, start_datetime, end_datetime, terms, code)
VALUES(@UUID, @UUID, '고객 특별 쿠폰', '모바일 티켓용 쿠폰 코드입니다.', 2, 1, 2, 10000, 1, 3, '1|2|3|4|5|6', '2019.11.29', '2020-02-29 23:59:59', '하이요.',  concat(substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1),substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1),substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1),substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1),substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1),substring(@allowedChars, FLOOR(RAND() * LENGTH(@allowedChars) + 1), 1)));
    SET i = i+1;
END WHILE;
END;;
DELIMITER
;
```

- 사용할 문자열을 만들고 랜덤으로 뽑아내어서 CONCAT했다.
- 괜찮은 것 같다.
- 기존 코드와 중복이 있는지 검사 후, 있으면 새로 문자열을 생성하도록 로직을 수정해봐야겠다.

---

## Iterator Interface

Iterator는 자바스크립트 엔진에 정의된 인터페이스다.

- next라는 키를 가진다.
- 값으로 인자를 받지않고, IteratorResultObject를 반환하는 함수가 온다.
  - IteratorResultObject 또한 인터페이스다.
- IteratorResultObject는 value와 done이라는 키를 가지고 있다.
- done은 계속 반복할 수 있을지 없을지에 따라 Boolean을 반환한다.

> 이 조건을 만족해야, 이터레이터 객체라고 할 수 있다.

```
{
	next() {
		return {
			value: 1,
			done: false
		};
	}
}
```

조금 더 와닿는 느낌의 예제.

```
const test = {
    data: [1,2,3,4,5],
    next() {
        return {
            done: this.data.length === 0,
            value: this.data.pop()
        };
    }
}

test.next();	//{done: false, value: 5}
test.next();	//{done: false, value: 4}
test.next();	//{done: false, value: 3}
test.next();	//{done: false, value: 2}
test.next();	//{done: false, value: 1}
test.next();	//{done: true, value: undefined}
```



---

## Iterable Interface

- Symbol.iterator라는 키를 갖는다.
  - "심볼 이터레이터라는 메소드를 가진다."
  - 참고로, `Symbol` 은 ES6에서 새롭게 생성된 데이터타입이다.
  - Primitive Type이다.. 값으로 인식된다. 객체가 아닌.
- 값으로 인자를 받지 않고 Iterator Object를 반환하는 함수가 온다.
  - 위에서 본 이터레이터 객체를 반환해야한다는 뜻
  - "즉, 이터러블 객체는 이터레이터 객체를 반환한다."

<br>

이터러블 객체는 다음과 같다고 볼 수 있다.

```
{
	[Symbol.iterator]() {
		return {
			next() {
				return {
					done: false,
					value: 1
				}
			}
		}
	}
}
```



---

### 이터레이터와 이터러블이 구분되어 있는 이유.

- 원본에서 사본을 복사해낼 타이밍을 가지게 된다.

---

Iterator 반복처리기 구현

```typescript
const loop = (iter, f) => {
	// 이터러블 검증
  if(typeof iter[Symbol.iterator] === 'function') {
    iter = iter[Symbol.iterator]();
  } else {
    return;
  }
  
  // 이터레이터 검증
  if(typeof iter.next !== 'function') {
    return;
  }
  
  do {
    const v = iter.next();
    if(v.done) {
      return;	//종료
    } 
    f(v.value);	//값을 전달
  }while(true);
};
```

이제 do-while문은 단순히 반복을 반복하는(..) 반복기의 역할에 불과하다.

상태관리나 반복을 종료하는건 이터레이터가 담당.

```typescript
const iter = {
    arr: [1,2,3,4,5],
    [Symbol.iterator]() {
        return this;
    },
    next() {
        return {
            done: this.arr.length === 0,
            value: this.arr.pop()
        };
    }
}

loop(iter, console.log);
//5
//4
//3
//2
//1
```

---

## Array Destructuring

> 이터러블 프로토콜을 준수하고있기 때문에, "언어의 지원을 받는다."

```typescript
const iter = {
  	[Symbol.iterator]() {
      return this;
    },
  arr: [1,2,3,4,5],
  next() {
    return {
      done: this.arr.length === 0,
      value: this.arr.pop()
    }
  }
};

const [a, ...b] = iter;
console.log(a, b);	//5, [4, 3, 2, 1]
```



