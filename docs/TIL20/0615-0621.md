# 0615

# FE교육 - 자바스크립트 7장 함수표현식

## 함수를 정의하는 방법

1. 함수 선언

```javascript
function sayHi(name) {
	...
}
```

함수 선언의 큰 특징은 **호이스팅**

<br>

2. 함수 표현식

```javascript
var sayHi = function(name) {
  ...
};
```

function 키워드 다음에 함수 이름이 없어 익명함수로 간주합니다. 익명함수를 종종 람다 함수라고 부르기도 합니다.

<br>

## 재귀

함수가 자기 자신을 이름으로 호출하는 형태입니다.

```javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  }
  
  return num * factorial(num - 1);
}
```

그런데 다음과 같은 경우에는 동작하지 않습니다.

```javascript
var test = factorial;
factorial = null;
test(5);	//Uncaught TypeError: factorial is not a function
```

재귀함수에서 더이상 함수가아닌 (null) `factorial(num - 1)` 을 실행하려하기 때문입니다.

그래서 `arguments.callee` 쓰는 것을 권장합니다.

```javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  }
  
  return num * arguments.callee(num - 1);
}
```

`arguments.callee` 는 현재 실행중인 함수를 가리키는 포인터 입니다.

근데 스트릭트 모드에서는 동작안함.

<br>

## 클로저

외부 함수가 실행을 마쳐서 활성화 객체가 파괴되었음에도 내부함수에서는 아직 이름 참조할 수 있음.

하지만 다른 함수에 비해 메모리를 많이 요구합니다.

클로저는 특정 변수가 아니라, 전체 변수 객체에 대한 참조를 저장합니다.

```javascript
for(var i = 0; i < num; i++) {
  setTimeout(function(i) {
    console.log(i);
  }, 100)
}  
```

많이 보던 예시

```javascript
for(var i = 0; i < 10; i++) {
    (function(j){
        setTimeout(function() {
          console.log(j);
        }, 100)
    })(i)
} 
```



<br>

## 모듈 패턴

싱글톤에서 고유변수와 특권 메소드를 만들어 사용.

-> 객체 리터럴이 싱글톤에 대한 공용 인터페이스 정의

```javascript
const singleton = function() {
  let num = 10;
  
  return {
    increase: function() {
      num++;
    },
    getNum: function() {
      return num;
    }
  }
};


var a = singleton();

a.increase();
a.getNum();	//11
```

<br>

# 0616

## 안전한 타입 탐지

`typeof` 나 `instanceof` 대신 `Object.prototype.toString()` 을 이용한 테크닉을 보여준다.

```javascript
function isArray(value) {
  return Object.prototype.toString.call(value) === '[Object Array]'
}
```



<br>

## 스코프 확인 생성자

new 연산자 없이 생성자를 호출하는 실수를 막는 테크닉이다.

```javascript
function Person(name, age) {
  if(this instanceof Person) {
    this.name = name;
    this.age = age;
  } else {
    return new Person(name, age);
  }
}
```

그러나 상속이 깨지는 문제가 발생할 수 있는데,

```javascript
function Cars(wheels) {
  if(this instanceof Cars) {
    this.wheels = wheels;
  } else {
    return new Cars(wheels);
  }
}

function SUV(engine) {
  Cars.call(this, 4);
  this.engine = engine;
}

const myCar = new SUV('diesel');
console.log(myCar.engine);	//'diesel'
console.log(myCar.wheels);	// undefined
```

프로토타입 체인을 연결해주어야한다.

```javascript
function Cars(wheels) {
  if(this instanceof Cars) {
    this.wheels = wheels;
  } else {
    return new Cars(wheels);
  }
}

function SUV(engine) {
  Cars.call(this, 4);
  this.engine = engine;
}

SUV.prototype = new Cars();

const myCar = new SUV('diesel');
console.log(myCar.engine);	//'diesel'
console.log(myCar.wheels);	// 4
```

<br>

## 지연로딩함수

처음보는 패턴인데, 이렇게 사용할 수 도 있구나 싶었습니다.

```javascript
const STATUS = {
	PENDING: 0,
  ACTIVE: 1,
	SUSPENDED: 2,
  WITHDRAWN: 3
};

let customerStatus; // 0, 1, 2, 3.....

function checkCustomerStatus(customerStatus) {
  if(customerStatus === STATUS.PENDING) {
    return something();
  } else if(customerStatus === STATUS.ACTIVE) {
    return anotherSomething();
	} else if(customerStatus === STATUS.SUSPENDED) {
    return otherThing();
  } else if(customerStatus === STATUS.WITHDRAWN) {
    return sayGoodbye();
  }
}
```

if문이 있는것 보다, 없는 것이 더 빠르므로 '지연 로딩' 이라는 테크닉을 사용할 수 있습니다.

두가지 방법이 있는데, 첫째는 ..

함수를 처음 호출할 때, 자기 자신을 수정하도록 하는 방법입니다.

```javascript
function checkCustomerStatus(customerStatus) {
	if(customerStatus === STATUS.PENDING) {
    checkCustomerStatus = function () {
      return something();
    }
  } else if(customerStatus === STATUS.ACTIVE) {
    checkCustomerStatus = function () {
      return anotherSomething();
    }
	} else if(customerStatus === STATUS.SUSPENDED) {
    checkCustomerStatus = function () {
      return otherThing();
    }
  } else if(customerStatus === STATUS.WITHDRAWN) {
    checkCustomerStatus = function () {
      return sayGoodbye();
    }
  }
  
  return checkCustomerStatus();
}
```

두번째 방법은, 함수를 선언하는 즉시 다른 함수를 할당하는 방법입니다.

즉시실행함수를 활용합니다.

```javascript
const checkCustomerStatus = (function(customerStatus) {
  if(customerStatus === STATUS.PENDING) {
    return function () {
      return something();
    }
  } else if(customerStatus === STATUS.ACTIVE) {
    return function () {
      return anotherSomething();
    }
	} else if(customerStatus === STATUS.SUSPENDED) {
    return function () {
      return otherThing();
    }
  } else if(customerStatus === STATUS.WITHDRAWN) {
    return function () {
      return sayGoodbye();
    }
  }
})();
```





