# 0615

# FE교육 - 자바스크립트 7장 함수표현식

## 함수를 정의하는 방법

1. 함수 선언

```javascript
function sayHi(name) {
	...
}
```

함수 선언의 큰 특징은 **호이스팅**

<br>

2. 함수 표현식

```javascript
var sayHi = function(name) {
  ...
};
```

function 키워드 다음에 함수 이름이 없어 익명함수로 간주합니다. 익명함수를 종종 람다 함수라고 부르기도 합니다.

<br>

## 재귀

함수가 자기 자신을 이름으로 호출하는 형태입니다.

```javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  }
  
  return num * factorial(num - 1);
}
```

그런데 다음과 같은 경우에는 동작하지 않습니다.

```javascript
var test = factorial;
factorial = null;
test(5);	//Uncaught TypeError: factorial is not a function
```

재귀함수에서 더이상 함수가아닌 (null) `factorial(num - 1)` 을 실행하려하기 때문입니다.

그래서 `arguments.callee` 쓰는 것을 권장합니다.

```javascript
function factorial(num) {
  if(num <= 1) {
    return 1;
  }
  
  return num * arguments.callee(num - 1);
}
```

`arguments.callee` 는 현재 실행중인 함수를 가리키는 포인터 입니다.

근데 스트릭트 모드에서는 동작안함.

<br>

## 클로저

외부 함수가 실행을 마쳐서 활성화 객체가 파괴되었음에도 내부함수에서는 아직 이름 참조할 수 있음.

하지만 다른 함수에 비해 메모리를 많이 요구합니다.

클로저는 특정 변수가 아니라, 전체 변수 객체에 대한 참조를 저장합니다.

```javascript
for(var i = 0; i < num; i++) {
  setTimeout(function(i) {
    console.log(i);
  }, 100)
}  
```

많이 보던 예시

```javascript
for(var i = 0; i < 10; i++) {
    (function(j){
        setTimeout(function() {
          console.log(j);
        }, 100)
    })(i)
} 
```



<br>

## 모듈 패턴

싱글톤에서 고유변수와 특권 메소드를 만들어 사용.

-> 객체 리터럴이 싱글톤에 대한 공용 인터페이스 정의

```javascript
const singleton = function() {
  let num = 10;
  
  return {
    increase: function() {
      num++;
    },
    getNum: function() {
      return num;
    }
  }
};


var a = singleton();

a.increase();
a.getNum();	//11
```





