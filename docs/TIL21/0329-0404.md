# 0330

사용하고 있는 에디터, tui editor에서는 이미지를 업로드하면 base64로 변환한다.

편할 수 있지만 퍼포먼스적인 문제가 있을 수 있다.

https://okky.kr/article/589839?note=1714876

커스텀하게 바꿀 수 있다.

https://solve-programming.tistory.com/29



# 0401

# Shadow DOM

![shadow dom](../pic/shadow-dom1.png)

Shadow DOM에는 4가지 개념이 중요한듯하다.

- Shadow host: Shadow DOM이 붙게되는 일반적인 DOM 노드.
- Shadow tree: Shadow DOM 내부의 DOM 트리
- Shadow boundary: 일반적인 DOM과 shadow DOM의 경계.
- Shadow root: Shadow tree의 루트 노드.

Shadow가 아닌 노드와 같은 방식으로 Shadow DOM의 노드를 변경할 수 있다.

예를 들어 자식을 추가하거나 속성을 설정하고 `element.style.foo` 를 사용하여 개별 노드에 스타일을 지정하거나, `<style>` 엘리먼트 안에 스타일을 추가하여 전체 Shadow DOM tree를 변경할 수 있다.

차이점은, Shadow DOM 내부의 코드는 외부에 영향을 줄 수 없기때문에 손쉬운 캡슐화가 가능하다는 점이다.

Shadow DOM은 결코 새로운 것이 아니다. 브라우저는 오랫동안 Shadow DOM을 사용하여 엘리먼트의 내부 구조를 캡슐화해 왔습니다.

기본 브라우저 컨트롤 기능이 노출된 `<vidoe>` 엘리먼트를 생각해봅시다.

DOM에서 볼 수 있는 건 오직 `<video>` 엘리먼트 뿐이지만, `<video>` 엘리먼트의 Shadow DOM 내부에는 여러 버튼들과 여러 컨트롤들이 포함되어 있습니다.



### 기본 사용법

`Eloement.attachShadow()` 를 사용하여 모든 엘리먼트에 shadow root를 연결시킬 수 있다.

`mode` 값을 `open` 이나 `close` 로 설정하는 옵션 객체를 파라미터로 넘길 수 있다.

```javascript
const shadow1 = elementRef.attachShadow({mode: 'open'});
const shadow2 = elementRef.attachShadow({mode: 'close'});
```

`open`  은 메인 컨텍스트에서 작성된 자바스크립트를 사용하여 shadow DOM에 접근할 수 있습니다.

```javascript
const shadowDom = customElement.shadowRoot;
```

`mode: closed` 로 설정하면 외부에서 shadow DOM을 접근할 수 없습니다.

customElement.shadowRoot는 null을 리턴할 것입니다.



참고: https://developer.mozilla.org/ko/docs/Web/Web_Components/Using_shadow_DOM