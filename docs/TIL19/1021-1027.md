



# 1021

7000분 정도의 DB테이블 마이그레이션 작업을 했다.

ㄷㄷ..... 무쟈게 긴장됐ㄷㅏ;

이런 작업을 할 때마다 안전하게, 복구할 수 있는 방법으로 진행해야할듯.

1. 로컬에서 테스트
   1. 로컬도 마이그레이션 진행하는 테이블을 CSV파일 export해놓고 작업.
   2. 전후를 확인해볼 수 있게 account_sid를 몇 개 적어두고 마이그레이션 이후 잘 바뀌었는지 DB상으로 확인
   3. 관리자콘솔에서도 바뀌었는지 전후 비교
2. 라이브
   1. 라이브도 CSV파일 export해서 혹시모를 사태 대비
   2. 전후를 확인해볼 수 있게 account_sid를 몇 개 적어두고 마이그레이션 이후 잘 바뀌었는지 DB상으로 확인
   3. 관리자콘솔에서도 바뀌었는지 전후 비교



---

리얼 리눅스

## 적당한 커밋의 사이즈?

- 기능 한 개?
- 메인테이너마다 달라?
- 단위테스트를 할 수 있는 크기?
- Function?

"기준 중 하나일테지만, review나 discussion이 가능한 양이 적당하다고 생각"



---

## 1.버그를 수정했을때 commit message어떻게 작성할 것인가?

(예시, B라는 문제가 발생했는데 , if문에 A라는 조건이 없어서였다.)

미천한 내 예시 : Fix B that caused by no condition A in conditional statement.

> fs/ext4: Fix the B problem
>
> When ~~~~, the B error can occur.
>
> the reason is that ~~~~.

```
fx/ext4 : prefix적어주는거. 어느 파트 인지.

Why: 70~80% 정도. How: 20~30% 정도.
커밋에있는 코드 수정분만 봐도 '어떻게'는 알 수 있음.
```



## 링크 134페이지는 왜 발생할까?

왜?

베이스가 달라서.



---

# 1022



# git rebase



[fork한 저장소를 최신 원본과 동기화 시키기](https://junwoo45.github.io/2019-09-01-git_upstream/) 라는 포스팅을 작성한 적이 있습니다.

 `git merge` 를 사용해서 `upstream` 에서 받아온 `master`를 내 로컬의 `master` 에 합치고 나의 `origin repository` 에 `git push` 하는 방법으로 내 저장소를 최신화시키는 방법을 정리한 글입니다.

이번에 리베이스를 공부하면서 이 리베이스가 더 이러한 상황을 위해 태어난 녀석같다는 생각이 들어서 새로 정리를 해보려고 합니다.



이론적인 얘기는 지루합니다.

바로 사용해보도록 하겠습니다.

마찬가지로, 포크한 저장소를 최신 원본과 동기화시키는 상황을 진행할건데요.

4번 까지는 `merge` 를 사용한 방법과 다를 것이 없습니다.

---

1.우선 현재 저장소의 원격 주소를 확인합니다.

```
$ git remote -v

origin  https://github.com/USERNAME/FORK_REPO.git (fetch)
origin  https://github.com/USERNAME/FORK_REPO.git (push)
```

![rebase ex1](../pic/rebase2.png)



2.원본 저장소의 원격 주소를 추가합니다.

```
$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git
```

![rebase ex2](../pic/rebase3.png)



3.원본 저장소의 원격 주소가 잘 추가되었는지 확인합니다.

```
$ git remote -v

origin  https://github.com/USERNAME/FORK_REPO.git (fetch)
origin  https://github.com/USERNAME/FORK_REPO.git (push)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (fetch)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (push)
```

![rebase ex3](../pic/rebase4.png)



4.원본을 fetch합니다.

```
$ git fetch upstream master

remote: Enumerating objects: 253, done.
remote: Counting objects: 100% (253/253), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 479 (delta 249), reused 252 (delta 249), pack-reused 226
오브젝트를 받는 중: 100% (479/479), 259.99 KiB | 463.00 KiB/s, 완료.
델타를 알아내는 중: 100% (296/296), 로컬 오브젝트 9개 마침.
https://github.com/sarojaba/awesome-devblog URL에서
 * branch            master     -> FETCH_HEAD
 * [새로운 브랜치]   master     -> upstream/master
```

![rebase ex4](../pic/rebase5.png)



> 여기까지는 `merge` 를 사용할때와 방법이 똑같습니다.

<br>

5.`rebase` 로 base를 교체하기.

```
$ git rebase upstream/master

First, rewinding head to replay your work on top of it...
Fast-forwarded master to upstream/master.
```

![rebase ex5](../pic/rebase6.png)



6.나의 원격저장소에 push합니다.

```
$ git push origin master

Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/USERNAME/FORK_REPO.git
   83e93ee..f393fa9  master -> master
```

![rebase ex6](../pic/rebase7.png)



---



## rebase -interactive

`rebase` 에는 interactive라는 옵션이 있는데, 이 옵션이 `rebase` 를 이해하는데 많은 도움이 되었습니다.



![rebase9](../pic/rebase9.png)

commit을 4개 준비했습니다.

저는 `commit 2` 의 커밋메세지가 마음에 들지않아 메세지를 수정하고 싶습니다.

![rebase10](../pic/rebase10.png)

하지만 이미 `push` 를 해서 저의 원격저장소에도 올라가있는 상황입니다.



이러한 상황에서 `git rebase -i` 를 사용하면 쉽게 중간에 낀 커밋메세지를 수정할 수 있습니다.

저는 시간을 시간을 되돌리고 싶습니다.

`commit 2` 의 시점으로 되돌아가 메세지를 수정하고 싶습니다.

1.`git rebase -i` 명령어를 사용하여 되돌아갈 시점을 선택할 수 있습니다.

```
$ git rebase -i --root
```

![rebase11](../pic/rebase11.png)



2.자동으로 vi 에디터가 열립니다. 수정하려는 커밋 앞에 `pick` 대신 `edit` 을 적어주고 저장해줍니다.

![rebase12](../pic/rebase12.png)



3.에디터가 종료되면 `git log` 메세지로 현재 상태를 확인해줍니다.

분명 `commit 4` 까지 존재했었지만, 지금은 `commit 2` 가 최신 커밋인 상태입니다.

저는 `commit 2` 가 막 작성된 상태로 시간여행을 온 상태입니다.

![rebase13](../pic/rebase13.png)



4.커밋메세지를 수정해줍니다.

`git commit --amend` 옵션은 커밋 메세지를 수정할 때 사용됩니다.

```
$ git commit --amend -m "커밋메세지가 이렇게 바뀌면 좋겠다!"
```

![rebase14](../pic/rebase14.png)



5.`git log` 로 커밋 메세지가 잘 바뀌었는지 확인해봅니다.

```
$ git log
```

![rebase15](../pic/rebase15.png)

잘 바뀌었습니다.



6.`git rebase --continue` 명령어를 입력해 다시 되돌렸던 시간을 복구해줍니다.

```
$ git rebase --continue
```

![rebase20](../pic/rebase20.png)

`git rebase -i` 를 했다면, `git rebase --continue` 도 항상 따라와야합니다.

시간을 되돌리고, 다시 풀어주고.



7.`git log` 명령어로 현재 상태를 확인해봅니다.

```
$ git log
```

![rebase16](../pic/rebase16.png)

제가 원하던 상태가 되었습니다!

`commit 2` 라고 적혀있던 커밋메세지가 `Rebase -interactive` 라고 잘 바뀌어 있습니다.



8.이제 저의 원격저장소에 `push` 합니다.

```
$ git push origin master
```

![rebase17](../pic/rebase17.png)



하지만, 실패합니다.

저는 이 문제를 자주 접했는데요.

저는 이 문제를 자주 접하는데요.

[git pull 이후 non-fast-forward문제](https://junwoo45til.netlify.com/#/git/git_pull_non-fast-forward) 로 정리했던 저의 troubleshooting페이지도 있습니다.

이 문제에 대한 설명은 잠시 미뤄두겠습니다.



9.강제로 밀어넣기!

```
$ git push origin master -f
```

![rebase18](../pic/rebase18.png)

<center><small>신에게는 아직  `-force`라는 배 한척이 남아있습니다..</small></center>



10.원격저장소 확인

![rebase19](../pic/rebase19.png)

잘 저장이 되었네요!





---

## 궁금증



![rebase8](../pic/rebase8.jpg)

<center>
  <small>
  	그런데 말입니다..
  </small>
</center>

<br>

왜 이름이 `rebase` 일까요? ~~그런게 왜 궁금해..~~

저는 지금까지 `rebase` 가 헷갈리고, 낯설고, 별로 친해지고 싶지 않았었는데요.

바로 이름때문이었습니다.

![rebase21](../pic/rebase22.jpg)



'시간을 되돌리는거면 `rewind` 라는 이름이 더 직관적이지 않나? 왜이렇게 만든거야?'

`git rewind` .. 누가봐도 시간을 되돌려서 작업을 하는 그런 멋진 명령어입니다.

비슷한 녀석이 또 있는데요.

처음엔 `Pull Request` 라는 이름은 정말 헷갈렸습니다.

`당김을 요청?`, `가져가주세요` 의 의미인데.. 음... 

PR을 하는 저의 입장이 아닌 메인테이너, upstream의 입장에서의 의미라 너무 와닿지가 않았습니다.

하다못해 `Send a Request` 정도의 단어였다면 ..

어쨋든.. `Pull Request` 는 그렇다쳐도 이 `rebase` 라는 이름의 의미를 알고나면 뭐라그럴까..

정답을 찾아헤매던 마법사가 진실을 마주했을 때의 그것과 비슷한 느낌을 받을 수 있습니다.



---

## rebase

