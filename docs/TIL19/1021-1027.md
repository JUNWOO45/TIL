



# 1021

7000분 정도의 DB테이블 마이그레이션 작업을 했다.

ㄷㄷ..... 무쟈게 긴장됐ㄷㅏ;

이런 작업을 할 때마다 안전하게, 복구할 수 있는 방법으로 진행해야할듯.

1. 로컬에서 테스트
   1. 로컬도 마이그레이션 진행하는 테이블을 CSV파일 export해놓고 작업.
   2. 전후를 확인해볼 수 있게 account_sid를 몇 개 적어두고 마이그레이션 이후 잘 바뀌었는지 DB상으로 확인
   3. 관리자콘솔에서도 바뀌었는지 전후 비교
2. 라이브
   1. 라이브도 CSV파일 export해서 혹시모를 사태 대비
   2. 전후를 확인해볼 수 있게 account_sid를 몇 개 적어두고 마이그레이션 이후 잘 바뀌었는지 DB상으로 확인
   3. 관리자콘솔에서도 바뀌었는지 전후 비교



---

리얼 리눅스

## 적당한 커밋의 사이즈?

- 기능 한 개?
- 메인테이너마다 달라?
- 단위테스트를 할 수 있는 크기?
- Function?

"기준 중 하나일테지만, review나 discussion이 가능한 양이 적당하다고 생각"



---

## 1.버그를 수정했을때 commit message어떻게 작성할 것인가?

(예시, B라는 문제가 발생했는데 , if문에 A라는 조건이 없어서였다.)

미천한 내 예시 : Fix B that caused by no condition A in conditional statement.

> fs/ext4: Fix the B problem
>
> When ~~~~, the B error can occur.
>
> the reason is that ~~~~.

```
fx/ext4 : prefix적어주는거. 어느 파트 인지.

Why: 70~80% 정도. How: 20~30% 정도.
커밋에있는 코드 수정분만 봐도 '어떻게'는 알 수 있음.
```



## 링크 134페이지는 왜 발생할까?

왜?

베이스가 달라서.



---

# 1022



git rebase



[fork한 저장소를 최신 원본과 동기화 시키기](https://junwoo45.github.io/2019-09-01-git_upstream/) 라는 포스팅을 작성한 적이 있습니다.

 `git merge` 를 사용해서 `upstream` 에서 받아온 `master`를 내 로컬의 `master` 에 합치고 나의 `origin repository` 에 `git push` 하는 방법으로 내 저장소를 최신화시키는 방법을 정리한 글입니다.

이번에 리베이스를 공부하면서 이 리베이스가 더 이러한 상황을 위해 태어난 녀석같다는 생각이 들어서 새로 정리를 해보려고 합니다.



이론적인 얘기는 지루합니다.

바로 사용해보도록 하겠습니다.

마찬가지로, 포크한 저장소를 최신 원본과 동기화시키는 상황을 진행할건데요.

4번 까지는 `merge` 를 사용한 방법과 다를 것이 없습니다.

---

1.우선 현재 저장소의 원격 주소를 확인합니다.

```
$ git remote -v

origin  https://github.com/USERNAME/FORK_REPO.git (fetch)
origin  https://github.com/USERNAME/FORK_REPO.git (push)
```

![rebase ex1](../pic/rebase2.png)



2.원본 저장소의 원격 주소를 추가합니다.

```
$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git
```

![rebase ex2](../pic/rebase3.png)



3.원본 저장소의 원격 주소가 잘 추가되었는지 확인합니다.

```
$ git remote -v

origin  https://github.com/USERNAME/FORK_REPO.git (fetch)
origin  https://github.com/USERNAME/FORK_REPO.git (push)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (fetch)
upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git (push)
```

![rebase ex3](../pic/rebase4.png)



4.원본을 fetch합니다.

```
$ git fetch upstream master

remote: Enumerating objects: 253, done.
remote: Counting objects: 100% (253/253), done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 479 (delta 249), reused 252 (delta 249), pack-reused 226
오브젝트를 받는 중: 100% (479/479), 259.99 KiB | 463.00 KiB/s, 완료.
델타를 알아내는 중: 100% (296/296), 로컬 오브젝트 9개 마침.
https://github.com/sarojaba/awesome-devblog URL에서
 * branch            master     -> FETCH_HEAD
 * [새로운 브랜치]   master     -> upstream/master
```

![rebase ex4](../pic/rebase5.png)



> 여기까지는 `merge` 를 사용할때와 방법이 똑같습니다.

<br>

5.`rebase` 로 base를 교체하기.

```
$ git rebase upstream/master

First, rewinding head to replay your work on top of it...
Fast-forwarded master to upstream/master.
```

![rebase ex5](../pic/rebase6.png)



6.나의 원격저장소에 push합니다.

```
$ git push origin master

Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/USERNAME/FORK_REPO.git
   83e93ee..f393fa9  master -> master
```

![rebase ex6](../pic/rebase7.png)



---

















![rebase8](../pic/rebase8.jpg)

<center>
  <small>
  	그런데 말입니다..
  </small>
</center>