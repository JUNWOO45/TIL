# 0930

오늘 배포했다가 30분만에 버그터져서 롤백함....

항상 코드를 짤 때 엣지케이스를 잘 생각해야함을 배웠다.



서비스가 안된다고할 때에는 진짜 덥고 땀났는데;

고작 8시간 지난 지금 돌이켜보면 되게 흥분되고 재밌었다ㅎㅎ

더 생각을 많이하면서 코드를 작성해야겠다.

아, 그리고 GCP는 정말정말 강력하다.

특히 오류로그;

AWS를 안써봐서 모르는거겠지만..... 이쪽도 많이 배우고 공부해야겠다.

---


`$ ng add @angular/material` 하니깐 번거로운것없이 앵귤러 머테리얼쓸때 필요한 모든 패키지가 다 설치되넹

굳굳.

app.module.ts에 `BrowserAnimationsModule` 까지 import됨 굳

=======
Material 컴포넌트는 vuetify만 사용해봤었고, 이번에 앵귤러를 공부하며 Angular Material을 사용해보고있는데.. vuetify가 훨씬 다양하고 이쁘고 직관적이고 쉬운 것 같다.

angular는 뭔가.... 뭔가..... 흠...

개인적으로 자란다 관리자콘솔을 개선한다면, 꼭 Material 을 도입해보고싶다.

단순히 디자인만 바뀌는거는 의미가 없고, 어떤부분을 개선하고 새로만들어야하는지 시간날때마다 고민해봐야할듯.



# 1001

10월이다.

2019년도 벌써 끝나가네.. 공부 열심히 해야할듯-_-;;

---

## package-lock.json이란?



package-lock.json을 자주 봤지만 어떤 역할을 하는지 모르고 있었습니다.

오늘은 package-lock.json에 대해서 정리해보려고 합니다.

<br>

### package-lock.json은 왜 생성될까?

우리가 기존에 사용하는 `package.json` 만으로는 정보가 부족하기 때문입니다.

`package.json` 에서는 버전정보를 저장할 때 `version range` 를 사용합니다.

"내가 사용할 패키지의 버전은 1.2.7버전이다." 라고 말하는 대신 "나는 1.2.7버전 이상의 패키지를 사용할거다."처럼 말하는 방식인데요.

(전자처럼 버전정보를 명시하는 것도 가능합니다.)

하지만 몇가지 조건이 들어맞어버리는 불행한 상황이 오게되면, 같은 `package.json` 을 사용해서 `npm install` 을 진행하더라도 서로 다른 `node_modules`를 생성하는 경우가 발생합니다.

-  npm의 버전이 다른 경우, npm의 알고리즘이 조금씩 다르기 때문에 다른 `node_modules` 트리가 생성될 수 있습니다.

- 콕찝어서 버전명을 명시하지않고 `version range` 를 사용하기 때문에, 새로운 버전의 패키지가 배포된 이후 설치를 진행할 경우 최신 버전으로 설치될 수 있습니다.

- 내가 사용하고 있는 패키지가 의존하고 있는 패키지가 새로운 버전으로 배포되었을 경우, 다른 `node_modules` 트리가 생성될 수 있습니다.



첫번째 상황 같은 경우에는 협업하는 멤버들이 `npm --version` 으로 버전을 확인한 뒤, npm 버전을 일치시킨 후 작업하면 예방할 수 있는 상황입니다.

하지만 다른 상황들에서는 다음과같은 일들이 발생할 수 있습니다.

> 개발자1: 테스트가 계속 실패해.
>
> 개발자2: 어제 내가 테스트할 땐 잘 됐는데??
>
> 개발자1: 왜이러지..
>
> .. 몇 시간 후
>
> 개발자1: 아직도 안돼..
>
> 개발자2: 뭐가 문제인 것 같아?
>
> 개발자1: range-parser문제인 것 같아.
>
> 개발자2: range-parser 버전 몇이야?
>
> 개발자1: 2.0.1
>
> 개발자2: 나랑 버전이 다르네; 오늘 아침에 새로운 버전으로 릴리즈되었나본데?

<br>

난감하죠.

이럴때 필요한 것이 `package-lock.json` 입니다.



![package-lock1](../pic/package-lock1.png)

<center>
  <small>
  	package.json 에는 "~3.3.8" 으로 적혀있지만, package-lock.json 에는 "3.3.16"으로 정확한 버전명이 적혀있습니다.
  </small>
</center>





`package-lock.json` 은 `node_modules` 구조나 `package.json` 이 수정되고 생성될 때 당시 의존성에 대한 정확하고 구체적인 정보를 품고 자동으로 생성됩니다.

 `npm install` 명령어를 입력하면 태어난다고 생각하면 되겠네요.

또한 `package-lock.json` 이 존재할 때에는 `npm install` 의 동작방식이 조금 변하는데요.

 `package.json` 을 사용하여 `node_modules` 를 생성하지않고 `package-lock.json` 을 사용하여 `node-modules` 를 생성합니다.

정리를 해보자면, `package-lock.json` 은 개발자들이 동일한 `node_module` 트리를 생성해서 같은 의존성을 설치할 수 있도록 보장해주는 고마운 녀석이라고 할 수 있겠습니다.

<br>

### 끝!

<br>

..을 내려고했지만 궁금했던점.

왜 `package.json` 과 `package-lock.json` 으로 나눠둔 걸까요?

애초에 `package.json` 에 정확한 버전명을 적어놓으면 해결되는 문제 아닐까? 라는 의문점이 들었습니다.

앞서 `package.json` 에서는 `version range` 를 사용한다고 했습니다.

`version range` 는 다음과같이 사용하는데요.

- `1.4.0` : 정확하게 1.4.0버전
- \>1.4.0 : 넘버링이 1.4.0보다 큰 버전
- <1.4.0 : 넘버링이 1.4.0보다 작은 버전
- \>=1.4.0 : 넘버링이 1.4.0보다 크거나 같은 버전
- <=1.4.0 : 넘버링이 1.4.0보다 작거나 같은 버전
- 1.4.0 || >= 2.4.0 : 정확하게 1.4.0버전이거나, 넘버링이 2.4.0보다 같거나 큰 모든 버전



만약 버전을 콕 찝어 정해놓는다면, 내 프로젝트에서 사용하고 있는 패키지의 중요한 버그 수정이 이루어질 때 마다 내 프로젝트의 `package.json` 에 적혀있는 버전도 수정해주어야하기 때문입니다.

모든 크고 작은 릴리즈에대해 항상 추적하고 수정해야하는 엄청난 귀찮음과 수고스러움을 `version range` 가 해결해주기 때문이었습니다.



---

Flex

그동안 마냥 사용해왔는데, 오늘 한가지 중요한점을 배웠다.

```css
.container {
  display: flex;
  justify-content: flex-start;
  align-itmes: flex-end;
}
```

현재 main axis는 가로. 왼쪽에서 오른쪽이다.

`justify-content` 는 항상 main axis를 의미하고, `align-items`는 항상 cross axis를 의미한다.

지금같은 상황에서는, 왼쪽하단으로 치우쳐진 CSS를 볼 수 있을 것이다.

```css
.container {
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;
}
```

지금은 main axis가 위에서 아래, 세로축이다.

`justify-content` 는 main axis를 따라가니깐 하단으로 쏠릴 것이고,

`align-items` 는 cross axis를 의미하니깐, 좌우폭의 중앙에 위치하겠넹.



이해하니깐 정말 쉽고 재밌다. ㅎㅎㅎㅎ

그동안 이해를 못하고 사용했었구나.



# 1002

부끄럽게도 내가 만드는 서비스를 처음부터 끝까지 라이브환경에서 이용해본적이 없었다.

우리 서비스는 선생님앱과 부모님앱, 그리고 관리자콘솔 이렇게 세 줄기로 구성되어있다.

1)부모님이 수업을 요청하면 2)선생님들이 수업에 지원하고 3)둘 사이 조정, 갈등 사항이 있으면 관리자콘솔에서 개입

정도의 플로우를 따른다.

오늘 약 2시간 정도 개발팀 다같이 서비스를 처음부터 끝까지 이용해보며 어떤 문제점이 있는지, 어떤 불편한 점이 있는지 경험해봤는데 그동안 느껴보지못했던 점들을 많이 느꼈다.

개발을 하며 이 전체 플로우의 단편적인 부분들을 반복해서 진행하고 구현하는것과는 전혀 다른 느낌이었다.

어느 회사를 가서도 항상 서비스를 이용해보는, 충분히 아주 충분히 단골고객처럼 이용해보는 마음가짐을 가져야겠다.



---





# GIT

### - git shortlog

커밋을 하고 1이상뜨는지 확인



### - add한 걸 취소 : git reset



### - git commit --amend

commit을 하긴하는데, 가장 최근의 커밋에 흡수시키겠다.

6개의 커밋을 했을때, 수정을해서 커밋을하면 7번째 커밋이 생기는데.

`--amend` 를 하면 흡수시켜버림.





### - push까지 해버린 commit삭제하기

```
gst
git add *
git commit -m "test"
git push origin master // 여기까지 진행했는데 삭제하고싶다면..

git reset HEAD~1	//가장 최근 커밋 삭제
git push origin master --force	//깃헙에 강제로 밀어넣기
```



### - git commit -sm "" 이란?

Author정보에 있는데 왜 또 이름이 들어갈까?

근데 요즘은 이거 잘 안씀. 구닥다리취급함.

요즘은 CLA(contributor license agreement)로 함.

ex) facebook CLA 검색 ㄱㄱ



### - pull request

`땡겨가줘..`

뭔가 새삼 귀여운 이름이네;;



### - git rebase -i --root

되돌리는거임. rebase -i를 rewind로 바꾸는게 더 이해하기좋을듯

edit을 3개했으면, `git rebase --continue` 를 3번해서 풀어줘야함.

`rebase ` : 감기

`--continue` : 풀기



### - git fetch upstream master

upstream의 master를 가져온다.

이때 origin의 `master`와 구별하기위해 `upstream/master`으로 표시



### - git checkout -- [수정한 파일]

이거 뭔 의미여. 해보자.



### -fetch

fetch를 하면 `.git` 에다가 가져와서 임시로 저장해놓음.



# 1004

번역 : https://www.synergycodes.com/blog/how-to-increase-your-frontend-apps-performance

나도 좋은컨텐츠를 블로그에 번역해보고싶어서 하나골랐다ㅎㅎ

원작자에게 허락먼저 구해야겠다.

---



# 앱의 성능을 향상시키는 방법 - 5가지 코딩 팁

------

이 글은 Tomasz Świstak의 [How to increase your frontend app's performance - 5 coding tips]([https://www.synergycodes.com/blog/author/tomasz-%C5%9Bwistak](https://www.synergycodes.com/blog/author/tomasz-świstak)) 를 번역한 글입니다.

------

많은 프론트엔드 프로젝트들이, 어느 시점에서부터는 성능 저하 문제가 발생하기 시작합니다.

솔루션의 복잡성이 증가하는 것은 정상적인 일입니다.

하지만, 개발자들은 이러한 문제를 해결해야하죠.

이 포스팅에서 앱을 최적화하는데 도움이되는 5가지 팁을 정리해보고자 합니다.

일부는 당연해보이고, 또 일부는 프로그래밍의 기초라고 생각될테지만, 그래도 이러한 기초지식들을 되새김질하는 것은 중요합니다.

각각의 팁은 자체적으로 실행하고 성능을 직접 확인한 벤치마크를 근거로 작성되었습니다.

<br>

## 이 팁을 읽기 전에

------

한가지 중요한 점은, 최적화가 필요하지않은 코드를 갈아엎지는 마세요.

여러분이 작성하는 코드는 코드 자체적으로도 항상 빨라야하지만, 더더욱 빠른 방법을 달성하기위해서는 다른 개발자들이 읽기 쉬워야합니다.

Donald Knuth는 코드 최적화에 대해 알아야할 가장 중요한 책인 'Computer Programming as an Art' 에 다음과 같이 썼습니다.

> "큰 문제는 개발자들이 잘못된 위치에서 너무 효율적인 코드를 고민하며 시간을 낭비하고 있다는 겁니다."
>
> "**조기 최적화**는 프로그래밍에서 **악의 근원**입니다."

<br>

## 1. 배열 대신 객체/맵을 사용하여 조회하라.

------

우리는 데이터를 다룰 때, "객체 검색, 객체 다루기, 또 다른 객체 검색" 같은 상황이 자주 발생합니다.

가장 일반적은 자바스크립트 데이터 구조는 배열이므로, 배열 안에 데이터가 저장되는 것은 지극히 정상적인 현상입니다.

그러나 배열에서 무언가를 찾으려면 `find`, `indexOf`, `filter` 같은 메소드를 사용하여 배열의 처음부터 끝을 모두 훑어야합니다.

그래서 우리는 O(n)의 복잡성을 지닌 선형 검색을 사용하게 됩니다.(이는 최악의 경우, 배열의 요소 갯수만큼의 많은 비교를 수행해야함을 의미합니다.)

작은 배열에서는 이 것이 눈에 띄지 않지만, 배열의 요소가 많다면 성능에 절대적인 영향을 끼치게됩니다.

이러한 시나리오에서는 배열을 객체나 맵으로 변환하고 `key` 로 검색을 하는 것이 좋습니다.

이러한 데이터 구조에서는 O(1)의 복잡성을 가지며 요소에 접근할 수 있으므로 자료의 크기에 관계없이 항상 메모리를 한 번 호출하게 됩니다.

객체와 맵은 `해시 테이블` 이라는 자료구조를 사용하기 때문이죠.

![performance](../pic/performance1.png)

차이가 매우 큽니다 - 맵과 객체는 초당 수백만 개의 작업을 수행하지만, 배열은 최상의 결과에서 조차 고작 100여개의 작업만 수행할 수 있습니다.

물론, 지금은 데이터 변환을 고려하지않았지만, 데이터 변환을 고려한다고 해도 여전히 맵과 객체가 빠릅니다.

<br>

## 예외를 먼저 처리하는 대신, IF문을 사용하라.

때때로 사람들은 무언가가 존재하지않을 때, `null` 을 검사하는 것을 생략하고 예외를 포착하는 것이 더 쉽다는 것을 깨닫게됩니다.

당연하게도, 이것은 나쁜 습관이며 이래서는 안됩니다.

따라서 당신의 코드에 이러한 부분이 있다면 코드를 수정하세요.

벤치 마크에서는 세가지 방법, `조건문`, `try-catch`, `short-circuit 평가` 를 검사했습니다.

벤치마크 주소는 다음과 같습니다.

[https://jsperf.com/try-catch-vs-conditions/1](https://jsperf.com/try-catch-vs-conditions/1)

![performance2](../pic/performance2.png)