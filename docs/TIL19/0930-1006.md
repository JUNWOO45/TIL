# 0930

오늘 배포했다가 30분만에 버그터져서 롤백함....

항상 코드를 짤 때 엣지케이스를 잘 생각해야함을 배웠다.



서비스가 안된다고할 때에는 진짜 덥고 땀났는데;

고작 8시간 지난 지금 돌이켜보면 되게 흥분되고 재밌었다ㅎㅎ

더 생각을 많이하면서 코드를 작성해야겠다.

아, 그리고 GCP는 정말정말 강력하다.

특히 오류로그;

AWS를 안써봐서 모르는거겠지만..... 이쪽도 많이 배우고 공부해야겠다.

---


`$ ng add @angular/material` 하니깐 번거로운것없이 앵귤러 머테리얼쓸때 필요한 모든 패키지가 다 설치되넹

굳굳.

app.module.ts에 `BrowserAnimationsModule` 까지 import됨 굳

=======
Material 컴포넌트는 vuetify만 사용해봤었고, 이번에 앵귤러를 공부하며 Angular Material을 사용해보고있는데.. vuetify가 훨씬 다양하고 이쁘고 직관적이고 쉬운 것 같다.

angular는 뭔가.... 뭔가..... 흠...

개인적으로 자란다 관리자콘솔을 개선한다면, 꼭 Material 을 도입해보고싶다.

단순히 디자인만 바뀌는거는 의미가 없고, 어떤부분을 개선하고 새로만들어야하는지 시간날때마다 고민해봐야할듯.



# 1001

10월이다.

2019년도 벌써 끝나가네.. 공부 열심히 해야할듯-_-;;

---

## package-lock.json이란?



package-lock.json을 자주 봤지만 어떤 역할을 하는지 모르고 있었습니다.

오늘은 package-lock.json에 대해서 정리해보려고 합니다.

<br>

### package-lock.json은 왜 생성될까?

우리가 기존에 사용하는 `package.json` 만으로는 정보가 부족하기 때문입니다.

`package.json` 에서는 버전정보를 저장할 때 `version range` 를 사용합니다.

"내가 사용할 패키지의 버전은 1.2.7버전이다." 라고 말하는 대신 "나는 1.2.7버전 이상의 패키지를 사용할거다."처럼 말하는 방식인데요.

(전자처럼 버전정보를 명시하는 것도 가능합니다.)

하지만 몇가지 조건이 들어맞어버리는 불행한 상황이 오게되면, 같은 `package.json` 을 사용해서 `npm install` 을 진행하더라도 서로 다른 `node_modules`를 생성하는 경우가 발생합니다.

-  npm의 버전이 다른 경우, npm의 알고리즘이 조금씩 다르기 때문에 다른 `node_modules` 트리가 생성될 수 있습니다.

- 콕찝어서 버전명을 명시하지않고 `version range` 를 사용하기 때문에, 새로운 버전의 패키지가 배포된 이후 설치를 진행할 경우 최신 버전으로 설치될 수 있습니다.

- 내가 사용하고 있는 패키지가 의존하고 있는 패키지가 새로운 버전으로 배포되었을 경우, 다른 `node_modules` 트리가 생성될 수 있습니다.



첫번째 상황 같은 경우에는 협업하는 멤버들이 `npm --version` 으로 버전을 확인한 뒤, npm 버전을 일치시킨 후 작업하면 예방할 수 있는 상황입니다.

하지만 다른 상황들에서는 다음과같은 일들이 발생할 수 있습니다.

> 개발자1: 테스트가 계속 실패해.
>
> 개발자2: 어제 내가 테스트할 땐 잘 됐는데??
>
> 개발자1: 왜이러지..
>
> .. 몇 시간 후
>
> 개발자1: 아직도 안돼..
>
> 개발자2: 뭐가 문제인 것 같아?
>
> 개발자1: range-parser문제인 것 같아.
>
> 개발자2: range-parser 버전 몇이야?
>
> 개발자1: 2.0.1
>
> 개발자2: 나랑 버전이 다르네; 오늘 아침에 새로운 버전으로 릴리즈되었나본데?

<br>

난감하죠.

이럴때 필요한 것이 `package-lock.json` 입니다.



![package-lock1](../pic/package-lock1.png)

<center>
  <small>
  	package.json 에는 "~3.3.8" 으로 적혀있지만, package-lock.json 에는 "3.3.16"으로 정확한 버전명이 적혀있습니다.
  </small>
</center>





`package-lock.json` 은 `node_modules` 구조나 `package.json` 이 수정되고 생성될 때 당시 의존성에 대한 정확하고 구체적인 정보를 품고 자동으로 생성됩니다.

 `npm install` 명령어를 입력하면 태어난다고 생각하면 되겠네요.

또한 `package-lock.json` 이 존재할 때에는 `npm install` 의 동작방식이 조금 변하는데요.

 `package.json` 을 사용하여 `node_modules` 를 생성하지않고 `package-lock.json` 을 사용하여 `node-modules` 를 생성합니다.

정리를 해보자면, `package-lock.json` 은 개발자들이 동일한 `node_module` 트리를 생성해서 같은 의존성을 설치할 수 있도록 보장해주는 고마운 녀석이라고 할 수 있겠습니다.

<br>

### 끝!

<br>

..을 내려고했지만 궁금했던점.

왜 `package.json` 과 `package-lock.json` 으로 나눠둔 걸까요?

애초에 `package.json` 에 정확한 버전명을 적어놓으면 해결되는 문제 아닐까? 라는 의문점이 들었습니다.

앞서 `package.json` 에서는 `version range` 를 사용한다고 했습니다.

`version range` 는 다음과같이 사용하는데요.

- `1.4.0` : 정확하게 1.4.0버전
- \>1.4.0 : 넘버링이 1.4.0보다 큰 버전
- <1.4.0 : 넘버링이 1.4.0보다 작은 버전
- \>=1.4.0 : 넘버링이 1.4.0보다 크거나 같은 버전
- <=1.4.0 : 넘버링이 1.4.0보다 작거나 같은 버전
- 1.4.0 || >= 2.4.0 : 정확하게 1.4.0버전이거나, 넘버링이 2.4.0보다 같거나 큰 모든 버전



만약 버전을 콕 찝어 정해놓는다면, 내 프로젝트에서 사용하고 있는 패키지의 중요한 버그 수정이 이루어질 때 마다 내 프로젝트의 `package.json` 에 적혀있는 버전도 수정해주어야하기 때문입니다.

모든 크고 작은 릴리즈에대해 항상 추적하고 수정해야하는 엄청난 귀찮음과 수고스러움을 `version range` 가 해결해주기 때문이었습니다.



---

Flex

그동안 마냥 사용해왔는데, 오늘 한가지 중요한점을 배웠다.

```css
.container {
  display: flex;
  justify-content: flex-start;
  align-itmes: flex-end;
}
```

현재 main axis는 가로. 왼쪽에서 오른쪽이다.

`justify-content` 는 항상 main axis를 의미하고, `align-items`는 항상 cross axis를 의미한다.

지금같은 상황에서는, 왼쪽하단으로 치우쳐진 CSS를 볼 수 있을 것이다.

```css
.container {
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;
}
```

지금은 main axis가 위에서 아래, 세로축이다.

`justify-content` 는 main axis를 따라가니깐 하단으로 쏠릴 것이고,

`align-items` 는 cross axis를 의미하니깐, 좌우폭의 중앙에 위치하겠넹.



이해하니깐 정말 쉽고 재밌다. ㅎㅎㅎㅎ

그동안 이해를 못하고 사용했었구나.



# 1002

부끄럽게도 내가 만드는 서비스를 처음부터 끝까지 라이브환경에서 이용해본적이 없었다.

우리 서비스는 선생님앱과 부모님앱, 그리고 관리자콘솔 이렇게 세 줄기로 구성되어있다.

1)부모님이 수업을 요청하면 2)선생님들이 수업에 지원하고 3)둘 사이 조정, 갈등 사항이 있으면 관리자콘솔에서 개입

정도의 플로우를 따른다.

오늘 약 2시간 정도 개발팀 다같이 서비스를 처음부터 끝까지 이용해보며 어떤 문제점이 있는지, 어떤 불편한 점이 있는지 경험해봤는데 그동안 느껴보지못했던 점들을 많이 느꼈다.

개발을 하며 이 전체 플로우의 단편적인 부분들을 반복해서 진행하고 구현하는것과는 전혀 다른 느낌이었다.

어느 회사를 가서도 항상 서비스를 이용해보는, 충분히 아주 충분히 단골고객처럼 이용해보는 마음가짐을 가져야겠다.



---

# GIT

### - git shortlog

커밋을 하고 1이상뜨는지 확인



### - add한 걸 취소 : git reset



### - git commit --amend

: git commit message를 입력했을때, 수정하는 명령어



### - push까지 해버린 commit삭제하기

```
gst
git add *
git commit -m "test"
git push origin master // 여기까지 진행했는데 삭제하고싶다면..

git reset HEAD~1	//가장 최근 커밋 삭제
git push origin master --force	//깃헙에 강제로 밀어넣기
```

