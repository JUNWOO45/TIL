<h1>
  0603
</h1>

todo어플리케이션을 만들면서.

```
만약 모든 컴포넌트가 '같은 데이터 속성(할 일)'을 조작한다면, 화면을 매번 새로고침해야한느 문제점을 해결할 수 있을 것입니다.

같은 데이터 속성을 사용하기위해 최상위(루트) 컴포넌트인 App컴포넌트에 todoItems를 정의하고, 하위 컴포넌트 todoList에 props로 전달하려합니다.

이전에는 할 일 추가, 삭제를 각각 하위 컴포넌트인 todoInput, todoList에서 했습니다.
수정하고나면 뷰 데이터 속성 todoItems와 로컬스토리지의 데이터조회, 추가, 삭제를 모두 App컴포넌트에서 하게됩니다.
하위 컴포넌트들은 그 데이터를 표현하거나 데이터 조작에대한 요청(이벤트 발생)만 수행합니다.
```

### :key 속성은 v-for 디렉티브를 사용할 때 꼭 지정하는 것이 좋습니다!

뷰는 목록의 특정 아이템이 삭제나 추가될 때, DOM에서 나머지 아이템의 순서를 다시 조정하지않고, 전체 아이템의 순서를 제어합니다.

이렇게 프레임워크에서 목록의 순서를 제어하는 이유는 브라우저가 DOM을 조작하는데 소요되는 시간들을 최소화하기 위해서입니다.

예를 들어, 목록 아이템이 100개가 있을 때, 두 번째 목록아이템을 지우면 나머지 98개의 아이템이 모두 한번씩 이동해야합니다.

화면을 다시 그려야하는 브라우저 입장에서는 목록아이템이 많으면 많을수록 렌더링 부담이 커지게 됩니다.

하지만 뷰 프레임워크에서 순서를 제어하는 경우엔, 두번째 아이템을 삭제했을 경우 나머지 목록 아이템을 움직이지 않고, 내부적으로 아이템의 순서만 재조정하여 돔 이동을 최소화시킵니다.

따라서 브라우저에서 화면을 더 빨리 그릴 수 있습니다.

:key 속성을 사용하면 이런 작업을 더 효율적으로 할 수 있게 됩니다.

### Vuex

뷰엑스는 어플리케이션의 상태관리를 돕는 라이브러리입니다.

상태(state)란 뷰 data속성과 비슷합니다.

뷰엑스는 사용하는 모든 데이터를 중앙에서 관리하여 크기가 큰 어플리케이션의 데이터 관리를 효율적으로 하는 것이 목적입니다.

### 뷰의 반응성

뷰가 데이터 변화를 감지했을 때 자동으로 화면을 다시 갱신하는 특성입니다.

데이터가 변경되었을 때 어떻게 뷰에서 자동으로 화면을 갱신하는지 간단하게 공부해보겠습니다.

먼저, 뷰로 어플리케이션을 구현하려면 인스턴스를 생성해야 합니다.

그리고 인스턴스가 생성될 때 data속성에 정의된 객체들은 특정 변환 작업을 거칩니다.

라이브러리에서 data에 정의된 모든 속성(객체)을 getter, setter의 형태로 변환합니다.

여기서 getter와 setter라는 속성은 사용자가 접근할 수 있는 속성이 아닙니다.

다만 뷰 인스턴스에 정의해놓은 data속성에 변화가 생길 때 뷰에서 감지하기위해 라이브러리 내부적으로 필요한 속성입니다.

그리고, 화면을 다시 갱신하는 watcher라는 속성도 있습니다.

watcher속성은 모든 컴포넌트에 존재하는 속성으로, 화면을 다시 그리는데 중요한 역할을 핣니다.

예를들어, 인스턴스가 화면에 올라가고 나서 특정 data 속성을 바꾸거나 접근하면 watcher에서 해당 사실을 감지합니다.

그리고 watcher에서 다시 화면을 그리라는 신호를 보냅니다.

이 외에도, '인스턴스 data 속성에 반응성이 언제 생기는가?'또한 중요합니다.

정답은 '인스턴스를 생성하는 시점'입니다.

따라서 인스턴스를 정의할 때 data속성에 정의하지 않고 인스턴스를 생성하고 난 후 data 속성에 객체를 추가하면 그 객체에는 반응성이 생기지 않습니다.

반응성이 없다는 것은 해당 객체의 변화가 있든 없든 뷰에서 화면을 다시 갱신하지 않는다는 의미입니다.

<hr>

https://kr.vuejs.org/v2/guide/reactivity.html

## 반응형에 대해 깊이 알아보기

#### 변경 내용을 추적하는 방법

vue 인스턴스에 자바스크립트 객체를 data옵션으로 전달하면 뷰는 모든 속성에 Object.defineProperty를 사용하여 getter/setter로 변환합니다.

이는 뷰가 ES5를 사용할 수 없는 IE8이하를 지원하지 않는 이유입니다!

getter/setter는 사용자에게는 보이지않으나 속성에 엑세스하거나 수정할때 뷰가 종속성 추적및 변경알림을 수행할 수 있습니다.

주의 사항은, 변환된 데이터 객체가 기록될 때 브라우저가 getter/setter형식을 다르게 처리하므로 친숙한 인터페이스를 사용하기위해서는 vue-devtools를 설치하는것이 좋습니다.

모든 컴포넌트 인스턴스에는 해당 watcher인스턴스가 있습니다.

이 인스턴스는 컴포넌트가 종속적으로 렌더링되는동안 "수정"된 모든 속성을 기록합니다.(이름값...)

나중에 종속적인 setter가 트리거되면 watcher에 알리고, 컴포넌트는 다시 렌더링됩니다.

#### 변경 감지 경고

최신 자바스크립트의 한계로인해 뷰는 속성의 추가 제거를 감지할 수 없습니다.(말이 왜케 어렵..)

뷰는 인스턴스 초기화 중에 getter/setter변환 프로세스를 수행하기때문에 data객체에 속성이 있어야 뷰가 이를 변환하고 응답할 수 있습니다.

```
var vm = new Vue({
	data: {
		a: 1
	}
});
//vm.a는 반응적입니다.

vm.b = 2;
//vm.b는 반응적이지 않습니다.
```

뷰는 이미 만들어진 인스턴스에 새로운 루트 수준의 반응 속성을 동적으로 추가하는 것을 허용하지 않습니다.

그러나 Vue.set(object, key, value)메소드를 사용하여 중첩된 객체에 반응성 속성을 추가할 수 있습니다.

```
Vue.set(vm.someObject, 'b', 2);
```

#### 반응형 속성 선언하기

뷰는 루트 수준의 반응성 속성을 동적으로 추가할 수 없으므로 모든 루트 수준의 반응성 데이터 속성을 빈 값으로라도 초기에 선언하여 뷰인스턴스를 초기화해야합니다.

```
var vm = new Vue({
	data: {
		//빈 값으로 메세지를 선언합니다.
		message: ''
	},
	template: '<div>{{ message }}</div>'
});

//나중에 'message'를 설정합니다.
vm.message = "hi!"
```

data 옵션에 message를 선언하지 않으면 뷰는 렌더함수가 존재하징낳는 속성에 접근하려한다는 경고를 합니다.

#### 비동기 갱신 큐

뷰는 DOM업데이트를 비동기로 합니다!

데이터 변경이 발견될때마다 큐를 열고 같은 이벤트루프에서 발생하는 모든 데이터변경을 버퍼에 담습니다.

같은 Watcher가 여러 번 발생하면 대기열에서 한번만 푸쉬됩니다.

이 버퍼링된 중복의 제거는 불필요한 계산과 DOM조작을 피하는데있어 중요합니다.

그 다음, 이벤트 루프"tick"에서 뷰는 대기열을 비우고 실제(이미 중복 제거된)작업을 수행합니다.

내부적으로 뷰는 비동기 큐를위해 네이티브 Promise.then과 MessageChannel을 시도하고 setTimeout(fn, 0)으로 돌아갑니다.

예를 들어...

vm.someData = 'NEW VALUE'를 설정하면, 컴포넌트는 즉시 재 렌더링되는 것이 아닙니다.

큐가 플러시될때 다음 'tick'에서 업데이트됩니다.

대부분의 경우 이 작업을 신경쓸 필요가 없지만 업데이트 후 DOM상태에 의존하는 작업을 수행하려는 경우에는 까다로울 수 있습니다.

뷰는 일반적으로 개발자가 "데이터 중심"방식으로 생각하고, DOM을 직접 만지지않도록 권장하지만 때로는 건드려야할 때도 있습니다.

뷰가 데이터변경 후 DOM 업데이트를 마칠때까지 기다리려면 데이터가 변경된 직후에 Vue.nextTick(콜백)을 사용할 수 있습니다.

ex)

```
<div id="example">{{ message }}</div>
var vm = new Vue({
	el: '#example',
	data: {
		message: '123'
	}
});

vm.message = 'new MSG!'	//데이터 변경
vm.$el.textContent === 'new MSG'	//false
Vue.nextTick(function() {
	vm.$el.textContent === 'new MSG'	//true
})
```

추가로, vm.$nextTick() 인스턴스 메소드가 있습니다.

이는 내부 컴포넌트들에 특히 유용합니다.

왜냐하면 전역 Vue가 필요없고 콜백의 this 컨텍스트가 자동으로 현재 Vue 인스턴스에 바인드될 것이기 때문입니다.

```
Vue.component('example', {
	template: '<span>{{ message }}</span>',
	data: function() {
		return {
			message: '갱신 안됨'
		}
	},
	methods: {
		updateMessage: function() {
			this.message = "갱신됨"
			console.log(this.$el.textContent)	//'갱신 안됨'
			this.$nextTick(function() {
				console.log(this.$el.textContent)	//'갱신됨'
			})
		}
	}
})
```



<hr>

<h2>Vue 인스턴스만들기</h2>

모든 Vue앱은 Vue함수로 새로운 뷰 인스턴스를 만드는 것부터 시작합니다.

```
var vm = new Vue({
	//option...
})
```

뷰 인스턴스를 인스턴스화할때에는, 데이터, 템플릿, 마운트할 엘리먼트, 메소드, 라이프사이클 콜백 등의 옵션을 포함할 수 있는 options객체를 전달해야합니다.

모든 뷰 컴포넌트는 본질적으로 확장된 뷰 인스턴스입니다.

<h4>
  속성과 메소드
</h4>

각 뷰 인스턴스는 data객체에 있는 모든 속성을 프록시처리합니다.

```
var data = { a : 1 };

var vm = new Vue({
	data: data
});

vm.a === data.a;	//true

vm.a = 5;
data.a;	// 5

data.a = 10;
vm.a;	//10

```

데이터가 변경되면, 화면은 다시 렌더링됩니다.

유의할 점은, data에 있는 속성들은 인스턴스가 생성될 때 존재한 것들만 반응형이라는 점입니다.

즉, 다음처럼 새 속성을 추가한다면..

```
vm.b = 'hi?';
```

b가 이후에 변경되더라도 화면은 갱신되지않습니다.

따라서, 어떠한 속성이 나중에 필요하다는 것을 알고 있다면... 다음처럼 data를 처음부터 지정해주는 것이 좋습니다.

```
data : {
	name: '',
	age: 0,
	todos: [],
	error: null
}
```



<h2>
  computed와 watch
</h2>

<h3>
  computed속성
</h3>

<hr>

템플릿 내에 표현식을 넣으면 편리하지만, 너무 많은 연산을 템플릿 안에서하면 코드가 비대해지고 유지보수가 어려워집니다.

```
<div id="example">
	{{ message.split("").reverse().join("") }}
</div>
```

message를 역순으로 표시한다는 것을 알려면 천천히 살펴봐야합니다.

더욱 복잡한 로직이라면, 반드시 computed속성을 사용해야 합니다.

```
<div id="example">
  <p>원본 메시지: "{{ message }}"</p>
  <p>역순으로 표시한 메시지: "{{ reversedMessage }}"</p>
</div>
```

```
var vm = new Vue({
	el: '#example',
	data: {
		message: '박준우'
	},
	computed: {
		reversedMessage: function() {
			return this.message.split('').reverse().join('');
		}
	}
})
```

computed의 reversedMessage의 값은 항상 message의 값에 의존합니다.

Vue는 이러한 사실을 알기때문에, message가 바뀔때마다 reversedMessage에 의존하는 바인딩을 모두 업데이트할 것입니다.




<h3>
  computed속성의 캐싱 VS methods
</h3>

```
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('');
  }
}
```

처럼 methods를 호출하여 같은 결과를 도출할 수 있습니다.

하지만, 엄청 큰 차이점이 있습니다.

**computed 속성은 종속 대상을 따라 저장(캐싱)된다는 것** 입니다.

computed속성은 해당 속성이 종속된 대상(message)가 변경될 때만 함수를 실행합니다.

즉, Message가 변하지 않는한 computed속성인 reversedMessage를 여러 번 요청해도 계산을 다시 하지 않고 계산되어있던 결과를 즉시 반환합니다.



<h3>
  watch 속성
</h3>

<hr>

대부분의 경우 computed속성이 더 적합하지만, 사용자가 만든 watch가 필요한 경우도 있습니다.

뷰는 watch옵션을 통해 데이터 변경에 반응하는 보다 일반적인 방법을 제공합니다.

이는 데이터 변경에대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행하는 경우에 유용합니다.

```
<div id="watch-example">
	<p>
		yes or no :
		<input v-model="question">
	</p>
	<p>{{ answer }}</p>
</div>
```

```
<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
<script>
	var watchExample = new Vue({
		el: '#watch-example',
		data: {
			question: '',
			answer: '질문하기 전까지는 대답할 수 없습니다.'
		},
		watch: {
			question: function(newQ) {
				this.answer = '입력을 기다리는 중...',
				this.getAnswer();
			}
		},
		methods: {
			getAnswer: _.debounce(
				function() {
					if(this.question.indexOf('?') === -1) {
						this.answer = '질문에는 물음표가 필요합니다!'
						return
					}
					this.answer = '생각중...';
					var vm = this;
					axios.get('https://yesno.wtf/api')
						.then(function(res) {
							vm.answer = _.capitalize(res.data.answer);
						})
						.catch(function(err) {
							vm.answer = '에러 : ' + error 
						})
				}, 500)
		}
	})
</script>
```



<hr>

<h2>
  Vuex
</h2>



<h3>
  상태관리 패턴
</h3>

상태관리 구성요소는 크게 3가지가 있다고 합니다.

- state: 컴포넌트 간 공유될 data
- view: 데이터가 표현될 template
- actions: 사용자의 입력에따라 반응할 methods

```
new Vue({
	//state
	data() {
		return {
			count: 0
		}
	},
	//view
	template: `
		<div>{{ count }}</div>
	`,
	//actions
	methods: {
		increment() {
			this.count++;
		}
	}
})
```






<h3>
  Vuex 사용하기
</h3>

우선 Vuex를 설치합니다.

```
$ npm install vuex --save
```

Vuex를 등록한 js파일을 하나 생성합니다.

컨벤션에따라 store.js로 해줍시다!

```
// store.js

import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

export const store = new Vuex.Store({
	state: {
		counter: 0
	}
});
```

Vue와 App이 등록된 main.js에서 store.js를 불러와 등록해줍니다.

```
//main.js

import Vue from 'vue';
import App from './App.vue'
import { store } form './store'

new Vue({
	el: '#app',
	store,
	render: h => h(App)
})
```

App.vue에서 Vuex를 사용해봅니다. state에 등록된 counter에 접근하려면 **this.$store.state.counter** 를 사용합니다.

```
//App.vue

<template>
  <div id="app">
    counter: {{ this.$store.state.counter }}
    <button @click="add">+</button>
    <button @click="sub">-</button>
  </div>
</template>

<script>
	export default {
		methods: {
			add() {
				this.$store.state.counter++;
			},
			sub() {
				this.$store.state.counter--;
			}
		},
		components: {
			'child': Child
		}
	}
</script>
```



<h1>
  0605
</h1>

<h2>
  Vuex
</h2>

중앙 데이터 관리식 구조에서 발생하는 문제점 중 하나는 각 컴포넌트에서 Vuex의 데이터를 접근할때 중복된 코드를 반복호출하게된다는 점입니다.

```
// App.vue
computed: {
	add() {
		return this.$store.state.counter++;
	}
}
```

```
// Child.vue
computed: {
	add() {
		return this.$store.state.counter++;
	}
}
```

복수개의 컴포넌트에서 똑같은 로직을 반복하고 있습니다.

이때, Vuex의 데이터(state)변경을 각 컴포넌트에서 수행하는 것이 아니라, Vuex에서 수행하도록하고 각 컴포넌트에서 수행로직을 호출하면, 코드 가독성도 올라가고 성능에서도 이점이 생깁니다!

```
// store.js(Vuex)
getters: {
	add:function(state) {
		return state.counter++;
	}
}
```

```
//App.uve
computed: {
	add() {
		return this.$store.getters.add;
	}
}
```

```
//Child.vue
computed: {
	add() {
		return this.$store.getters.add;
	}
}
```

만약 getters에 담겨있는 함수가 엄~~청 복잡하다면, 왜 Getters를 쓰는게 편한지 더욱 체감할 수 있을 듯 싶습니다.

```
//store.js
export const store = new Vuex.Store({
	state: {
    counter: 0
  },
	getters: {
		getCounter: function(state) {
			return state.counter;
		}
	}
})

```

```
//App.vue
<div id="app">
	Parent counter: {{ parentCounter }}
</div>

<script>
	computed: {
		parentCounter() {
			return this.$store.getters.getCounter;
		}
	}
</script>
```

```
//Child.vue
<div>
	Child counter: {{ childCounter }}
</div>

<script>
	computed: {
		childCounter() {
			return this.$store.getters.getCounter;
		}
	}
</script>
```

1.우선, 기존에 Parent counter: {{ this.$store.state.counter }}라고 쓰여있던건 너무 깁니다!

template의 표현식은 최대한 간소화해야한다고 공부했습니다. 고쳐줍니다.

2.Vuex에 Getters를 등록해줍니다.

그리고 기존의 parentCounter와 childCounter에 사용되던 return this.\$store.state.counter를 return this.\$store.getters.getCounter로 고쳐줍니다.

<h3>
  mapGetters
</h3>

mapGetters는 Vuex에 내장된 helper함수입니다.

getters를 써서 가독성이 올라간 코드를 더 직관적으로 작성할 수 있게 도와줍니다.

```
//App.vue
<div id="app">
  Parent counter : {{ parentCounter }}
</div>
```

이걸..

```
//App.vue
import { mapGetters } from 'vuex';

// ...
computed: mapGetters({
	parentCounter: 'getCounter'
})
```

getCounter는 Vuex의 getters에 선언된 속성이름입니다.



<h3>
  Mutations
</h3>

Mutations는 Vue의 데이터, 즉 state값을 변경하는 로직을 의미합니다.

Mutations는 Getters와는 다르게,

1.인자를 받아 Vuex에 넘겨줄 수 있습니다.

2.computed가 아닌 methods에 등록합니다.

지금까지는 

```
return this.$store.state.counter++;
return this.$store.state.counter
```

처럼 직접 state에 접근하여 데이터를 다루었지만, 이것은 **안티패턴**입니다..!

(그 이유는, 여러개의 컴포넌트에서 같은 state값을 동시에 제어하게된다면, state값이 어느 컴포넌트에서 호출해서 변경된것인지 추적하기 어렵기때문입니다.)

<h3>
  Mutations등록</h3>

```
//store.js

export const store = new Vuex.Store({
	//...
	mutations: {
		addCounter: function(state, payload) {
			return state.counter++;
		}
	}
})
```

<h3>
  Mutations사용
</h3>

```
//App.vue
methods: {
	addCounter() {
		this.$store.commit('addCounter');
	}
}
```

Mutations는 commit을 이용해서 접근해야합니다.



<h3>
  Mutations에 인자 값 넘기기
</h3>

각 컴포넌트에 state를 조작하는데 필요한 특정값들을 넘기고싶을때엔 commit()의 두번째 인자를 넣어줍니다.

```
this.$store.commit('addCounter', 10);
this.$store.commit('addCounter', {
	age: 100,
});
```

두번째 예시를 Vuex에서 받는다고 가정하면..

```
mutations: {
	//this.$store.commit('getAge', {
	//	age: 100
	//})
	getAge: function(state, payload) {
		state.age = payload.age;
	}
}
```



<hr>



<h2>
  Actions란?
</h2>

Mutations에는 순차적인 로직들만 선언하고, Actions에는 비순차적 또는 비동기적 처리로 로직들을 선언합니다.

왜이렇게 Mutations와 Actions로 나눠서 등록할까요?

Mutations는 State관리에 주안점을 두고 있습니다.

**"상태관리"**자체가 한 데이터에대해 여러개의 컴포넌트가 관여하는 것을 효율적으로 관리하기위함인데, Mutations에 비동기 처리 로직들이 포함된다면, 같은 값에대해 여러개의 컴포넌트에서 변경을 요청했을때 그 변경 순서 파악이 어렵기 때문입니다.

이러한 문제점과 마주치지않기위해 Actions에는 비동기 처리 로직을, Mutations에는 동기 처리 로직으로 나눠서 구현하는 것입니다.

그렇다면, setTimeout()이나 서버와의 http통신처리같은 로직은 Actions에 선언하겠군요!

<h3>
  Actions 등록
</h3>

```
//store.js

export const store = new Vuex.Store({
	//...
	mutations: {
		addCounter: function(state, payload) {
			return state.counter++;
		}
	},
	actions: {
		addCounter: function(context) {
			return context.commit('addCounter');
		}
	}
})
```

actions는 결국 mutations의 메서드를 호출합니다.

```
//App.vue
methods: {
	addCounter() {
		this.$store.dispatch('addCounter');
	}
}
```

