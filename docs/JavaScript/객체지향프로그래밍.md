# 자바스크립트 객체지향 프로그래밍

- 자바스크립트에서의 객체는 모두 Object타입의 인스턴스입니다.



## 객체접근 - 프로퍼티 추가

```javascript
var obj = {
  gender: 'male',
  age: 100
};

obj.name = 'aaa';	//프로퍼티가 없으면 프로퍼티 추가
obj.name = 'bbb';	//프로퍼티가 있으면 값변경
```

- key값이 숫자로 시작한다면, dot notaion은 사용못하고 배열의 인덱스 형태로만 접근 가능합니다.

```javascript
obj.1st	//error
obj['1st'] = 'first';
```

- 배열의 인덱스형태에서는 자바스크립트 표현식이 모두 가능합니다.

```javascript
var personName = 'name';
obj[personName] = 'junwoo';	//obj.name = 'junwoo'
obj[personName + 'Deleted'] = 'junwoo';	//obj.nameDeleted = 'junwoo'
```



## 객체 접근 - 프로퍼티 삭제

```javascript
var obj = {
  name: 'junwoo'
};

//null값을 넣어도 지워지는것이 아닙니다!
obj.name = null;
'name' in obj === true;

//delete로 삭제해야합니다! 지워지면 true를 리턴합니다.
delete obj.name;
'name' in obj === false;
obj.name === undefined	//true
```



## 객체접근 - 객체삭제

- 객체로의 참조는 끊을 수 있어도, 객체를 직접 삭제할 수는 없습니다.

```javascript
var foo = {};

foo = null;
//변수 foo가 참조하던 객체의 참조가 끊겼습니다.
//{}는 삭제된 것이 아닙니다!
//하지만 언젠가 가비지콜렉터에의해 객체는 메모리 상에서 소멸될 것입니다.
```



## Object.defineProperty()

- 객체의 프로퍼티에 특별한 속성을 적용시킵니다.
- 속성으로 프로퍼티의 접근 권한을 설정할 수 있습니다.
- getter와 setter를 만들 수 있습니다.

```javascript
var obj = {};

Object.defineProperty(obj, 'name', {
  value: 'junwoo',
  configurable: true,	//삭제
	writable: true,	//값 변경
  enumarable: true	//for-in문에서 해당 프로퍼티를 반환하는지.
});	
//옵션의 속성을 생략하면 디폴트로 모두 false가 설정됩니다.
```

테스트해보겠습니다!

```javascript
var obj = {};

Object.defineProperty(obj, 'name', {
  value: 'junwoo',
  configurable: false,	
	writable: true,
  enumarable: true
});	
//configurable값을 false로 주고

delete obj.name;
obj.name === 'junwoo';	//삭제가 불가능 합니다!
```

```javascript
var obj = {};

Object.defineProperty(obj, 'name', {
  value: 'junwoo',
  configurable: true,	
	writable: false,
  enumarable: true
});	
//writable값만 false로 주고

obj.name = 'mike';
obj.name === 'junwoo';	//변경 불가능
```

```javascript
var obj = {
  name: 'junwoo',
  age: 100
};

Object.defineProperty(obj, 'id', {
  value: 'abcdefg',
  configurable: true,	
	writable: true,
  enumarable: false
});	
//enumarable값만 false로 주고

for(var key in obj) {
  console.log("key : ", key);
}
// key : name
// key : age
// id값은 출력되지 않습니다!
```



## Object.defineProperty() - getter와 setter

```javascript
var obj = {};
var randomNum = 100;

Object.defineProperty(obj, 'age', {
  set: function(value) {
    randomNum = value;
  },
  get: function() {
    return randomNum + '살';
  }
});

obj.age = 100;
console.log(obj.age);	//'100살'
```



## call, apply, bind

###우선 call과 apply먼저..

```javascript
var person = {
  name: 'paul',
  title: '반갑습니다.'
};

function setName(name) {
  this.name = name;
}

setName('junwoo');

window.name === 'junwoo';
```

- 현재 person객체와 setName함수는 아무런 관계도 없습니다.
- setName함수를 실행하게되면, this는 window를 가리키고있기에, 글로벌 컨텍스트에 name이라는 프로퍼티가 생성될 뿐…...
- 저는 setName함수가 person객체를 바꾸게 하고 싶습니다! 어떻게 해야할까요?

```javascript
var person = {
  name: 'paul',
  title: '반갑습니다.'
};

function setName(name) {
  this.name = name;
}

setName.call(person, 'junwoo');
//혹은
//setName.apply(person, ['junwoo']);

person.name === 'junwoo';
```

### bind

- this가 특정 객체로 고정된 함수를 리턴합니다.

```javascript
var person = {
  name: 'paul',
  title: '반갑습니다.'
};

function setName(name) {
  this.name = name;
}

var setNameOfPerson = setName.bind(person);
setNameOfPerson('gagaga');

person.name === 'gagaga'	//true
```



###call메소드를 이용해서 bind함수를 직접 구현해보기.

```javascript
var person = {
  name: 'junwoo'
};

function printPersonName() {
  console.log(this.name);
}

function makeBindMethod(func, context) {
  return function() {
    func.call(context);
  }
}

var customBind = makeBindMethod(printPersonName, person);
customBind();	//'junwoo'
```

printPersonName함수의 this를 person객체와 연결시키고싶습니다.

custonBind변수에 담기는 makeBindMethod에 printPersonName함수와 person 객체를 인자로 넣고,

makeBindMethod는 익명함수 function(){func.call(context)}를 리턴하죠.

즉, customBind는...

```javascript
customBind = function() {
	printPersonName.call(person)
} 
```

이 담기게 됩니다.



## 객체 생성 패턴

### 팩터리 함수

- 리터럴은 여러개의 객체를 생성할때는 부적합합니다.

```javascript
var person1 = {
  name: 'junwoo'
};

var person2 = {
  name: 'pogba'
};

var person3 = {
  name: 'eriksen'
};

...
```

- 팩터리패턴 : 객체의 생성과정을 캡슐화합니다.
- 만드려고하는 객체를 생성하는 함수를 작성해서 여러개의 객체를 만들 수 있습니다!

```javascript
function createPerson(name) {
  var newPerson = {};
  
  newPerson.name = name;
  
  return newPerson;
}

var person1 = createPerson('junwoo');
var person2 = createPerson('pogba');
var person3 = createPerson('eriksen');
```



### 생성자

- 클래스의 역할을 합니다!
- 일반 함수를 new 키워드와 함께 실행하면 생성자로 동작합니다!
- new키워드를 사용했을 때 this는 빈 객체를 가리킵니다.

```javascript
function Person(name) {
  this.name = name;
}

var person1 = new Person('junwoo');
```



### new연산자의 내부 동작(1)

```javascript
//new 없이 실행하게되면...
var person = Person('junwoo');

function Person(name) {
  //1. this = window입니다.
  this.name = name;	//2. 코드를 실행합니다.
  
  //3. return undefined : 리턴값이 없으면 undefined를 리턴합니다.
}

//즉, person변수에는 undefined이 담기게 됩니다.
```

### new연산자의 내부 동작(2)

```javascript
//new와 함께 실행하면..!
var person = new Person('junwoo');

function Person(name) {
  //1. this = {}; : 새로운 객체를 만들고 this는 그 객체를 가리킵니다!
  //2. 객체와 생성자의 프로토타입을 연결합니다!
  
  this.name = name; //3.코드를 실행합니다.
  //4. return this; : 생성자는 만들어진 객체를 자동으로 리턴합니다. 따라서 person변수에 만들어진 객체가 담깁니다!
}
```



### 객체 타입 비교

- 생성자를 이용해서 객체를 생성하면 생성자의 타입을 가질 수 있습니다.
- 타입은 constructor와 instanceof연산자를 이용해서 구할 수 있습니다.

```javascript
function Person() {};

var man = new Person();

typeof man;	//'object'
man.constructor === Person;	//true
man instanceof Person;	//true
```

