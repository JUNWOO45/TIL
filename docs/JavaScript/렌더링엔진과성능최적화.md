<h1>
  렌더링 엔진과 성능을 최적화하는 방법
</h1>

부제 : 자바스크립트는 어떻게 동작하는가(왜 이 제목은 인터넷에 엄청나게 많이 존재하는가..)



우선, 브라우저의 주요 컴포넌트를 살펴보겠습니다.

- 사용자 인터페이스 : 주소 입력 바, 뒤로가기&앞으로가기 버튼, 즐겨찾기 메뉴 등이 있습니다. 웹페이지에서 컨텐츠를 보는 창을 제외한 브라우저 디스플레이의 모든 부분을 의미합니다.
- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 상호작용을 다루는 부분입니다.
- 렌더링 엔진 : 웹페이지의 표시를 책임집니다! 렌더링 엔진은 HTML과 CSS를 파싱하고, 파싱된 내용을 화면에 표시합니다.
- 네트워킹 : XHR요청과 같은 네트워크 호출입니다.
- UI 백엔드 : 체크박스 및 윈도우와같은 핵심 위젯을 그리기위해 사용됩니다. 
- 자바스크립트 엔진 : 기본적으로 여기서 자바스크립트가 실행됩니다..!
- 데이터 지속성(Data persistence) : localStorage, indexDB, WebSQL, FileSystem같이 데이터를 로컬에 저장할 수 있게 제공되는 저장소입니다.

<h3>
  렌더링 엔진 개요
</h3> 

렌더링 엔진은 브라우저 화면에 요청된 페이지를 표시하는 것이 주역할입니다.

렌더링 엔진은 HTML 및 XML문서와 이미지들을 표시할 수 있습니다.

추가적으로 플러그인을 사용한다면, 렌더링 엔진은 PDF와 같은 다른 문서도 표시할 수 있습니다!

인기있는 엔진들로는

- Gecko - Firefox
- WebKit - Safari
- Blink - Chrome, Opera

가 있습니다.



<h3>
  렌더링 과정
</h3>

렌더링 엔진은 네트워킹 레이어로부터 요청된 문서의 내용을 전달받습니다.

그 과정은 다음과 같습니다.

1. HTML을 파싱하여 DOM트리를 구성합니다.
2. 렌더 트리를 구성합니다.
3. 렌더 트리를 레이아웃합니다.
4. 렌더 트리를 그립니다.



<h3>
  DOM트리 구성
</h3>

렌더링 엔진의 첫번째 단계는 HTML 도큐먼트를 파싱하고, 파싱된 요소들을 DOM트리의 실제 DOM노드로 변환하는 것입니다.



<h3>
  CSSOM트리 구성
</h3>

CSSOM이란, CSS 객체 모델(CSS Object Model)을 뜻합니다.

```
<link rel="stylesheet" href="style.css">
```

브라우저가 페이지 내에서 DOM을 구성하는 동안, head영역에서 외부 CSS스타일 시트를 참조하는 link태그를 만납니다.

페이지를 그리기위해 해당 파일이 필요한 것을 예상하면서 즉시 자원요청을 실시합니다.

```
//style.css

body {
	font-size: 10px;
}

div {
	border: 1px solid black;
}
```

HTML 돔트리와 마찬가지로, 엔진은 CSS를 브라우저에서 동작할 수 있는 CSSOM으로 변환합니다.



<h3>
  렌더 트리 구성
</h3>

CSSOM트리에서 스탕리 데이터와 결합한 HTML의 시각적인 정보는 렌더트리를 생성하기위해 사용됩니다.

렌더 트리란, 시작적 요소들이 화면에 표시되는 순서대로 구성된 트리입니다.

렌더 트리는 HTML + CSS의 시각적 표현이라고 생각하면 됩니다.

렌더 트리는 "정확한 순서로 콘텐츠를 그리기 위해" 존재합니다.

(렌더 트리의 각 노드는 Webkit의 렌더러 또는 렌더 객체로 알려져있습니다.)

렌더 트리를 구성하기위해 브라우저는 다음과 같은 일을 수행합니다.

- DOM트리의 루트에서부터 시작해, 각각의 시각적 노드들을 순회합니다.
  일부 노드(스크립트 태그, 메타 태그 등)는 시각적이지 않기때문에 출력되지않고 생략됩니다.
  또한 일부 노드는 CSS를 통해 숨겨지고 렌더 트리에서 생략됩니다(ex: display: none;)
- 각각의 시각적인 노드들로부터 브라우저는 적절한 CSSOM규칙을 찾아 적용합니다.
- 브라우저는 콘텐츠와 계산된 스타일과 함께 시각적인 노드들을 보여줍니다.



<h3>
  렌더 트리 레이아웃
</h3>

렌더러가 생성되고 트리에 추가될때, 이 렌더러는 위치와 크기를 가지고 있지 않습니다.

이러한 **위치와 크기에대한 값**들을 계산하는 것을 "레이아웃"이라고 합니다.

HTML 도큐먼트 엘리먼트에서 \<html>태그를 자주 봣는데요. 이것을 **루트 렌더러** 라고 합니다.

좌표는 루트 렌더러를 기준으로 top, left좌표가 사용됩니다.

레이아웃은 부분 또는 전체 렌더러의 계층을 통과하며 재귀적으로 반복되고, 이를 필요로하는 렌더러의 기하학적 정보를 계산합니다.

루트 렌더러의 위치는 0, 0입니다.



<h3>
  렌더 트리 페인팅
</h3>

렌더 트리를 순회하고 화면상에 콘텐츠를 보여주기위해 렌더러의 paint() 메서드를 호출합니다.

페인팅은 두가지가 있습니다.

- Global : 전체 트리가 다시 그려집니다.
- Incremental : 전체 트리에 영향을 주지않는 방법으로 렌더러 일부가 변경됩니다. 렌더러는 화면 상에서 렌더러의 사각형을 무효로 합니다. 이렇게하면 운영체제(OS)가 다시 그리기 필요한 영역으로 인식하고 paint이벤트를 발생시킵니다. OS는 몇몇 영역을 하나로 합쳐 똑똑한 방식으로 이를 처리합니다.

페인트가 점진적인 과정임을 이해하는 것이 중요하다고 합니다.

더 나은 UX의 경우, 렌더링 엔진은 가능한 빠르게 화면상에 콘텐츠를 보여줄 수 있도록 시도할 것입니다.

렌더링 엔진은 렌더 트리를 만들고 레이아웃하기위해 모든 HTML이 파싱될때까지 기다리지 않습니다.

콘텐츠 일부는 파싱되고 표시되며, 나머지 콘텐츠 항목들은 네트워크 상에서 계속 처리됩니다.



<h3>
  스크립트와 스탕리 시트의 처리 순서
</h3>

스크립트는 파서가 \<script>태그에 도달했을때 즉시 파싱되고 실행됩니다.

문서의 파싱은 스크립트 실행이 끝날때까지 대기합니다.

이것은 처리가 **"동기적"**임을 보여줍니다!

만약 스크립트가 외부 스크립트라면, 먼저 네트워크에서 동기적으로 이 파일을 가져와야합니다.

파일을 가져오기 전까지 모든 파싱과정은 정지됩니다.

HTML5에서는 스크립트를 비동기로 표시하여 다른 스레드에서 파싱되고 실행될 수 있는 옵션을 추가했습니다.



<h3>
  렌더링 성능 최적화
</h3>

만약 어플리케이션을 최적화하고 싶다면, 5가지 영역에 집중해야한다고 합니다.

1. 자바스크립트 : 렌더링과 관련해, 자바스크립트 코드가 페이지의 DOM엘리먼트와 상호작용하는 방식에대해 생각할 필요가 있습니다. 
2. 스타일 계산 : 매칭 셀렉터에 기반해 엘리먼트에 CSS규칙이 적용되는 것을 결정하는 과정입니다.
3. 레이아웃 : 브라우저가 엘리먼트에 적용되는 규칙을 알고 있으면, 브라우저는 화면에서 엘리먼트들이 차지하는 공간과 위치를 계산할 수 있습니다.
   웹 레이아웃 모델은 한 엘리먼트가 다른 엘리먼트에 영향을 줄 수 있다고 정의합니다.
   예를들어, body태그의 너비는 자식요소 너비에 영향을 줄 수 있습니다.
4. 페인트 : 실제 픽셀이 채워지는 곳입니다.
   이 과정에는 텍스트, 색상, 이미지, 보더, 그림자 등을 그리는 작업이 포함됩니다.
   엘리먼트의 모든 시각적인 부분들이 포함됩니다.
5. 합성 : 페이지의 부분들은 여러 레이어로 그려지기에, 페이지가 정확히 렌더링 되도록 순서대로 화면에 그려져야 합니다. 특히, 겹치는 엘리먼트가 있을 경우에 이 부분이 굉장히 중요합니다.



<h3>
  자바스크립트 최적화
</h3>

자바스크립트는 종종 브라우저에서 시각적인 변화를 유발하는데, 특히 SPA를 만들때 더더욱 그러합니다.

- 시각적 업데이트를위해 setTimeout이나 SetInterval은 피해야합니다.

<h3>
  CSS 최적화
</h3>

엘리머트 추가, 삭제, 속성 변경등을 통해 DOM을 수정하면, 브라우저는 엘리먼트 스타일과 전체 또는 일부 페이지의 레이아웃을 다시 계산하게 됩니다.

따라서, 다음을 고려해야합니다.

- 셀렉터의 복잡도를 줄입니다.
- 스타일 계산을 수행해야하는 엘리먼트의 갯수를 줄입니다.

<h3>
  레이아웃 최적화
</h3>

레이아웃 재계산은 브라우저에게 매우 무거울 수 있습니다.

- 가능할때마다 레이아웃의 수를 줄입니다.
  스타일을 변경할때 브라우저는 어떤 변경사항 중 레이아웃을 재계산해야하는지를 확인합니다.
  width, height, left, top같은 속성들을 변경하려면 레이아웃이 필요합니다.
  따라서 가능한 한 많이 변경하지 말아야합니다.

- 가능할때마다 구형 레이아웃 모델에 대해 **flexbox**를 사용합니다.(…..!!)

  이것은 빠르게 동작하고 어플리케이션에 큰 성능이점을 만들 수 있습니다(…..!!!!아..아닛..!?)

- 강제 레이아웃 동기화를 피합니다.
  자바스크립트가 실행되는 동안, 이전 프레임으로부터 모든 구형 레이아웃값을 알고 있어 쿼리가 가능하다는 점을 염두해두고 있어야합니다.

  SOMETHING.offsetHeight에 접근한다면 문제가 되지 않지만, 접근전에 스타일을 변경하는 경우(ex : 엘리먼트에 일부 CSS를 동적으로 추가)에는 브라우저는 먼저 스타일을 변경하고 레이아웃을 실행해야합니다.
  이것은 시간이 오래 걸릴 수 있고 자원을 많이 소비할 수있으므로 되도록이면 피해야합니다.



<h3>
  페인트 최적화
</h3>

페인트과정은 전테 작업에서 가장 많이 실행되기때문에 가능한 피하는것이 중요합니다.

- transforms 또는 Opacity이외의 속성을 변경하면 페인트가 실행되므로 덜 사용합니다.
- 레이아웃이 발생하면 기하값(width, hegiht…)들을 엘리먼트의 시각적 변화로 바꾸기때문에 페인트또한 발생합니다.
- 레이어 비율과 애니메이션의 조화에 따라 페인트를 줄입니다.

