<h1>
    0129
</h1>

리덕스

~~~
MVC패턴을 대체하기 위해서 페이스북이 사용한 Flux패턴을 살짝 바꾼것이라고 합니다.

Flux는 애플리케이션에서 데이터를 취급하기위한 패턴입니다.
Flux와 React는 페이스북에서 함께 성장해왔습니다.
이 둘은 페이스북이 가지고 있었던 특정 문제점을 해결하기 위해서 개발되었다고합니다.
그 중 가장 많이 알려져있던 문제점이 알림버그입니다.

이전에는 데이터를 가지고 있는 모델(model)이 렌더링하기위해 뷰레이어로 데이터를 보냈을 것입니다.
사용자와의 상호작용(user interaction)이 뷰를 통해서 일어났기때문에 사용자의 입력에 따라 뷰가 가끔씩 모델을 업데이트해야할 필요가 있었습니다.
그리고 의존성때문에 모델이 다른 모델을 업데이트해야할 때도 있었습니다.

어떤 한 변경이 다른 변경을 초래하기도 했습니다.
또한 이런 변경들이 비동기적으로 생기기도했습니다.

이러한 데이터흐름은 디버그하기 어렵게 만들었습니다.

- 해결책: 단방향 데이터 흐름(unidirectional data flow)
그래서 페이스북은 다른 종류의 아키텍처를 시도하기로 결정했습니다.
이 구조에서 데이터는 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 흐름이 다시 시작됩니다.
이 아키텍처를 Flux라고 불렀습니다.

Action -> Dispatcher -> Store -> View -> Action...

캐릭터들을 만나보겠습니다.

- 액션 생성자
첫번째 캐릭터는 액션생성자입니다.
모든 변경사항과 사용자와의 상호작용기 거쳐가야하는 액션의 생성을 담당하고있습니다.
언제든 애플리케이션의 상태를 변경하거나 뷰를 업데이트하고싶다면 액션을 생성해야만합니다.

액션 생성자는 전보기사와 같습니다. 메세지를 포맷에 맞게 변환시켜줍니다.
어떤 메세지를 보낼지 알려주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷으로 바꿔준다.
액션생성자는 타입과 페이로드를 포함한 액션을 생성합니다.
...
일단 액션생성자가 액션 메세지를 생성한 뒤에는 디스패쳐로 넘겨줍니다.

-디스패쳐
디스패쳐는 기본적으로 콜백이 등록되어있는 곳입니다.
디스패쳐는 전화교환대에서 교환원이 일하는 것과 같습니다.
디스패쳐는 액션을 보낼 필요가 잇는 모든 스토어를 가지고 있고, 액션 생성자로부터 액션이 넘어오면 여러 스토어에 액션을 보냅니다.

이 처리는 동기적으로 실행되어서 위쪽에서 이야기했던 다수의 공으로 플레이하는 핑퐁게임같은 경우를 처리하는데 도움을 줍니다.
만약 스토어들 사이에 의존성이 있어서 하나를 다른것보다 먼저 업데이트해야한다면, 디스패쳐가 적절히 처리하도록 할 수 있습니다.

Flux의 디스패쳐는 다른 아키텍쳐들과는 조금 다른점이 있습니다.
액션타입과는 관계없이 등록된 모든 스토어로 보내진다는 점입니다.
이말은, 스토어가 특정 액션만 구독하지않고 모든 액션을 일단 받은 뒤 처리할지말지 결정한다는 뜻입니다.

- 스토어
스토어는 애플리케이션 내의 모든 상태와 그와 관련된 로직을 가지고 있습니다.

스토어는 모든것을 관리하는 정부관료와 같습니다.
모든 상태변경은 반드시 스토어에의해서 결정되어야만 하며, 상태 변경을 위한 요청을 스토어에 직접 보낼 수는 없습니다.
무조건 액션생성자/디스패쳐 파이프라인을 거쳐서 액션을 보내야만 합니다.

만약 스토어가 디스패쳐에 등록되어 있ㄸ가면, 모든 액션을 받게 될 것입니다.
스토어의 내부에서는 보통 switch statement를 사용해서 처리할 액션과 무시할 액션을 결정하게 됩니다.
만약 처리가 필요한 액션이라면, 주어진 액션에 따라서 무엇을 할 지 결정하고 상태를 변경하게 됩니다.

일단 스토어에 상태 변경을 완료하고나면, 변경이벤트를 내보냅니다.
이 이벤트는 컨트롤러 뷰에 상태가 변경했다는 것을 알려주게됩니다.

-컨트롤러 뷰와 뷰
뷰는 상태를 가져오고 유저에게 보여주고 입력받을 화면을 렌더링하는 역할을 맡습니다.
뷰는 발표자와 같습니다.
애플리케이션 내부에 대해서 아는것이 없지만, 받은 데이터를 처리해서 사람들이 이해할 수 있는 포맷으로 어떻게 바꾸는지 알고 있습니다.

컨트롤러 뷰는 스토어와 뷰 사이의 중간관리자같은 역할을 합니다.
상태가 변경되었을때 스토어가 그 사실을 컨트롤러 뷰에게 알려주면, 컨트롤러 뷰는 자신의 아래에 있는 모든 뷰에게 새로운 상태를 넘겨줍니다.

-어떻게 이 캐릭터들이 함께 동작하는가?

- 준비
먼저 애플리케이션이 초기화할때 딱 한번 준비과정을 가집니다.

1) 스토어는 디스패쳐에 액션이 들어오면 알려달라고 말해둡니다.
2) 컨트롤러 뷰는 스토어에게 최신 상태를 묻습니다.
3) 스토어가 컨트롤러 뷰에게 상태를 주면 렌더링하기 위해 모든 자식 뷰에게 상태를 넘겨줍니다.
4) 컨트롤러 뷰는 스토어에게 상태가 바뀔때 알려달라고 다시 부탁합니다.

- 데이터 흐름
준비과정이 끝나면 애플리케이션은 유저입력을 위한 준비가 완료됩니다.
사용자의 입력으로 인해 액션이 생겼을 경우를 보겠습니다.
 
1) 뷰는 액션 생성자에게 액션을 준비하라고 말합니다.
2) 액션생성자는 액션을 포맷에 맞게 만들어서 디스패쳐에 넘겨줍니다.
3) 디스패쳐는 들어온 액션의 순서에 맞게 알맞은 스토어로 보내줍니다. 각 스터오는 모든 액션을 받게 되지만 필요한 액션만을 골라서 상태를 필요에 맞게 변경합니다.
4) 상태 변경이 완료되면 스토어는 자신을 구독하고잇는 컨트롤러 뷰에게 그 사실을 알립니다.
5) 연락을 받은 컨트롤러 뷰들은 스토어에게 변경된 상태를 요청합니다.
6) 스토어가 새로운 상태를 넘겨주면 컨트롤러 뷰는 자신 아래의 모든 뷰에게 새로운 상태에 맞게 렌더링하라고 알려줍니다.


~~~

