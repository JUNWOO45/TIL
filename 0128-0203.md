<h1>
    0129
</h1>



~~~
리덕스는 MVC패턴을 대체하기 위해서 페이스북이 사용한 Flux패턴을 살짝 바꾼것이라고 합니다.

그렇다면 먼저 Flux를 알아보는게 좋을 것 같습니다.

Flux는 애플리케이션에서 데이터를 취급하기위한 패턴입니다.
Flux와 React는 페이스북에서 함께 성장해왔습니다.
이 둘은 페이스북이 가지고 있었던 특정 문제점을 해결하기 위해서 개발되었다고합니다.
그 중 가장 많이 알려져있던 문제점이 알림버그입니다.

이전에는 데이터를 가지고 있는 모델(model)이 렌더링하기위해 뷰레이어로 데이터를 보냈을 것입니다.
사용자와의 상호작용(user interaction)이 뷰를 통해서 일어났기때문에 사용자의 입력에 따라 뷰가 가끔씩 모델을 업데이트해야할 필요가 있었습니다.
그리고 의존성때문에 모델이 다른 모델을 업데이트해야할 때도 있었습니다.

어떤 한 변경이 다른 변경을 초래하기도 했습니다.
또한 이런 변경들이 비동기적으로 생기기도했습니다.

이러한 데이터흐름은 디버그하기 어렵게 만들었습니다.

- 해결책: 단방향 데이터 흐름(unidirectional data flow)
그래서 페이스북은 다른 종류의 아키텍처를 시도하기로 결정했습니다.
이 구조에서 데이터는 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 흐름이 다시 시작됩니다.
이 아키텍처를 Flux라고 불렀습니다.

Action -> Dispatcher -> Store -> View -> Action...

캐릭터들을 만나보겠습니다.

- 액션 생성자
첫번째 캐릭터는 액션생성자입니다.
모든 변경사항과 사용자와의 상호작용기 거쳐가야하는 액션의 생성을 담당하고있습니다.
언제든 애플리케이션의 상태를 변경하거나 뷰를 업데이트하고싶다면 액션을 생성해야만합니다.

액션 생성자는 전보기사와 같습니다. 메세지를 포맷에 맞게 변환시켜줍니다.
어떤 메세지를 보낼지 알려주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷으로 바꿔준다.
액션생성자는 타입과 페이로드를 포함한 액션을 생성합니다.
...
일단 액션생성자가 액션 메세지를 생성한 뒤에는 디스패쳐로 넘겨줍니다.

-디스패쳐
디스패쳐는 기본적으로 콜백이 등록되어있는 곳입니다.
디스패쳐는 전화교환대에서 교환원이 일하는 것과 같습니다.
디스패쳐는 액션을 보낼 필요가 잇는 모든 스토어를 가지고 있고, 액션 생성자로부터 액션이 넘어오면 여러 스토어에 액션을 보냅니다.

이 처리는 동기적으로 실행되어서 위쪽에서 이야기했던 다수의 공으로 플레이하는 핑퐁게임같은 경우를 처리하는데 도움을 줍니다.
만약 스토어들 사이에 의존성이 있어서 하나를 다른것보다 먼저 업데이트해야한다면, 디스패쳐가 적절히 처리하도록 할 수 있습니다.

Flux의 디스패쳐는 다른 아키텍쳐들과는 조금 다른점이 있습니다.
액션타입과는 관계없이 등록된 모든 스토어로 보내진다는 점입니다.
이말은, 스토어가 특정 액션만 구독하지않고 모든 액션을 일단 받은 뒤 처리할지말지 결정한다는 뜻입니다.

- 스토어
스토어는 애플리케이션 내의 모든 상태와 그와 관련된 로직을 가지고 있습니다.

스토어는 모든것을 관리하는 정부관료와 같습니다.
모든 상태변경은 반드시 스토어에의해서 결정되어야만 하며, 상태 변경을 위한 요청을 스토어에 직접 보낼 수는 없습니다.
무조건 액션생성자/디스패쳐 파이프라인을 거쳐서 액션을 보내야만 합니다.

만약 스토어가 디스패쳐에 등록되어 있ㄸ가면, 모든 액션을 받게 될 것입니다.
스토어의 내부에서는 보통 switch statement를 사용해서 처리할 액션과 무시할 액션을 결정하게 됩니다.
만약 처리가 필요한 액션이라면, 주어진 액션에 따라서 무엇을 할 지 결정하고 상태를 변경하게 됩니다.

일단 스토어에 상태 변경을 완료하고나면, 변경이벤트를 내보냅니다.
이 이벤트는 컨트롤러 뷰에 상태가 변경했다는 것을 알려주게됩니다.

-컨트롤러 뷰와 뷰
뷰는 상태를 가져오고 유저에게 보여주고 입력받을 화면을 렌더링하는 역할을 맡습니다.
뷰는 발표자와 같습니다.
애플리케이션 내부에 대해서 아는것이 없지만, 받은 데이터를 처리해서 사람들이 이해할 수 있는 포맷으로 어떻게 바꾸는지 알고 있습니다.

컨트롤러 뷰는 스토어와 뷰 사이의 중간관리자같은 역할을 합니다.
상태가 변경되었을때 스토어가 그 사실을 컨트롤러 뷰에게 알려주면, 컨트롤러 뷰는 자신의 아래에 있는 모든 뷰에게 새로운 상태를 넘겨줍니다.

-어떻게 이 캐릭터들이 함께 동작하는가?

- 준비
먼저 애플리케이션이 초기화할때 딱 한번 준비과정을 가집니다.

1) 스토어는 디스패쳐에 액션이 들어오면 알려달라고 말해둡니다.
2) 컨트롤러 뷰는 스토어에게 최신 상태를 묻습니다.
3) 스토어가 컨트롤러 뷰에게 상태를 주면 렌더링하기 위해 모든 자식 뷰에게 상태를 넘겨줍니다.
4) 컨트롤러 뷰는 스토어에게 상태가 바뀔때 알려달라고 다시 부탁합니다.

- 데이터 흐름
준비과정이 끝나면 애플리케이션은 유저입력을 위한 준비가 완료됩니다.
사용자의 입력으로 인해 액션이 생겼을 경우를 보겠습니다.
 
1) 뷰는 액션 생성자에게 액션을 준비하라고 말합니다.
2) 액션생성자는 액션을 포맷에 맞게 만들어서 디스패쳐에 넘겨줍니다.
3) 디스패쳐는 들어온 액션의 순서에 맞게 알맞은 스토어로 보내줍니다. 각 스터오는 모든 액션을 받게 되지만 필요한 액션만을 골라서 상태를 필요에 맞게 변경합니다.
4) 상태 변경이 완료되면 스토어는 자신을 구독하고잇는 컨트롤러 뷰에게 그 사실을 알립니다.
5) 연락을 받은 컨트롤러 뷰들은 스토어에게 변경된 상태를 요청합니다.
6) 스토어가 새로운 상태를 넘겨주면 컨트롤러 뷰는 자신 아래의 모든 뷰에게 새로운 상태에 맞게 렌더링하라고 알려줍니다.
~~~

~~~
Redux

3가지 원칙

1)Single Source of Truth
리덕스는 어플리케이션의 state를 위해 단 한개의 store를 사용합니다.
flux와의 주요 차이입니다.
flux에서는 여러개의 store를 사용합니다.

2)State is Read-only
어플리케이션에서 store의 state를 직접 변경할 수 없습니다.
state를 변경하기 위해선 무조건 action이 dispatch되어야합니다.

3) Changes are mad with pure Functions
action객체를 처리하는 함수를 reducer라고 부릅니다.
reducer는 정보를 받아서 상태를 어떻게 업데이트할 지 정의합니다.

reducer는 순수함수로 작성되어야합니다.
즉, 네트워크 및 데이터베이스 접근x, 인수변경x
같은 인수로 실행된 함수는 언제나 같은 결과를 반환해야합니다.
순수하지않은 API사용불가(Date.now(), Math.random() 등)


http://bestalign.github.io/2015/10/26/cartoon-intro-to-redux/

- 왜 Flux를 바꿔야하나?
Flux와 같이 Redux도 애플리케이션의 상태를 더욱 예측 가능하게 만들어줍니다.
만약에 상태를 변경하고 싶다면 액션을 발생시켜야 합니다.
상태를 저장하고 있는 스토어는 접근자만 있고 설정자는 없으므로 직접적으로 상태를 바꿀 방법이 존재하지 않습니다.
이런 기본적인 점은 Flux와 Redux가 아주 비슷합니다.

그렇다면 왜 다른 패턴이 필요할까요?
Redux를 만든 댄 아브라모브는 Flux를 더 향상시킬 수 있다는 사실을 찾아냈습니다.

문제점1. 스토어의 코드는 애플리케이션 상태를 삭제하지않고는 리로딩이 불가능하다.
Flux에서 스토어는 다음의 두가지를 포함합니다.
1. 상태 변환을 위한 로직
2. 현재 애플리케이션의 상태

스토어 객체 하나가 이 두가지를 가지고 있는것은 핫 리로딩을 할때 문제점을 만듭니다.
새로운 상태변환로직을 위해 스토어객체를 리로딩하면 스토어에 저장되어있는 기존의 상태까지 잃어버리는데다가 스토어와 시스템의 나머지 부분 사이에 있는 이벤트 구독까지 망가져버립니다.

해결방법 :
두 기능을 분리하도록 하자.
한 객체는 애플리케이션의 상태만을 가지게하고, 이 객체는 리로딩하지 않도록 하자.
또 다른 객체는 모든 상태변환로직을 가지도록하자.
이 객체는 상태를 가지고 있지 않으므로 걱정없이 리로딩할 수 있을 것입니다.

문제점 2. 애플리케이션 상태는 매 액션마다 재기록된다.
시간여행 디버깅을 위해서는 상태 객체의 모든 버전들을 기록해두어야합니다.
그걸 가지고 쉽게 이전상태로 돌아갈 수 있습니다.

매번 상태가 새로 바뀔때마다 이전 애플리케이션 상태를 상태 객체의 버전들을 저장하는 배열에 추가할 필요가 있습니다. 
하지만 자바스크립트의 동작방식때문에 단순히 상태를 가진 변수를 배열에다가 추가하는 것만으로는 부족합니다.
이 방식으로는 애플리케이션 상태의 스냅샷을 생성하는게 아니라 같은 객체를 가리키는 새로운 포인터를 만들뿐입니다.

제대로 동작하게 만들기 위해서는 각각의 버전이 완벽히 독립된 객체가 될 필요가 있습니다.
그러면 이전 상태들이 실수로 수정되는 일은 일어나지 않을 것입니다.

해결방법 : 
액션이 스토어로 전달되었을때 기존의 어플리케이션 상태를 수정하는 대신, 그 상태를 복사한 뒤 복사본을 수정하면 됩니다.

문제점 3. 서드파티 플러그인이 들어갈 좋은 장소가 없다.
개발자도구는 여러곳에 쉽게 쓰일 수 있도록 만들어야합니다.
사용자는 자신의 코드를 수정하지 않고도 간단히 코드 몇 줄을 집어넣는 것만으로 개발자 도구를 사용할 수 있어야합니다.

해결방법 : 
시스템의 부분을 다른 객체들로 쉽게 감쌀 수 있게 만들어보자.
또한 상태변환 로직을 트리를 사용해서 구조화하자.
(어렵네요..무슨 소리인지....)


새로운 캐릭터들

- 액션 생성자
리덕스는 플럭스에서 액션 생성자를 그대로 가져왔습니다.
애플리케이션 상태를 바꾸고 싶다면 항상 액션을 보내야만 합니다.
이것이 상태를 바꾸기 위한 유일한 방법입니다.
플럭스에대한 이전 글에서 이야기했듯이 액션 생성자는 전보기사와 하는 일이 비슷핣니다.
어떤 메세지를 보내고 싶은지 액션 생성자에게 알려주면, 나머지 시스템이 이해할 수 있는 포맷으로 바꾸어줍니다.
플럭스와 다르게 리덕스의 액션생성자는 디스패쳐로 액션을 보내지 않습니다.
대신, 포맷을 바꾼뒤 액션을 돌려줍니다.

- 스토어
Flux의 스토어는 모든 것을 관리하는 정부관료와 같다고 이야기했었습니다.
모든 상태변화는 스토어에 의해서 이루어져야하고 스토어로 직접 요청하는 대신 액션 파이프라인을 따라가야합니다.
리덕스의 스토어도 같은역할을 하지만, 플럭스와는 조금 다릅니다.

플럭스에서는 다수의 스토어를 가질 수 있습니다.
각 스토어는 각자의 범위를 갖고 그 내부의 모든 컨트롤을 가집니다.
그리고 애플리케이션 상태 중 한 조각을 가지고 있고, 그 상태 조각과 관련된 모든 변화 로직을 가집니다.

반면, 리덕스의 스토어는 좀 더 일을 다른곳에 위임하는 경향이 있으며, 그렇게 해야만합니다.
왜냐하면 리덕스는 단 하나의 스토어만을 가지기 때문입니다.
만약 혼자서 모든 일을 처리하려고한다면 아마 처리할 양이 너무나 많을 것입니다.

대신, 리덕스의 스토어는 상태트리 전체를 유지하는 책임을 집니다.
액션이 들어왔을때 어떤 상태변화가 필요한지에 대한 일은 위임하며, 바로 다음에 이야기할 리듀서가 그 일을 맡습니다.

- 리듀서
스토어는 액션이 어떤 상태변화를 만드는지 알 필요가 있을때 리듀서에게 묻습니다.
루트 리듀서는 애플리케이션 상태 객체의 키를 기준삼아 상태를 조각조각 나눕니다.
이렇게 나누어진 상태 조각은 그 조각을 처리할 줄 아는 리듀서에게 넘겨줍니다.

리듀서는 마치 서류 복사를 지나치게 열정적으로 하는 사무실 직원과 같습니다.
일을 망치는 것에 아주 민감해서 넘겨받은 예전 상태는 변경하지 않습니다.
대신 새로운 복사본을 만들고, 거기에다가 모든 변경사항을 적용합니다.

이것이 바로 리덕스의 핵심 아이디어 중 하나입니다.
상태 객체는 직접 변경되지 않습니다.
대신, 각각의 상태 조각이 복사 후 변경되고 새로운 상태 객체 하나로 합쳐집니다.

리듀서는 복사되고 업데이트된 상태 객체를 루트 리듀서에게 넘겨주고, 루트 리듀서는 이 객체를 스토어로 보냅니다.
그리고 스토어는 이 객체를 새로운 애플리케이션 상태로 만듭니다.

- 뷰: 똑똑한 컴포넌트와 멍청한 컴포넌트
플럭스는 컨트롤러 뷰와 일반 뷰를 가지고 있습니다.
컨트롤러 뷰는 중간 관리자 같아서 스토어와 자식 뷰 사이에서 커뮤니케이션을 관리하죠.

리덕스도 비슷한 컨셉을 가지고 있습니다.
똑똑한 컴포넌트와 멍청한 컴포넌트가 그것입니다.
똑똑한 컴포넌트는 관리자처럼 행동하는데, 플럭스의 컨트롤러뷰보다 몇가지 규칙을 더 가지고 있습니다.
1) 똑똑한 컴포넌트는 액션 처리를 책임집니다. 똑똑한 컴포넌트 밑의 멍청한 컴포넌트가 액션을 보낼 필요가 있을 때, 똑똑한 컴포넌트는 props를 통해서 멍청한 컴포넌트에 함수를 보냅니다. 멍청한 컴포넌트는 받은 함수를 콜백으로써 단순히 호출만 합니다.
2) 똑똑한 컴포넌트는 자기 자신의 CSS style을 가지고 있지 않습니다.
3) 똑똑한 컴포넌트는 자기 자신의DOM을 거의 가지고 있지 않습니다. 대신 DOM요소들을 관리하는 멍청한 컴포넌트들을 관리합니다.

멍청한 컴포넌트는 액션에 직접 의존성을 가지지 않습니다.
이는 모든 액션을 props를 통해서 넘겨받기 때문입니다.
이말인 즉슥, 멍청한 컴포넌트는 다른 로직을 가진 다른 애플리케이션에서 재사용될 수 있다는 소리입니다.

- 뷰 레이어 바인딩
스토어를 뷰에 연결하기위해서 리덕스는 약간의 도움이 필요합니다.
그 둘을 함께 묶어줄 무엇인가가 필요한데, 이걸 해주는것이 바로 뷰 레이어 바인딩입니다.
리액트를 사용한다면 reacdt-redux가 그것이죠.

뷰 레이어 바인딩은 뷰 트리를 위한 IT부서와 같습니다.
모든 컴포넌트를 스토어에 연갈하는 역할을 하며, 많은 기술적인 세부사항들을 처리해서 트리 구조가 세부사항에 신경쓰지 않도록 해줍니다.

뷰 레이어 바인딩은 세가지 컨셉을 가지고 있습니다.
1) 공급 컴포넌트 : 컴포넌트 트리를 감싸는 컴포넌트입니다. connect()를 이용해 루트 컴포넌트 밑의 컴포너느들이 스토어에 연결되기 쉽게 만들어줍니다.
2) connect(): react-redux가 제공하는 함수입니다. 컴포넌트가 애플리케이션 상태 업데이트를 받고 싶으면 connect()를 이용해서 컴포넌트를 감싸주면 됩니다. 그러면 connect()가 셀렉터를 이용해서 필요한 모든 연결을 만들어 줍니다.
3) 셀렉터: 직접 만들어야하는 함수입니다. 어플리케이션 상태 안의 어느 부분이 커모넌트에 props로써 필요한 것인지 지정합니다.

- 루트 컴포넌트
모든 리액트 어플리케이션은 루트 컴포넌트를 가집니다.
이것은 단지 컴포넌트 계층 구조에서 가장 위에 위치하는 컴포넌트일 뿐입니다.
하지만 리덕스에서는 루트 컴포넌트는 추가로 책임져야 할 것이 존재합니다.

루트 컴포넌트가 맡는 임무는 마치 CEO와 같습니다.
모든 팀이 일을 하도록 하는 임무를 가집니다.
스토어를 생성하고, 무슨 리듀서를 사용할 지 알려주며 뷰 레이어 바인딩과 뷰를 불러옵니다.

하지만 루트 컴포넌트는 애플리케이션을 초기화한 뒤로는 거의 일을 하지 않습니다.

- 어떻게 함께 동작하는가?

- 준비
1) 스토어를 준비합니다.
2) 스토어와 컴포넌트 사이의 커뮤니케이션을 준비합니다.
3) 액션콜백을 준비합니다.

- 데이터흐름
1) 뷰가 액션을 요청합니다. 액션 생성자가 포맷을 변환한 뒤 돌려줍니다.
2) bindActionCreators()가 준비과정에서 사용되었으면 자동으로 액션이 보내집니다. 그게 아니라면 뷰가 직접 액션을 보냅니다.
3) 스토어가 액션을 받습니다. 현재 애플리케이션 상태 트리와 액션을 루트 리듀서에게 보냅니다.
4) 루트 리듀서는 상태 트리를 조각으로 나눈 뒤 알맞은 서브 리듀서로 상태 조각들을 넘겨줍니다.
5) 서브 리듀서는 받은 상태조각을 복사한 뒤, 그 복사본을 변경합니다. 루트 리듀서에게 변경된 복사본을 돌려줍니다.
6) 모든 서브 리듀서가 변경된 상태 조각들을 돌려주면, 루트 리듀서는 이 상태조각들을 할ㄴ데 모아 상태 트리로 만든 뒤 스토어로 돌려줍니다. 스토어는 새로운 상태트리를 옛날 상태트리와 바꿉니다.
7) 스토어는 뷰 레이어 바인딩에게 애플리케이션 상태가 변경되었다는 것을 알립니다.
8) 뷰 레이어 바인딩은 스토어에게 새로운 상태를 보내달라고 요청합니다.
9) 뷰 레이어 바인딩은 뷰에게 화면을 업데이트하도록 요청핣니다.

~~~



<h1>
    0130
</h1>



export default connect()(AddToDo) 가 container component인 것.

AddToDo가 container component가 아니다.



~~~
combineReducers

reducer는 단순 함수.

~~~



미들웨어

~~~
ex) redux-logger

createStore할때 두번째 인자로 applyMiddleward(logger)넣어줌.

디버깅하기가 굉장히 쉬워짐.

~~~



react-redux

~~~
핵심은 Provider

<Provider store = {store}>
	<App />
</Provider>


두번째 핵심 connect([...options])
- 컴포넌트를 redux에 연결하는 함수를 반환합니다.
~~~

~~~
reducer함수
1) 우선 ActionTypes를 불러와야함.
2) 리듀서 함수가 파라미터로 이전 상태값과 action을 전달받을거니깐 초기값을 지정해야함.
3) export 해주며 함수를 써줘야함.
4) 일반적으로 switch문을 사용해서 reducer함수를 작성함.
5) 리듀서 함수가 여러개일때는 index.js를 만들어서 combineReduucers를 이용해서 합쳐줘야함.
~~~

~~~
store
:스토어를 만드려면 reduux에서 createStore를 불러운 다음에 reducer를 인수로 전달하여 해당 함수를 실행해야함.

1)src폴더에 있는 index.js에서 createStore를 불러오고, reducers(여기선 index.js)를 불러온다.
2) store를 만들어준다.
store에는 
1.dispatch(action): action을 reducer로 보낸다는 의미
2.getState(): 현재 상태를 반환
3.subscribe(listener)
등의 기능이 있다.
~~~



<h1>
    0131
</h1>

- Action

: "작업에 대한 정보"를 지니고 있는 객체

- Reducer

: 변화를 일으키는 함수( 1. 비동기 작업 x 2. 전달받은 인수 변경x 3.동일한 인수 = 동일한 결과)

: 이전 상태와 액션을 받아서 다음 상태를 반환한다.

: 이전 상태를 변경하는게 아님. 그저 새로운 상태를 반환하는것.

: 기존 상태를 복사하고 변화를 준 다음에 반환.



- Store

: 어플리케이션의 현재상태



<h1>
    0201
</h1>

https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape

~~~
많은 어플리케이션들이 nested 자료를 다룹니다.
예를들어, 블로그 에디어는 많은 포스트들, 그리고 각각의 포스트에 포함된 많은 댓글들, 댓글과 포스트의 작성자등의 정보를 가지고 있습니다.
이러한 데이터는 다음과 같이 보여집니다.

const blogPosts = [
  {
    id: 'post1',
    author: { username: 'user1', name: 'User 1' },
    body: '......',
    comments: [
      {
        id: 'comment1',
        author: { username: 'user2', name: 'User 2' },
        comment: '.....'
      },
      {
        id: 'comment2',
        author: { username: 'user3', name: 'User 3' },
        comment: '.....'
      }
    ]
  },
  {
    id: 'post2',
    author: { username: 'user2', name: 'User 2' },
    body: '......',
    comments: [
      {
        id: 'comment3',
        author: { username: 'user3', name: 'User 3' },
        comment: '.....'
      },
      {
        id: 'comment4',
        author: { username: 'user1', name: 'User 1' },
        comment: '.....'
      },
      {
        id: 'comment5',
        author: { username: 'user3', name: 'User 3' },
        comment: '.....'
      }
    ]
  }
  // and repeat many times
]

이러한 구조는 복잡하고, 몇몇 데이터는 반복된다는걸 알 수 있습니다.
이러한 구조는 몇가지 이유들로 인해 문제가 됩니다.
- 몇몇 군데에서의 중복된 데이터는, 적절하게 업데이트되는것을 방해합니다.
- nested 데이터는 똑같은 reducer로직이 nested되었다는 것을 의미하고, 이는 복잡함을 의미합니다. 특히, 매우 깊게 nested된 파일을 업데이트하려면 어렵습니다.
- Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.
(변경할 수 없는 데이터 업데이트에는 상태 트리의 모든 상위 항목도 복사 및 업데이트되어야 하고, 새 개체 참조로 인해 연결된 UI 구성 요소가 다시 렌더링되므로, 너무 중첩된 데이터 개체를 업데이트하면 표시 중인 데이터가 실제로 변경되지 않았더라도 전혀 관련이 없는 UI 구성 요소가 다시 반환될 수 있습니다.)

그래서 우리는 정규화를 해야합니다.

정규화의 기본 컨셉은 다음과 같습니다.
- 각각의 데이터타입은 state안에서 자기 자신만의 테이블을 갖습니다.
- 각각의 데이터 테이블은 아이템의 id값을 key로, 아이템 스스로를 values로 하는 각각의 객체를 저장합니다.
- 각각의 아이템은 저장된 id값으로 불러올 수 있습니다.

정규화된 블로그 데이터 예제는 다음과 같습니다.
{
    posts : {
        byId : {
            "post1" : {
                id : "post1",
                author : "user1",
                body : "......",
                comments : ["comment1", "comment2"]
            },
            "post2" : {
                id : "post2",
                author : "user2",
                body : "......",
                comments : ["comment3", "comment4", "comment5"]
            }
        },
        allIds : ["post1", "post2"]
    },
    comments : {
        byId : {
            "comment1" : {
                id : "comment1",
                author : "user2",
                comment : ".....",
            },
            "comment2" : {
                id : "comment2",
                author : "user3",
                comment : ".....",
            },
            "comment3" : {
                id : "comment3",
                author : "user3",
                comment : ".....",
            },
            "comment4" : {
                id : "comment4",
                author : "user1",
                comment : ".....",
            },
            "comment5" : {
                id : "comment5",
                author : "user3",
                comment : ".....",
            },
        },
        allIds : ["comment1", "comment2", "comment3", "commment4", "comment5"]
    },
    users : {
        byId : {
            "user1" : {
                username : "user1",
                name : "User 1",
            },
            "user2" : {
                username : "user2",
                name : "User 2",
            },
            "user3" : {
                username : "user3",
                name : "User 3",
            }
        },
        allIds : ["user1", "user2", "user3"]
    }
}

이러한 state구조는 전체적으로 더욱 flatter합니다.
기존 구조와 비교해본다면 다음과 같은 개선점을 가지고 있습니다.
- 각각의 아이템은 오직 한곳에서만 정의되어 있으므로, 아이템을 업데이트할때 여러군데에서 반복해서 업데이트할 필요가 없습니다.
- reducer 로직이 더이상 깊은 레벨의 nesting까지 신경쓰지 않아도 되서 더욱 심플합니다.
- 검색이나 업데이트로직이 매우 간결하고 일관성있습니다. 아이템의 타입이나 id가 주어지면 객체의 깊은곳까지 파고들어갈 필요없이, 매우 간단한 단계를 통해 접근할 수 있습니다.
- 각각의 데이터타입이 분리되어있어서, 댓글을 수정하는 업데이트는 오직 "comments >byId > comment로의 접근으로 수정가능합니다. 이것은 일반적으로 데이터가 변경됨으로써 업데이트해야하는 UI가 적다는 것을 의미합니다.
이와 반대로, 원래의 중첩된형태의 댓글을 업데이트하려면, 댓글 객체, 그 상위 객체, 모든 포스트배열 객체등을 싹 다 업데이트 했어야했습니다.

정규화된 state구조는 일반적으로 더욱 많은 컴포넌트와 연결되어있지만, 더욱 적은 컴포넌트를 책임져야 한다는 것을 의미합니다. 기존 구조에서는 더욱 적은컴포넌트와 연결되어있지만 더 많은 데이터가 오고갔습니다.
부모 구성요소가 단순히 id를 통해 연결된 하위 항목으로 데이터를 전달하는 것은 리액트 리덕스 어플리케이션에서 ui성능을 최적화하기 좋은 패턴입니다.

일반적은 어플리케이션에서는 관계가있는 데이터와 관계가없는 데이터가 섞여있을 확률이 있습니다.
이러한 두가지 다른 데이터들을 어떻게 분류할 것인지에대한 정확한 룰은 없지만, 한가지 일반적인 패턴은 "항목"과 같은 관계된 "테이블"을 공통된 상위 key아래에 두는 것입니다.
이러한 방법을 적용한 예는 다음과 같습니다.
{
    simpleDomainData1: {....},
    simpleDomainData2: {....},
    entities : {
        entityType1 : {....},
        entityType2 : {....}
    },
    ui : {
        uiSection1 : {....},
        uiSection2 : {....}
    }
}

이러한 방법은 몇가지 방법으로 더욱 확장될 수 있습니다.
예를 들어, 항목을 많이 편집하는 어플리케이션은 두 세트의 "테이블"을 상태로 유지할 수 있습니다. 하나는 "current"아이템이고, 다른 하나는 "작업중"항목입니다.
아이템이 수정되면, 아이템의 value값은 "작업중"항목으로 복사되어집니다. 아이템의 값을 업데이트하는 액션이 일어나면 "작업중"항목으로 복사합니다.
"Resetting" the edit form would simply require removing the item from the "work-in-progress" section and re-copying the original data from "current" to "work-in-progress", while "applying" the edits would involve copying the values from the "work-in-progress" section to the "current" section.

우리는 리덕스를 "데이터베이스"의 일부로 다루기때문에, 수많은 데이터베이스 디자인들이 적용될 수 있습니다.
예를 들어, 만약 우리가 너무너무많은 관계를 가지고 있다면, 우리는 해당 아이템의 id를 저장하는 중간 테이블을 사용하여 모델링할 수도 있습니다.
일관성을 위해, 우리는 byId와 allId를 사용할 수 잇습니다.
{
    entities: {
        authors : { byId : {}, allIds : [] },
        books : { byId : {}, allIds : [] },
        authorBook : {
            byId : {
                1 : {
                    id : 1,
                    authorId : 5,
                    bookId : 22
                },
                2 : {
                    id : 2,
                    authorId : 5,
                    bookId : 15,
                },
                3 : {
                    id : 3,
                    authorId : 42,
                    bookId : 12
                }
            },
            allIds : [1, 2, 3]

        }
    }
}

이러한 구조에서는 "이 작가의 모든 책보기"같은 행동은 굉장히 쉽게 동작하게 됩니다.

API는 대체로 nested한 형태의 데이터를 보내옵니다. 그래서 이러한 데이터들은 정규화가 필요하죠.
https://github.com/paularmstrong/normalizr
이 라이브러리가 보통 이러한 일에 쓰입니다!

~~~



